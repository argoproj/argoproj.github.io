{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-commander-65ee086192df02c3cd44.js","webpack:///./.cache/json/docs-argo-ci-node-modules-commander.json"],"names":["webpackJsonp","2186","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,2iXAAm4WC,QAAA,wCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-commander-65ee086192df02c3cd44.js","sourcesContent":["webpackJsonp([62979176296541],{\n\n/***/ 2186:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>Commander.js</h1>\\n<p><a href=\\\"http://travis-ci.org/tj/commander.js\\\"><img src=\\\"https://api.travis-ci.org/tj/commander.js.svg?branch=master\\\" alt=\\\"Build Status\\\"></a>\\n<a href=\\\"https://www.npmjs.org/package/commander\\\"><img src=\\\"http://img.shields.io/npm/v/commander.svg?style=flat\\\" alt=\\\"NPM Version\\\"></a>\\n<a href=\\\"https://www.npmjs.org/package/commander\\\"><img src=\\\"https://img.shields.io/npm/dm/commander.svg?style=flat\\\" alt=\\\"NPM Downloads\\\"></a>\\n<a href=\\\"https://gitter.im/tj/commander.js?utm_source=badge&#x26;utm_medium=badge&#x26;utm_campaign=pr-badge&#x26;utm_content=badge\\\"><img src=\\\"https://badges.gitter.im/Join%20Chat.svg\\\" alt=\\\"Join the chat at https://gitter.im/tj/commander.js\\\"></a></p>\\n<p>  The complete solution for <a href=\\\"http://nodejs.org\\\">node.js</a> command-line interfaces, inspired by Ruby's <a href=\\\"https://github.com/commander-rb/commander\\\">commander</a>.<br>\\n<a href=\\\"http://tj.github.com/commander.js/\\\">API documentation</a></p>\\n<h2>Installation</h2>\\n<pre><code>$ npm install commander --save\\n</code></pre>\\n<h2>Option parsing</h2>\\n<p> Options with commander are defined with the <code>.option()</code> method, also serving as documentation for the options. The example below parses args and options from <code>process.argv</code>, leaving remaining args as the <code>program.args</code> array which were not consumed by options.</p>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .option('-p, --peppers', 'Add peppers')\\n  .option('-P, --pineapple', 'Add pineapple')\\n  .option('-b, --bbq-sauce', 'Add bbq sauce')\\n  .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')\\n  .parse(process.argv);\\n\\nconsole.log('you ordered a pizza with:');\\nif (program.peppers) console.log('  - peppers');\\nif (program.pineapple) console.log('  - pineapple');\\nif (program.bbqSauce) console.log('  - bbq');\\nconsole.log('  - %s cheese', program.cheese);\\n</code></pre>\\n<p> Short flags may be passed as a single arg, for example <code>-abc</code> is equivalent to <code>-a -b -c</code>. Multi-word options such as \\\"--template-engine\\\" are camel-cased, becoming <code>program.templateEngine</code> etc.</p>\\n<h2>Coercion</h2>\\n<pre><code class=\\\"language-js\\\">function range(val) {\\n  return val.split('..').map(Number);\\n}\\n\\nfunction list(val) {\\n  return val.split(',');\\n}\\n\\nfunction collect(val, memo) {\\n  memo.push(val);\\n  return memo;\\n}\\n\\nfunction increaseVerbosity(v, total) {\\n  return total + 1;\\n}\\n\\nprogram\\n  .version('0.1.0')\\n  .usage('[options] &#x3C;file ...>')\\n  .option('-i, --integer &#x3C;n>', 'An integer argument', parseInt)\\n  .option('-f, --float &#x3C;n>', 'A float argument', parseFloat)\\n  .option('-r, --range &#x3C;a>..&#x3C;b>', 'A range', range)\\n  .option('-l, --list &#x3C;items>', 'A list', list)\\n  .option('-o, --optional [value]', 'An optional value')\\n  .option('-c, --collect [value]', 'A repeatable value', collect, [])\\n  .option('-v, --verbose', 'A value that can be increased', increaseVerbosity, 0)\\n  .parse(process.argv);\\n\\nconsole.log(' int: %j', program.integer);\\nconsole.log(' float: %j', program.float);\\nconsole.log(' optional: %j', program.optional);\\nprogram.range = program.range || [];\\nconsole.log(' range: %j..%j', program.range[0], program.range[1]);\\nconsole.log(' list: %j', program.list);\\nconsole.log(' collect: %j', program.collect);\\nconsole.log(' verbosity: %j', program.verbose);\\nconsole.log(' args: %j', program.args);\\n</code></pre>\\n<h2>Regular Expression</h2>\\n<pre><code class=\\\"language-js\\\">program\\n  .version('0.1.0')\\n  .option('-s --size &#x3C;size>', 'Pizza size', /^(large|medium|small)$/i, 'medium')\\n  .option('-d --drink [drink]', 'Drink', /^(coke|pepsi|izze)$/i)\\n  .parse(process.argv);\\n  \\nconsole.log(' size: %j', program.size);\\nconsole.log(' drink: %j', program.drink);\\n</code></pre>\\n<h2>Variadic arguments</h2>\\n<p> The last argument of a command can be variadic, and only the last argument.  To make an argument variadic you have to\\nappend <code>...</code> to the argument name.  Here is an example:</p>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .command('rmdir &#x3C;dir> [otherDirs...]')\\n  .action(function (dir, otherDirs) {\\n    console.log('rmdir %s', dir);\\n    if (otherDirs) {\\n      otherDirs.forEach(function (oDir) {\\n        console.log('rmdir %s', oDir);\\n      });\\n    }\\n  });\\n\\nprogram.parse(process.argv);\\n</code></pre>\\n<p> An <code>Array</code> is used for the value of a variadic argument.  This applies to <code>program.args</code> as well as the argument passed\\nto your action as demonstrated above.</p>\\n<h2>Specify the argument syntax</h2>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .arguments('&#x3C;cmd> [env]')\\n  .action(function (cmd, env) {\\n     cmdValue = cmd;\\n     envValue = env;\\n  });\\n\\nprogram.parse(process.argv);\\n\\nif (typeof cmdValue === 'undefined') {\\n   console.error('no command given!');\\n   process.exit(1);\\n}\\nconsole.log('command:', cmdValue);\\nconsole.log('environment:', envValue || \\\"no environment given\\\");\\n</code></pre>\\n<p>Angled brackets (e.g. <code>&#x3C;cmd></code>) indicate required input. Square brackets (e.g. <code>[env]</code>) indicate optional input.</p>\\n<h2>Git-style sub-commands</h2>\\n<pre><code class=\\\"language-js\\\">// file: ./examples/pm\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .command('install [name]', 'install one or more packages')\\n  .command('search [query]', 'search with optional query')\\n  .command('list', 'list packages installed', {isDefault: true})\\n  .parse(process.argv);\\n</code></pre>\\n<p>When <code>.command()</code> is invoked with a description argument, no <code>.action(callback)</code> should be called to handle sub-commands, otherwise there will be an error. This tells commander that you're going to use separate executables for sub-commands, much like <code>git(1)</code> and other popular tools.<br>\\nThe commander will try to search the executables in the directory of the entry script (like <code>./examples/pm</code>) with the name <code>program-command</code>, like <code>pm-install</code>, <code>pm-search</code>.</p>\\n<p>Options can be passed with the call to <code>.command()</code>. Specifying <code>true</code> for <code>opts.noHelp</code> will remove the option from the generated help output. Specifying <code>true</code> for <code>opts.isDefault</code> will run the subcommand if no other subcommand is specified.</p>\\n<p>If the program is designed to be installed globally, make sure the executables have proper modes, like <code>755</code>.</p>\\n<h3><code>--harmony</code></h3>\\n<p>You can enable <code>--harmony</code> option in two ways:</p>\\n<ul>\\n<li>Use <code>#! /usr/bin/env node --harmony</code> in the sub-commands scripts. Note some os version donâ€™t support this pattern.</li>\\n<li>Use the <code>--harmony</code> option when call the command, like <code>node --harmony examples/pm publish</code>. The <code>--harmony</code> option will be preserved when spawning sub-command process.</li>\\n</ul>\\n<h2>Automated --help</h2>\\n<p> The help information is auto-generated based on the information commander already knows about your program, so the following <code>--help</code> info is for free:</p>\\n<pre><code> $ ./examples/pizza --help\\n\\n   Usage: pizza [options]\\n\\n   An application for pizzas ordering\\n\\n   Options:\\n\\n     -h, --help           output usage information\\n     -V, --version        output the version number\\n     -p, --peppers        Add peppers\\n     -P, --pineapple      Add pineapple\\n     -b, --bbq            Add bbq sauce\\n     -c, --cheese &#x3C;type>  Add the specified type of cheese [marble]\\n     -C, --no-cheese      You do not want any cheese\\n</code></pre>\\n<h2>Custom help</h2>\\n<p> You can display arbitrary <code>-h, --help</code> information\\nby listening for \\\"--help\\\". Commander will automatically\\nexit once you are done so that the remainder of your program\\ndoes not execute causing undesired behaviours, for example\\nin the following executable \\\"stuff\\\" will not output when\\n<code>--help</code> is used.</p>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .option('-f, --foo', 'enable some foo')\\n  .option('-b, --bar', 'enable some bar')\\n  .option('-B, --baz', 'enable some baz');\\n\\n// must be before .parse() since\\n// node's emit() is immediate\\n\\nprogram.on('--help', function(){\\n  console.log('  Examples:');\\n  console.log('');\\n  console.log('    $ custom-help --help');\\n  console.log('    $ custom-help -h');\\n  console.log('');\\n});\\n\\nprogram.parse(process.argv);\\n\\nconsole.log('stuff');\\n</code></pre>\\n<p>Yields the following help output when <code>node script-name.js -h</code> or <code>node script-name.js --help</code> are run:</p>\\n<pre><code>Usage: custom-help [options]\\n\\nOptions:\\n\\n  -h, --help     output usage information\\n  -V, --version  output the version number\\n  -f, --foo      enable some foo\\n  -b, --bar      enable some bar\\n  -B, --baz      enable some baz\\n\\nExamples:\\n\\n  $ custom-help --help\\n  $ custom-help -h\\n</code></pre>\\n<h2>.outputHelp(cb)</h2>\\n<p>Output help information without exiting.\\nOptional callback cb allows post-processing of help text before it is displayed.</p>\\n<p>If you want to display help by default (e.g. if no command was provided), you can use something like:</p>\\n<pre><code class=\\\"language-js\\\">var program = require('commander');\\nvar colors = require('colors');\\n\\nprogram\\n  .version('0.1.0')\\n  .command('getstream [url]', 'get stream URL')\\n  .parse(process.argv);\\n\\n  if (!process.argv.slice(2).length) {\\n    program.outputHelp(make_red);\\n  }\\n\\nfunction make_red(txt) {\\n  return colors.red(txt); //display the help text in red on the console\\n}\\n</code></pre>\\n<h2>.help(cb)</h2>\\n<p>  Output help information and exit immediately.\\nOptional callback cb allows post-processing of help text before it is displayed.</p>\\n<h2>Examples</h2>\\n<pre><code class=\\\"language-js\\\">var program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .option('-C, --chdir &#x3C;path>', 'change the working directory')\\n  .option('-c, --config &#x3C;path>', 'set config path. defaults to ./deploy.conf')\\n  .option('-T, --no-tests', 'ignore test hook');\\n\\nprogram\\n  .command('setup [env]')\\n  .description('run setup commands for all envs')\\n  .option(\\\"-s, --setup_mode [mode]\\\", \\\"Which setup mode to use\\\")\\n  .action(function(env, options){\\n    var mode = options.setup_mode || \\\"normal\\\";\\n    env = env || 'all';\\n    console.log('setup for %s env(s) with %s mode', env, mode);\\n  });\\n\\nprogram\\n  .command('exec &#x3C;cmd>')\\n  .alias('ex')\\n  .description('execute the given remote cmd')\\n  .option(\\\"-e, --exec_mode &#x3C;mode>\\\", \\\"Which exec mode to use\\\")\\n  .action(function(cmd, options){\\n    console.log('exec \\\"%s\\\" using %s mode', cmd, options.exec_mode);\\n  }).on('--help', function() {\\n    console.log('  Examples:');\\n    console.log();\\n    console.log('    $ deploy exec sequential');\\n    console.log('    $ deploy exec async');\\n    console.log();\\n  });\\n\\nprogram\\n  .command('*')\\n  .action(function(env){\\n    console.log('deploying \\\"%s\\\"', env);\\n  });\\n\\nprogram.parse(process.argv);\\n</code></pre>\\n<p>More Demos can be found in the <a href=\\\"https://github.com/tj/commander.js/tree/master/examples\\\">examples</a> directory.</p>\\n<h2>License</h2>\\n<p>MIT</p>\",\"docPath\":\"argo-ci/node_modules/commander/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-commander-65ee086192df02c3cd44.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>Commander.js</h1>\\n<p><a href=\\\"http://travis-ci.org/tj/commander.js\\\"><img src=\\\"https://api.travis-ci.org/tj/commander.js.svg?branch=master\\\" alt=\\\"Build Status\\\"></a>\\n<a href=\\\"https://www.npmjs.org/package/commander\\\"><img src=\\\"http://img.shields.io/npm/v/commander.svg?style=flat\\\" alt=\\\"NPM Version\\\"></a>\\n<a href=\\\"https://www.npmjs.org/package/commander\\\"><img src=\\\"https://img.shields.io/npm/dm/commander.svg?style=flat\\\" alt=\\\"NPM Downloads\\\"></a>\\n<a href=\\\"https://gitter.im/tj/commander.js?utm_source=badge&#x26;utm_medium=badge&#x26;utm_campaign=pr-badge&#x26;utm_content=badge\\\"><img src=\\\"https://badges.gitter.im/Join%20Chat.svg\\\" alt=\\\"Join the chat at https://gitter.im/tj/commander.js\\\"></a></p>\\n<p>  The complete solution for <a href=\\\"http://nodejs.org\\\">node.js</a> command-line interfaces, inspired by Ruby's <a href=\\\"https://github.com/commander-rb/commander\\\">commander</a>.<br>\\n<a href=\\\"http://tj.github.com/commander.js/\\\">API documentation</a></p>\\n<h2>Installation</h2>\\n<pre><code>$ npm install commander --save\\n</code></pre>\\n<h2>Option parsing</h2>\\n<p> Options with commander are defined with the <code>.option()</code> method, also serving as documentation for the options. The example below parses args and options from <code>process.argv</code>, leaving remaining args as the <code>program.args</code> array which were not consumed by options.</p>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .option('-p, --peppers', 'Add peppers')\\n  .option('-P, --pineapple', 'Add pineapple')\\n  .option('-b, --bbq-sauce', 'Add bbq sauce')\\n  .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')\\n  .parse(process.argv);\\n\\nconsole.log('you ordered a pizza with:');\\nif (program.peppers) console.log('  - peppers');\\nif (program.pineapple) console.log('  - pineapple');\\nif (program.bbqSauce) console.log('  - bbq');\\nconsole.log('  - %s cheese', program.cheese);\\n</code></pre>\\n<p> Short flags may be passed as a single arg, for example <code>-abc</code> is equivalent to <code>-a -b -c</code>. Multi-word options such as \\\"--template-engine\\\" are camel-cased, becoming <code>program.templateEngine</code> etc.</p>\\n<h2>Coercion</h2>\\n<pre><code class=\\\"language-js\\\">function range(val) {\\n  return val.split('..').map(Number);\\n}\\n\\nfunction list(val) {\\n  return val.split(',');\\n}\\n\\nfunction collect(val, memo) {\\n  memo.push(val);\\n  return memo;\\n}\\n\\nfunction increaseVerbosity(v, total) {\\n  return total + 1;\\n}\\n\\nprogram\\n  .version('0.1.0')\\n  .usage('[options] &#x3C;file ...>')\\n  .option('-i, --integer &#x3C;n>', 'An integer argument', parseInt)\\n  .option('-f, --float &#x3C;n>', 'A float argument', parseFloat)\\n  .option('-r, --range &#x3C;a>..&#x3C;b>', 'A range', range)\\n  .option('-l, --list &#x3C;items>', 'A list', list)\\n  .option('-o, --optional [value]', 'An optional value')\\n  .option('-c, --collect [value]', 'A repeatable value', collect, [])\\n  .option('-v, --verbose', 'A value that can be increased', increaseVerbosity, 0)\\n  .parse(process.argv);\\n\\nconsole.log(' int: %j', program.integer);\\nconsole.log(' float: %j', program.float);\\nconsole.log(' optional: %j', program.optional);\\nprogram.range = program.range || [];\\nconsole.log(' range: %j..%j', program.range[0], program.range[1]);\\nconsole.log(' list: %j', program.list);\\nconsole.log(' collect: %j', program.collect);\\nconsole.log(' verbosity: %j', program.verbose);\\nconsole.log(' args: %j', program.args);\\n</code></pre>\\n<h2>Regular Expression</h2>\\n<pre><code class=\\\"language-js\\\">program\\n  .version('0.1.0')\\n  .option('-s --size &#x3C;size>', 'Pizza size', /^(large|medium|small)$/i, 'medium')\\n  .option('-d --drink [drink]', 'Drink', /^(coke|pepsi|izze)$/i)\\n  .parse(process.argv);\\n  \\nconsole.log(' size: %j', program.size);\\nconsole.log(' drink: %j', program.drink);\\n</code></pre>\\n<h2>Variadic arguments</h2>\\n<p> The last argument of a command can be variadic, and only the last argument.  To make an argument variadic you have to\\nappend <code>...</code> to the argument name.  Here is an example:</p>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .command('rmdir &#x3C;dir> [otherDirs...]')\\n  .action(function (dir, otherDirs) {\\n    console.log('rmdir %s', dir);\\n    if (otherDirs) {\\n      otherDirs.forEach(function (oDir) {\\n        console.log('rmdir %s', oDir);\\n      });\\n    }\\n  });\\n\\nprogram.parse(process.argv);\\n</code></pre>\\n<p> An <code>Array</code> is used for the value of a variadic argument.  This applies to <code>program.args</code> as well as the argument passed\\nto your action as demonstrated above.</p>\\n<h2>Specify the argument syntax</h2>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .arguments('&#x3C;cmd> [env]')\\n  .action(function (cmd, env) {\\n     cmdValue = cmd;\\n     envValue = env;\\n  });\\n\\nprogram.parse(process.argv);\\n\\nif (typeof cmdValue === 'undefined') {\\n   console.error('no command given!');\\n   process.exit(1);\\n}\\nconsole.log('command:', cmdValue);\\nconsole.log('environment:', envValue || \\\"no environment given\\\");\\n</code></pre>\\n<p>Angled brackets (e.g. <code>&#x3C;cmd></code>) indicate required input. Square brackets (e.g. <code>[env]</code>) indicate optional input.</p>\\n<h2>Git-style sub-commands</h2>\\n<pre><code class=\\\"language-js\\\">// file: ./examples/pm\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .command('install [name]', 'install one or more packages')\\n  .command('search [query]', 'search with optional query')\\n  .command('list', 'list packages installed', {isDefault: true})\\n  .parse(process.argv);\\n</code></pre>\\n<p>When <code>.command()</code> is invoked with a description argument, no <code>.action(callback)</code> should be called to handle sub-commands, otherwise there will be an error. This tells commander that you're going to use separate executables for sub-commands, much like <code>git(1)</code> and other popular tools.<br>\\nThe commander will try to search the executables in the directory of the entry script (like <code>./examples/pm</code>) with the name <code>program-command</code>, like <code>pm-install</code>, <code>pm-search</code>.</p>\\n<p>Options can be passed with the call to <code>.command()</code>. Specifying <code>true</code> for <code>opts.noHelp</code> will remove the option from the generated help output. Specifying <code>true</code> for <code>opts.isDefault</code> will run the subcommand if no other subcommand is specified.</p>\\n<p>If the program is designed to be installed globally, make sure the executables have proper modes, like <code>755</code>.</p>\\n<h3><code>--harmony</code></h3>\\n<p>You can enable <code>--harmony</code> option in two ways:</p>\\n<ul>\\n<li>Use <code>#! /usr/bin/env node --harmony</code> in the sub-commands scripts. Note some os version donâ€™t support this pattern.</li>\\n<li>Use the <code>--harmony</code> option when call the command, like <code>node --harmony examples/pm publish</code>. The <code>--harmony</code> option will be preserved when spawning sub-command process.</li>\\n</ul>\\n<h2>Automated --help</h2>\\n<p> The help information is auto-generated based on the information commander already knows about your program, so the following <code>--help</code> info is for free:</p>\\n<pre><code> $ ./examples/pizza --help\\n\\n   Usage: pizza [options]\\n\\n   An application for pizzas ordering\\n\\n   Options:\\n\\n     -h, --help           output usage information\\n     -V, --version        output the version number\\n     -p, --peppers        Add peppers\\n     -P, --pineapple      Add pineapple\\n     -b, --bbq            Add bbq sauce\\n     -c, --cheese &#x3C;type>  Add the specified type of cheese [marble]\\n     -C, --no-cheese      You do not want any cheese\\n</code></pre>\\n<h2>Custom help</h2>\\n<p> You can display arbitrary <code>-h, --help</code> information\\nby listening for \\\"--help\\\". Commander will automatically\\nexit once you are done so that the remainder of your program\\ndoes not execute causing undesired behaviours, for example\\nin the following executable \\\"stuff\\\" will not output when\\n<code>--help</code> is used.</p>\\n<pre><code class=\\\"language-js\\\">#!/usr/bin/env node\\n\\n/**\\n * Module dependencies.\\n */\\n\\nvar program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .option('-f, --foo', 'enable some foo')\\n  .option('-b, --bar', 'enable some bar')\\n  .option('-B, --baz', 'enable some baz');\\n\\n// must be before .parse() since\\n// node's emit() is immediate\\n\\nprogram.on('--help', function(){\\n  console.log('  Examples:');\\n  console.log('');\\n  console.log('    $ custom-help --help');\\n  console.log('    $ custom-help -h');\\n  console.log('');\\n});\\n\\nprogram.parse(process.argv);\\n\\nconsole.log('stuff');\\n</code></pre>\\n<p>Yields the following help output when <code>node script-name.js -h</code> or <code>node script-name.js --help</code> are run:</p>\\n<pre><code>Usage: custom-help [options]\\n\\nOptions:\\n\\n  -h, --help     output usage information\\n  -V, --version  output the version number\\n  -f, --foo      enable some foo\\n  -b, --bar      enable some bar\\n  -B, --baz      enable some baz\\n\\nExamples:\\n\\n  $ custom-help --help\\n  $ custom-help -h\\n</code></pre>\\n<h2>.outputHelp(cb)</h2>\\n<p>Output help information without exiting.\\nOptional callback cb allows post-processing of help text before it is displayed.</p>\\n<p>If you want to display help by default (e.g. if no command was provided), you can use something like:</p>\\n<pre><code class=\\\"language-js\\\">var program = require('commander');\\nvar colors = require('colors');\\n\\nprogram\\n  .version('0.1.0')\\n  .command('getstream [url]', 'get stream URL')\\n  .parse(process.argv);\\n\\n  if (!process.argv.slice(2).length) {\\n    program.outputHelp(make_red);\\n  }\\n\\nfunction make_red(txt) {\\n  return colors.red(txt); //display the help text in red on the console\\n}\\n</code></pre>\\n<h2>.help(cb)</h2>\\n<p>  Output help information and exit immediately.\\nOptional callback cb allows post-processing of help text before it is displayed.</p>\\n<h2>Examples</h2>\\n<pre><code class=\\\"language-js\\\">var program = require('commander');\\n\\nprogram\\n  .version('0.1.0')\\n  .option('-C, --chdir &#x3C;path>', 'change the working directory')\\n  .option('-c, --config &#x3C;path>', 'set config path. defaults to ./deploy.conf')\\n  .option('-T, --no-tests', 'ignore test hook');\\n\\nprogram\\n  .command('setup [env]')\\n  .description('run setup commands for all envs')\\n  .option(\\\"-s, --setup_mode [mode]\\\", \\\"Which setup mode to use\\\")\\n  .action(function(env, options){\\n    var mode = options.setup_mode || \\\"normal\\\";\\n    env = env || 'all';\\n    console.log('setup for %s env(s) with %s mode', env, mode);\\n  });\\n\\nprogram\\n  .command('exec &#x3C;cmd>')\\n  .alias('ex')\\n  .description('execute the given remote cmd')\\n  .option(\\\"-e, --exec_mode &#x3C;mode>\\\", \\\"Which exec mode to use\\\")\\n  .action(function(cmd, options){\\n    console.log('exec \\\"%s\\\" using %s mode', cmd, options.exec_mode);\\n  }).on('--help', function() {\\n    console.log('  Examples:');\\n    console.log();\\n    console.log('    $ deploy exec sequential');\\n    console.log('    $ deploy exec async');\\n    console.log();\\n  });\\n\\nprogram\\n  .command('*')\\n  .action(function(env){\\n    console.log('deploying \\\"%s\\\"', env);\\n  });\\n\\nprogram.parse(process.argv);\\n</code></pre>\\n<p>More Demos can be found in the <a href=\\\"https://github.com/tj/commander.js/tree/master/examples\\\">examples</a> directory.</p>\\n<h2>License</h2>\\n<p>MIT</p>\",\"docPath\":\"argo-ci/node_modules/commander/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-commander.json\n// module id = 2186\n// module chunks = 62979176296541"],"sourceRoot":""}