{"version":3,"sources":["webpack:///path---docs-argo-cd-docs-operator-manual-declarative-setup-html-d2332b42ec401922d3ed.js","webpack:///./.cache/json/docs-argo-cd-docs-operator-manual-declarative-setup-html.json"],"names":["webpackJsonp","560","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,4ydAAghbC,QAAA,iDAAAC,KAAA","file":"path---docs-argo-cd-docs-operator-manual-declarative-setup-html-d2332b42ec401922d3ed.js","sourcesContent":["webpackJsonp([162223455216220],{\n\n/***/ 560:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>Declarative Setup</h1>\\n<p>Argo CD applications, projects and settings can be defined declaratively using Kubernetes manifests.</p>\\n<h2>Quick Reference</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Kind</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><a href=\\\"argocd-cm.yaml\\\"><code>argocd-cm.yaml</code></a></td>\\n<td>ConfigMap</td>\\n<td>General Argo CD configuration</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"argocd-secret.yaml\\\"><code>argocd-secret.yaml</code></a></td>\\n<td>Secret</td>\\n<td>Password, Certificates, Signing Key</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"argocd-rbac-cm.yaml\\\"><code>argocd-rbac-cm.yaml</code></a></td>\\n<td>ConfigMap</td>\\n<td>RBAC Configuration</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"application.yaml\\\"><code>application.yaml</code></a></td>\\n<td>Application</td>\\n<td>Example application spec</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"project.yaml\\\"><code>project.yaml</code></a></td>\\n<td>AppProject</td>\\n<td>Example project spec</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>Applications</h2>\\n<p>The Application CRD is the Kubernetes resource object representing a deployed application instance\\nin an environment. It is defined by two key pieces of information:</p>\\n<ul>\\n<li><code>source</code> reference to the desired state in Git (repository, revision, path, environment)</li>\\n<li><code>destination</code> reference to the target cluster and namespace.</li>\\n</ul>\\n<p>A minimal Application spec is as follows:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\nspec:\\n  project: default\\n  source:\\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\\n    targetRevision: HEAD\\n    path: guestbook\\n  destination:\\n    server: https://kubernetes.default.svc\\n    namespace: guestbook\\n</code></pre>\\n<p>See <a href=\\\"application.yaml\\\">application.yaml</a> for additional fields</p>\\n<p>!!! warning\\nBy default, deleting an application will not perform a cascade delete, thereby deleting its resources. You must add the finalizer if you want this behaviour - which you may well not want.\\n</p>\\n<pre><code class=\\\"language-yaml\\\">metadata:\\n  finalizers:\\n    - resources-finalizer.argocd.argoproj.io\\n</code></pre>\\n<h3>Application of Applications</h3>\\n<p>You can create an application that creates other applications, which in turn can create other applications.\\nThis allows you to declaratively manage a group of applications that can be deployed and configured in concert.</p>\\n<p>See <a href=\\\"cluster-bootstrapping.html\\\">cluster bootstrapping</a>.</p>\\n<h2>Projects</h2>\\n<p>The AppProject CRD is the Kubernetes resource object representing a logical grouping of applications.\\nIt is defined by the following key pieces of information:</p>\\n<ul>\\n<li><code>sourceRepos</code> reference to the repositories that applications within the project can pull manifests from.</li>\\n<li><code>destinations</code> reference to clusters and namespaces that applications within the project can deploy into.</li>\\n<li><code>roles</code> list of entities with definitions of their access to resources within the project.</li>\\n</ul>\\n<p>An example spec is as follows:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: AppProject\\nmetadata:\\n  name: my-project\\nspec:\\n  description: Example Project\\n  # Allow manifests to deploy from any Git repos\\n  sourceRepos:\\n  - '*'\\n  # Only permit applications to deploy to the guestbook namespace in the same cluster\\n  destinations:\\n  - namespace: guestbook\\n    server: https://kubernetes.default.svc\\n  # Deny all cluster-scoped resources from being created, except for Namespace\\n  clusterResourceWhitelist:\\n  - group: ''\\n    kind: Namespace\\n  # Allow all namespaced-scoped resources to be created, except for ResourceQuota, LimitRange, NetworkPolicy\\n  namespaceResourceBlacklist:\\n  - group: ''\\n    kind: ResourceQuota\\n  - group: ''\\n    kind: LimitRange\\n  - group: ''\\n    kind: NetworkPolicy\\n  roles:\\n  # A role which provides read-only access to all applications in the project\\n  - name: read-only\\n    description: Read-only privileges to my-project\\n    policies:\\n    - p, proj:my-project:read-only, applications, get, my-project/*, allow\\n    groups:\\n    - my-oidc-group\\n  # A role which provides sync privileges to only the guestbook-dev application, e.g. to provide\\n  # sync privileges to a CI system\\n  - name: ci-role\\n    description: Sync privileges for guestbook-dev\\n    policies:\\n    - p, proj:my-project:ci-role, applications, sync, my-project/guestbook-dev, allow\\n    # NOTE: JWT tokens can only be generated by the API server and the token is not persisted\\n    # anywhere by Argo CD. It can be prematurely revoked by removing the entry from this list.\\n    jwtTokens:\\n    - iat: 1535390316\\n</code></pre>\\n<h2>Repositories</h2>\\n<p>Repository credentials are stored in secret. Use following steps to configure a repo:</p>\\n<ol>\\n<li>Create secret which contains repository credentials. Consider using <a href=\\\"https://github.com/bitnami-labs/sealed-secrets\\\">bitnami-labs/sealed-secrets</a> to store encrypted secret\\ndefinition as a Kubernetes manifest.</li>\\n<li>Register repository in the <code>argocd-cm</code> config map. Each repository must have <code>url</code> field and, depending on whether you connect using HTTPS or SSH, <code>usernameSecret</code> and <code>passwordSecret</code> (for HTTPS) or <code>sshPrivateKeySecret</code> (for SSH).</li>\\n</ol>\\n<p>Example for HTTPS:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    - url: https://github.com/argoproj/my-private-repository\\n      passwordSecret:\\n        name: my-secret\\n        key: password\\n      usernameSecret:\\n        name: my-secret\\n        key: username\\n</code></pre>\\n<p>Example for SSH:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    - url: git@github.com:argoproj/my-private-repository\\n      sshPrivateKeySecret:\\n        name: my-secret\\n        key: sshPrivateKey\\n</code></pre>\\n<p>!!! tip\\nThe Kubernetes documentation has <a href=\\\"https://kubernetes.io/docs/concepts/configuration/secret/#use-case-pod-with-ssh-keys\\\">instructions for creating a secret containing a private key</a>. </p>\\n<h3>Repository Credentials (v1.1+)</h3>\\n<p>If you want to use the same credentials for multiple repositories, you can use <code>repository.credentials</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    - url: https://github.com/argoproj/private-repo\\n    - url: https://github.com/argoproj/other-private-repo\\n  repository.credentials: |\\n    - url: https://github.com/argoproj\\n      passwordSecret:\\n        name: my-secret\\n        key: password\\n      usernameSecret:\\n        name: my-secret\\n        key: username\\n</code></pre>\\n<p>Argo CD will only use the credentials if you omit <code>usernameSecret</code>, <code>passwordSecret</code>, and <code>sshPrivateKeySecret</code> fields (<code>insecureIgnoreHostKey</code> is ignored).</p>\\n<p>A credential may be match if it's URL is the prefix of the repository's URL. The means that credentials may match, e.g in the above example both <a href=\\\"https://github.com/argoproj\\\">https://github.com/argoproj</a> and <a href=\\\"https://github.com\\\">https://github.com</a> would match. Argo CD selects the first one that matches.</p>\\n<p>!!! tip\\nOrder your credentials with the most specific at the top and the least specific at the bottom. </p>\\n<p>A complete example.</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    # this has it's own credentials\\n    - url: https://github.com/argoproj/private-repo\\n      passwordSecret:\\n        name: private-repo-secret\\n        key: password\\n      usernameSecret:\\n        name: private-repo-secret\\n        key: username\\n      sshPrivateKeySecret:\\n        name: private-repo-secret\\n        key: sshPrivateKey\\n    - url: https://github.com/argoproj/other-private-repo\\n    - url: https://github.com/otherproj/another-private-repo\\n  repository.credentials: |\\n    # this will be used for the second repo\\n    - url: https://github.com/argoproj\\n      passwordSecret:\\n        name: other-private-repo-secret\\n        key: password\\n      usernameSecret:\\n        name: other-private-repo-secret\\n        key: username\\n      sshPrivateKeySecret:\\n        name: other-private-repo-secret\\n        key: sshPrivateKey\\n    # this will be used for the third repo\\n    - url: https://github.com\\n      passwordSecret:\\n        name: another-private-repo-secret\\n        key: password\\n      usernameSecret:\\n        name: another-private-repo-secret\\n        key: username\\n      sshPrivateKeySecret:\\n        name: another-private-repo-secret\\n        key: sshPrivateKey\\n</code></pre>\\n<h2>Clusters</h2>\\n<p>Cluster credentials are stored in secrets same as repository credentials but does not require entry in <code>argocd-cm</code> config map. Each secret must have label\\n<code>argocd.argoproj.io/secret-type: cluster</code>.</p>\\n<p>The secret data must include following fields:</p>\\n<ul>\\n<li><code>name</code> - cluster name</li>\\n<li><code>server</code> - cluster api server url</li>\\n<li><code>config</code> - JSON representation of following data structure:</li>\\n</ul>\\n<pre><code class=\\\"language-yaml\\\"># Basic authentication settings\\nusername: string\\npassword: string\\n# Bearer authentication settings\\nbearerToken: string\\n# IAM authentication configuration\\nawsAuthConfig:\\n    clusterName: string\\n    roleARN: string\\n# Transport layer security configuration settings\\ntlsClientConfig:\\n    # PEM-encoded bytes (typically read from a client certificate file).\\n    caData: string\\n    # PEM-encoded bytes (typically read from a client certificate file).\\n    certData: string\\n    # Server should be accessed without verifying the TLS certificate\\n    insecure: boolean\\n    # PEM-encoded bytes (typically read from a client certificate key file).\\n    keyData: string\\n    # ServerName is passed to the server for SNI and is used in the client to check server\\n    # ceritificates against. If ServerName is empty, the hostname used to contact the\\n    # server is used.\\n    serverName: string\\n</code></pre>\\n<p>Cluster secret example:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: mycluster-secret\\n  labels:\\n    argocd.argoproj.io/secret-type: cluster\\ntype: Opaque\\nstringData:\\n  name: mycluster.com\\n  server: https://mycluster.com\\n  config: |\\n    {\\n      \\\"bearerToken\\\": \\\"&#x3C;authentication token>\\\",\\n      \\\"tlsClientConfig\\\": {\\n        \\\"insecure\\\": false,\\n        \\\"caData\\\": \\\"&#x3C;base64 encoded certificate>\\\"\\n      }\\n    }\\n</code></pre>\\n<h2>Helm Chart Repositories</h2>\\n<p>Non standard Helm Chart repositories have to be registered under the <code>helm.repositories</code> key in the\\n<code>argocd-cm</code> ConfigMap. Each repository must have <code>url</code> and <code>name</code> fields. For private Helm repos you\\nmay need to configure access credentials and HTTPS settings using <code>usernameSecret</code>, <code>passwordSecret</code>,\\n<code>caSecret</code>, <code>certSecret</code> and <code>keySecret</code> fields.</p>\\n<p>Example:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  helm.repositories: |\\n    - url: https://storage.googleapis.com/istio-prerelease/daily-build/master-latest-daily/charts\\n      name: istio.io\\n    - url: https://argoproj.github.io/argo-helm\\n      name: argo\\n      usernameSecret:\\n        name: my-secret\\n        key: username\\n      passwordSecret:\\n        name: my-secret\\n        key: password\\n      caSecret:\\n        name: my-secret\\n        key: ca\\n      certSecret:\\n        name: my-secret\\n        key: cert\\n      keySecret:\\n        name: my-secret\\n        key: key\\n</code></pre>\\n<h2>Resource Exclusion</h2>\\n<p>Resources can be excluded from discovery and sync so that ArgoCD is unaware of them. For example, <code>events.k8s.io</code> and <code>metrics.k8s.io</code> are always excluded. Use cases:</p>\\n<ul>\\n<li>You have temporal issues and you want to exclude problematic resources.</li>\\n<li>There are many of a kind of resources that impacts ArgoCD's performance.</li>\\n<li>Restrict ArgoCD's access to certain kinds of resources, e.g. secrets. See <a href=\\\"security.md#cluster-rbac\\\">security.md#cluster-rbac</a>.</li>\\n</ul>\\n<p>To configure this, edit the <code>argcd-cm</code> config map:</p>\\n<pre><code>kubectl edit configmap argocd-cm -n argocdconfigmap/argocd-cm edited\\n</code></pre>\\n<p>Add <code>resource.exclusions</code>, e.g.:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\ndata:\\n  resource.exclusions: |\\n    - apiGroups:\\n      - \\\"*\\\"\\n      kinds:\\n      - \\\"*\\\"\\n      clusters:\\n      - https://192.168.0.20\\nkind: ConfigMap\\n</code></pre>\\n<p>The <code>resource.exclusions</code> node is a list of objects. Each object can have:</p>\\n<ul>\\n<li><code>apiGroups</code> A list of globs to match the API group.</li>\\n<li><code>kinds</code> A list of kinds to match. Can be \\\"*\\\" to match all.</li>\\n<li><code>cluster</code> A list of globs to match the cluster.</li>\\n</ul>\\n<p>If all three match, then the resource is ignored.</p>\\n<p>Notes:</p>\\n<ul>\\n<li>Quote globs in your YAML to avoid parsing errors.</li>\\n<li>Invalid globs result in the whole rule being ignored.</li>\\n<li>If you add a rule that matches existing resources, these will appear in the interface as <code>OutOfSync</code>.</li>\\n</ul>\\n<h2>SSO &#x26; RBAC</h2>\\n<ul>\\n<li>SSO configuration details: <a href=\\\"sso.html\\\">SSO</a></li>\\n<li>RBAC configuration details: <a href=\\\"rbac.html\\\">RBAC</a></li>\\n</ul>\\n<h2>Manage Argo CD Using Argo CD</h2>\\n<p>Argo CD is able to manage itself since all settings are represented by Kubernetes manifests. The suggested way is to create <a href=\\\"https://github.com/kubernetes-sigs/kustomize\\\">Kustomize</a>\\nbased application which uses base Argo CD manifests from [https://github.com/argoproj/argo-cd] and apply required changes on top.</p>\\n<p>Example of <code>kustomization.yaml</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v0.10.6\\n\\n# additional resources like ingress rules, cluster and repository secrets.\\nresources:\\n- clusters-secrets.yaml\\n- repos-secrets.yaml\\n\\n# changes to config maps\\npatchesStrategicMerge:\\n- overlays/argo-cd-cm.yaml\\n</code></pre>\\n<p>The live example of self managed Argo CD config is available at <a href=\\\"https://cd.apps.argoproj.io\\\">https://cd.apps.argoproj.io</a> and with configuration\\nstored at <a href=\\\"https://github.com/argoproj/argoproj-deployments/tree/master/argocd\\\">argoproj/argoproj-deployments</a>.</p>\\n<p>!!! note\\nYou will need to sign-in using your github account to get access to <a href=\\\"https://cd.apps.argoproj.io\\\">https://cd.apps.argoproj.io</a></p>\",\"docPath\":\"argo-cd/docs/operator-manual/declarative-setup\",\"proj\":\"argo-cd\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-cd-docs-operator-manual-declarative-setup-html-d2332b42ec401922d3ed.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>Declarative Setup</h1>\\n<p>Argo CD applications, projects and settings can be defined declaratively using Kubernetes manifests.</p>\\n<h2>Quick Reference</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Kind</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><a href=\\\"argocd-cm.yaml\\\"><code>argocd-cm.yaml</code></a></td>\\n<td>ConfigMap</td>\\n<td>General Argo CD configuration</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"argocd-secret.yaml\\\"><code>argocd-secret.yaml</code></a></td>\\n<td>Secret</td>\\n<td>Password, Certificates, Signing Key</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"argocd-rbac-cm.yaml\\\"><code>argocd-rbac-cm.yaml</code></a></td>\\n<td>ConfigMap</td>\\n<td>RBAC Configuration</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"application.yaml\\\"><code>application.yaml</code></a></td>\\n<td>Application</td>\\n<td>Example application spec</td>\\n</tr>\\n<tr>\\n<td><a href=\\\"project.yaml\\\"><code>project.yaml</code></a></td>\\n<td>AppProject</td>\\n<td>Example project spec</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>Applications</h2>\\n<p>The Application CRD is the Kubernetes resource object representing a deployed application instance\\nin an environment. It is defined by two key pieces of information:</p>\\n<ul>\\n<li><code>source</code> reference to the desired state in Git (repository, revision, path, environment)</li>\\n<li><code>destination</code> reference to the target cluster and namespace.</li>\\n</ul>\\n<p>A minimal Application spec is as follows:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\nspec:\\n  project: default\\n  source:\\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\\n    targetRevision: HEAD\\n    path: guestbook\\n  destination:\\n    server: https://kubernetes.default.svc\\n    namespace: guestbook\\n</code></pre>\\n<p>See <a href=\\\"application.yaml\\\">application.yaml</a> for additional fields</p>\\n<p>!!! warning\\nBy default, deleting an application will not perform a cascade delete, thereby deleting its resources. You must add the finalizer if you want this behaviour - which you may well not want.\\n</p>\\n<pre><code class=\\\"language-yaml\\\">metadata:\\n  finalizers:\\n    - resources-finalizer.argocd.argoproj.io\\n</code></pre>\\n<h3>Application of Applications</h3>\\n<p>You can create an application that creates other applications, which in turn can create other applications.\\nThis allows you to declaratively manage a group of applications that can be deployed and configured in concert.</p>\\n<p>See <a href=\\\"cluster-bootstrapping.html\\\">cluster bootstrapping</a>.</p>\\n<h2>Projects</h2>\\n<p>The AppProject CRD is the Kubernetes resource object representing a logical grouping of applications.\\nIt is defined by the following key pieces of information:</p>\\n<ul>\\n<li><code>sourceRepos</code> reference to the repositories that applications within the project can pull manifests from.</li>\\n<li><code>destinations</code> reference to clusters and namespaces that applications within the project can deploy into.</li>\\n<li><code>roles</code> list of entities with definitions of their access to resources within the project.</li>\\n</ul>\\n<p>An example spec is as follows:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: AppProject\\nmetadata:\\n  name: my-project\\nspec:\\n  description: Example Project\\n  # Allow manifests to deploy from any Git repos\\n  sourceRepos:\\n  - '*'\\n  # Only permit applications to deploy to the guestbook namespace in the same cluster\\n  destinations:\\n  - namespace: guestbook\\n    server: https://kubernetes.default.svc\\n  # Deny all cluster-scoped resources from being created, except for Namespace\\n  clusterResourceWhitelist:\\n  - group: ''\\n    kind: Namespace\\n  # Allow all namespaced-scoped resources to be created, except for ResourceQuota, LimitRange, NetworkPolicy\\n  namespaceResourceBlacklist:\\n  - group: ''\\n    kind: ResourceQuota\\n  - group: ''\\n    kind: LimitRange\\n  - group: ''\\n    kind: NetworkPolicy\\n  roles:\\n  # A role which provides read-only access to all applications in the project\\n  - name: read-only\\n    description: Read-only privileges to my-project\\n    policies:\\n    - p, proj:my-project:read-only, applications, get, my-project/*, allow\\n    groups:\\n    - my-oidc-group\\n  # A role which provides sync privileges to only the guestbook-dev application, e.g. to provide\\n  # sync privileges to a CI system\\n  - name: ci-role\\n    description: Sync privileges for guestbook-dev\\n    policies:\\n    - p, proj:my-project:ci-role, applications, sync, my-project/guestbook-dev, allow\\n    # NOTE: JWT tokens can only be generated by the API server and the token is not persisted\\n    # anywhere by Argo CD. It can be prematurely revoked by removing the entry from this list.\\n    jwtTokens:\\n    - iat: 1535390316\\n</code></pre>\\n<h2>Repositories</h2>\\n<p>Repository credentials are stored in secret. Use following steps to configure a repo:</p>\\n<ol>\\n<li>Create secret which contains repository credentials. Consider using <a href=\\\"https://github.com/bitnami-labs/sealed-secrets\\\">bitnami-labs/sealed-secrets</a> to store encrypted secret\\ndefinition as a Kubernetes manifest.</li>\\n<li>Register repository in the <code>argocd-cm</code> config map. Each repository must have <code>url</code> field and, depending on whether you connect using HTTPS or SSH, <code>usernameSecret</code> and <code>passwordSecret</code> (for HTTPS) or <code>sshPrivateKeySecret</code> (for SSH).</li>\\n</ol>\\n<p>Example for HTTPS:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    - url: https://github.com/argoproj/my-private-repository\\n      passwordSecret:\\n        name: my-secret\\n        key: password\\n      usernameSecret:\\n        name: my-secret\\n        key: username\\n</code></pre>\\n<p>Example for SSH:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    - url: git@github.com:argoproj/my-private-repository\\n      sshPrivateKeySecret:\\n        name: my-secret\\n        key: sshPrivateKey\\n</code></pre>\\n<p>!!! tip\\nThe Kubernetes documentation has <a href=\\\"https://kubernetes.io/docs/concepts/configuration/secret/#use-case-pod-with-ssh-keys\\\">instructions for creating a secret containing a private key</a>. </p>\\n<h3>Repository Credentials (v1.1+)</h3>\\n<p>If you want to use the same credentials for multiple repositories, you can use <code>repository.credentials</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    - url: https://github.com/argoproj/private-repo\\n    - url: https://github.com/argoproj/other-private-repo\\n  repository.credentials: |\\n    - url: https://github.com/argoproj\\n      passwordSecret:\\n        name: my-secret\\n        key: password\\n      usernameSecret:\\n        name: my-secret\\n        key: username\\n</code></pre>\\n<p>Argo CD will only use the credentials if you omit <code>usernameSecret</code>, <code>passwordSecret</code>, and <code>sshPrivateKeySecret</code> fields (<code>insecureIgnoreHostKey</code> is ignored).</p>\\n<p>A credential may be match if it's URL is the prefix of the repository's URL. The means that credentials may match, e.g in the above example both <a href=\\\"https://github.com/argoproj\\\">https://github.com/argoproj</a> and <a href=\\\"https://github.com\\\">https://github.com</a> would match. Argo CD selects the first one that matches.</p>\\n<p>!!! tip\\nOrder your credentials with the most specific at the top and the least specific at the bottom. </p>\\n<p>A complete example.</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  repositories: |\\n    # this has it's own credentials\\n    - url: https://github.com/argoproj/private-repo\\n      passwordSecret:\\n        name: private-repo-secret\\n        key: password\\n      usernameSecret:\\n        name: private-repo-secret\\n        key: username\\n      sshPrivateKeySecret:\\n        name: private-repo-secret\\n        key: sshPrivateKey\\n    - url: https://github.com/argoproj/other-private-repo\\n    - url: https://github.com/otherproj/another-private-repo\\n  repository.credentials: |\\n    # this will be used for the second repo\\n    - url: https://github.com/argoproj\\n      passwordSecret:\\n        name: other-private-repo-secret\\n        key: password\\n      usernameSecret:\\n        name: other-private-repo-secret\\n        key: username\\n      sshPrivateKeySecret:\\n        name: other-private-repo-secret\\n        key: sshPrivateKey\\n    # this will be used for the third repo\\n    - url: https://github.com\\n      passwordSecret:\\n        name: another-private-repo-secret\\n        key: password\\n      usernameSecret:\\n        name: another-private-repo-secret\\n        key: username\\n      sshPrivateKeySecret:\\n        name: another-private-repo-secret\\n        key: sshPrivateKey\\n</code></pre>\\n<h2>Clusters</h2>\\n<p>Cluster credentials are stored in secrets same as repository credentials but does not require entry in <code>argocd-cm</code> config map. Each secret must have label\\n<code>argocd.argoproj.io/secret-type: cluster</code>.</p>\\n<p>The secret data must include following fields:</p>\\n<ul>\\n<li><code>name</code> - cluster name</li>\\n<li><code>server</code> - cluster api server url</li>\\n<li><code>config</code> - JSON representation of following data structure:</li>\\n</ul>\\n<pre><code class=\\\"language-yaml\\\"># Basic authentication settings\\nusername: string\\npassword: string\\n# Bearer authentication settings\\nbearerToken: string\\n# IAM authentication configuration\\nawsAuthConfig:\\n    clusterName: string\\n    roleARN: string\\n# Transport layer security configuration settings\\ntlsClientConfig:\\n    # PEM-encoded bytes (typically read from a client certificate file).\\n    caData: string\\n    # PEM-encoded bytes (typically read from a client certificate file).\\n    certData: string\\n    # Server should be accessed without verifying the TLS certificate\\n    insecure: boolean\\n    # PEM-encoded bytes (typically read from a client certificate key file).\\n    keyData: string\\n    # ServerName is passed to the server for SNI and is used in the client to check server\\n    # ceritificates against. If ServerName is empty, the hostname used to contact the\\n    # server is used.\\n    serverName: string\\n</code></pre>\\n<p>Cluster secret example:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: mycluster-secret\\n  labels:\\n    argocd.argoproj.io/secret-type: cluster\\ntype: Opaque\\nstringData:\\n  name: mycluster.com\\n  server: https://mycluster.com\\n  config: |\\n    {\\n      \\\"bearerToken\\\": \\\"&#x3C;authentication token>\\\",\\n      \\\"tlsClientConfig\\\": {\\n        \\\"insecure\\\": false,\\n        \\\"caData\\\": \\\"&#x3C;base64 encoded certificate>\\\"\\n      }\\n    }\\n</code></pre>\\n<h2>Helm Chart Repositories</h2>\\n<p>Non standard Helm Chart repositories have to be registered under the <code>helm.repositories</code> key in the\\n<code>argocd-cm</code> ConfigMap. Each repository must have <code>url</code> and <code>name</code> fields. For private Helm repos you\\nmay need to configure access credentials and HTTPS settings using <code>usernameSecret</code>, <code>passwordSecret</code>,\\n<code>caSecret</code>, <code>certSecret</code> and <code>keySecret</code> fields.</p>\\n<p>Example:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\ndata:\\n  helm.repositories: |\\n    - url: https://storage.googleapis.com/istio-prerelease/daily-build/master-latest-daily/charts\\n      name: istio.io\\n    - url: https://argoproj.github.io/argo-helm\\n      name: argo\\n      usernameSecret:\\n        name: my-secret\\n        key: username\\n      passwordSecret:\\n        name: my-secret\\n        key: password\\n      caSecret:\\n        name: my-secret\\n        key: ca\\n      certSecret:\\n        name: my-secret\\n        key: cert\\n      keySecret:\\n        name: my-secret\\n        key: key\\n</code></pre>\\n<h2>Resource Exclusion</h2>\\n<p>Resources can be excluded from discovery and sync so that ArgoCD is unaware of them. For example, <code>events.k8s.io</code> and <code>metrics.k8s.io</code> are always excluded. Use cases:</p>\\n<ul>\\n<li>You have temporal issues and you want to exclude problematic resources.</li>\\n<li>There are many of a kind of resources that impacts ArgoCD's performance.</li>\\n<li>Restrict ArgoCD's access to certain kinds of resources, e.g. secrets. See <a href=\\\"security.md#cluster-rbac\\\">security.md#cluster-rbac</a>.</li>\\n</ul>\\n<p>To configure this, edit the <code>argcd-cm</code> config map:</p>\\n<pre><code>kubectl edit configmap argocd-cm -n argocdconfigmap/argocd-cm edited\\n</code></pre>\\n<p>Add <code>resource.exclusions</code>, e.g.:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\ndata:\\n  resource.exclusions: |\\n    - apiGroups:\\n      - \\\"*\\\"\\n      kinds:\\n      - \\\"*\\\"\\n      clusters:\\n      - https://192.168.0.20\\nkind: ConfigMap\\n</code></pre>\\n<p>The <code>resource.exclusions</code> node is a list of objects. Each object can have:</p>\\n<ul>\\n<li><code>apiGroups</code> A list of globs to match the API group.</li>\\n<li><code>kinds</code> A list of kinds to match. Can be \\\"*\\\" to match all.</li>\\n<li><code>cluster</code> A list of globs to match the cluster.</li>\\n</ul>\\n<p>If all three match, then the resource is ignored.</p>\\n<p>Notes:</p>\\n<ul>\\n<li>Quote globs in your YAML to avoid parsing errors.</li>\\n<li>Invalid globs result in the whole rule being ignored.</li>\\n<li>If you add a rule that matches existing resources, these will appear in the interface as <code>OutOfSync</code>.</li>\\n</ul>\\n<h2>SSO &#x26; RBAC</h2>\\n<ul>\\n<li>SSO configuration details: <a href=\\\"sso.html\\\">SSO</a></li>\\n<li>RBAC configuration details: <a href=\\\"rbac.html\\\">RBAC</a></li>\\n</ul>\\n<h2>Manage Argo CD Using Argo CD</h2>\\n<p>Argo CD is able to manage itself since all settings are represented by Kubernetes manifests. The suggested way is to create <a href=\\\"https://github.com/kubernetes-sigs/kustomize\\\">Kustomize</a>\\nbased application which uses base Argo CD manifests from [https://github.com/argoproj/argo-cd] and apply required changes on top.</p>\\n<p>Example of <code>kustomization.yaml</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v0.10.6\\n\\n# additional resources like ingress rules, cluster and repository secrets.\\nresources:\\n- clusters-secrets.yaml\\n- repos-secrets.yaml\\n\\n# changes to config maps\\npatchesStrategicMerge:\\n- overlays/argo-cd-cm.yaml\\n</code></pre>\\n<p>The live example of self managed Argo CD config is available at <a href=\\\"https://cd.apps.argoproj.io\\\">https://cd.apps.argoproj.io</a> and with configuration\\nstored at <a href=\\\"https://github.com/argoproj/argoproj-deployments/tree/master/argocd\\\">argoproj/argoproj-deployments</a>.</p>\\n<p>!!! note\\nYou will need to sign-in using your github account to get access to <a href=\\\"https://cd.apps.argoproj.io\\\">https://cd.apps.argoproj.io</a></p>\",\"docPath\":\"argo-cd/docs/operator-manual/declarative-setup\",\"proj\":\"argo-cd\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-cd-docs-operator-manual-declarative-setup-html.json\n// module id = 560\n// module chunks = 162223455216220"],"sourceRoot":""}