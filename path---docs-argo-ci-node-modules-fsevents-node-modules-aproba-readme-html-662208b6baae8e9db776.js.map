{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-fsevents-node-modules-aproba-readme-html-662208b6baae8e9db776.js","webpack:///./.cache/json/docs-argo-ci-node-modules-fsevents-node-modules-aproba-readme-html.json"],"names":["webpackJsonp","2368","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,+wGAAk6EC,QAAA,2DAAAC,KAAA","file":"path---docs-argo-ci-node-modules-fsevents-node-modules-aproba-readme-html-662208b6baae8e9db776.js","sourcesContent":["webpackJsonp([251282898854083],{\n\n/***/ 2368:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>aproba</h1>\\n<p>A ridiculously light-weight function argument validator</p>\\n<pre><code>var validate = require(\\\"aproba\\\")\\n\\nfunction myfunc(a, b, c) {\\n  // `a` must be a string, `b` a number, `c` a function\\n  validate('SNF', arguments) // [a,b,c] is also valid\\n}\\n\\nmyfunc('test', 23, function () {}) // ok\\nmyfunc(123, 23, function () {}) // type error\\nmyfunc('test', 23) // missing arg error\\nmyfunc('test', 23, function () {}, true) // too many args error\\n</code></pre>\\n<p>Valid types are:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>type</th>\\n<th>description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>*</td>\\n<td>matches any type</td>\\n</tr>\\n<tr>\\n<td>A</td>\\n<td>Array.isArray OR an arguments object</td>\\n</tr>\\n<tr>\\n<td>S</td>\\n<td>typeof == string</td>\\n</tr>\\n<tr>\\n<td>N</td>\\n<td>typeof == number</td>\\n</tr>\\n<tr>\\n<td>F</td>\\n<td>typeof == function</td>\\n</tr>\\n<tr>\\n<td>O</td>\\n<td>typeof == object and not type A and not type E</td>\\n</tr>\\n<tr>\\n<td>B</td>\\n<td>typeof == boolean</td>\\n</tr>\\n<tr>\\n<td>E</td>\\n<td>instanceof Error OR null \\n<strong>(special: see below)</strong></td>\\n</tr>\\n<tr>\\n<td>Z</td>\\n<td>== null</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Validation failures throw one of three exception types, distinguished by a\\n<code>code</code> property of <code>EMISSINGARG</code>, <code>EINVALIDTYPE</code> or <code>ETOOMANYARGS</code>.</p>\\n<p>If you pass in an invalid type then it will throw with a code of\\n<code>EUNKNOWNTYPE</code>.</p>\\n<p>If an <strong>error</strong> argument is found and is not null then the remaining\\narguments are optional.  That is, if you say <code>ESO</code> then that's like using a\\nnon-magical <code>E</code> in: <code>E|ESO|ZSO</code>.</p>\\n<h3>But I have optional arguments?!</h3>\\n<p>You can provide more than one signature by separating them with pipes <code>|</code>.\\nIf any signature matches the arguments then they'll be considered valid.</p>\\n<p>So for example, say you wanted to write a signature for\\n<code>fs.createWriteStream</code>.  The docs for it describe it thusly:</p>\\n<pre><code>fs.createWriteStream(path[, options])\\n</code></pre>\\n<p>This would be a signature of <code>SO|S</code>.  That is, a string and and object, or\\njust a string.</p>\\n<p>Now, if you read the full <code>fs</code> docs, you'll see that actually path can ALSO\\nbe a buffer.  And options can be a string, that is:</p>\\n<pre><code>path &#x3C;String> | &#x3C;Buffer>\\noptions &#x3C;String> | &#x3C;Object>\\n</code></pre>\\n<p>To reproduce this you have to fully enumerate all of the possible\\ncombinations and that implies a signature of <code>SO|SS|OO|OS|S|O</code>.  The\\nawkwardness is a feature: It reminds you of the complexity you're adding to\\nyour API when you do this sort of thing.</p>\\n<h3>Why this exists</h3>\\n<p>I wanted a very simple argument validator. It needed to do two things:</p>\\n<ol>\\n<li>\\n<p>Be more concise and easier to use than assertions</p>\\n</li>\\n<li>\\n<p>Not encourage an infinite bikeshed of DSLs</p>\\n</li>\\n</ol>\\n<p>This is why types are specified by a single character and there's no such\\nthing as an optional argument. </p>\\n<p>This is not intended to validate user data. This is specifically about\\nasserting the interface of your functions.</p>\\n<p>If you need greater validation, I encourage you to write them by hand or\\nlook elsewhere.</p>\",\"docPath\":\"argo-ci/node_modules/fsevents/node_modules/aproba/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-fsevents-node-modules-aproba-readme-html-662208b6baae8e9db776.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>aproba</h1>\\n<p>A ridiculously light-weight function argument validator</p>\\n<pre><code>var validate = require(\\\"aproba\\\")\\n\\nfunction myfunc(a, b, c) {\\n  // `a` must be a string, `b` a number, `c` a function\\n  validate('SNF', arguments) // [a,b,c] is also valid\\n}\\n\\nmyfunc('test', 23, function () {}) // ok\\nmyfunc(123, 23, function () {}) // type error\\nmyfunc('test', 23) // missing arg error\\nmyfunc('test', 23, function () {}, true) // too many args error\\n</code></pre>\\n<p>Valid types are:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>type</th>\\n<th>description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>*</td>\\n<td>matches any type</td>\\n</tr>\\n<tr>\\n<td>A</td>\\n<td>Array.isArray OR an arguments object</td>\\n</tr>\\n<tr>\\n<td>S</td>\\n<td>typeof == string</td>\\n</tr>\\n<tr>\\n<td>N</td>\\n<td>typeof == number</td>\\n</tr>\\n<tr>\\n<td>F</td>\\n<td>typeof == function</td>\\n</tr>\\n<tr>\\n<td>O</td>\\n<td>typeof == object and not type A and not type E</td>\\n</tr>\\n<tr>\\n<td>B</td>\\n<td>typeof == boolean</td>\\n</tr>\\n<tr>\\n<td>E</td>\\n<td>instanceof Error OR null \\n<strong>(special: see below)</strong></td>\\n</tr>\\n<tr>\\n<td>Z</td>\\n<td>== null</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Validation failures throw one of three exception types, distinguished by a\\n<code>code</code> property of <code>EMISSINGARG</code>, <code>EINVALIDTYPE</code> or <code>ETOOMANYARGS</code>.</p>\\n<p>If you pass in an invalid type then it will throw with a code of\\n<code>EUNKNOWNTYPE</code>.</p>\\n<p>If an <strong>error</strong> argument is found and is not null then the remaining\\narguments are optional.  That is, if you say <code>ESO</code> then that's like using a\\nnon-magical <code>E</code> in: <code>E|ESO|ZSO</code>.</p>\\n<h3>But I have optional arguments?!</h3>\\n<p>You can provide more than one signature by separating them with pipes <code>|</code>.\\nIf any signature matches the arguments then they'll be considered valid.</p>\\n<p>So for example, say you wanted to write a signature for\\n<code>fs.createWriteStream</code>.  The docs for it describe it thusly:</p>\\n<pre><code>fs.createWriteStream(path[, options])\\n</code></pre>\\n<p>This would be a signature of <code>SO|S</code>.  That is, a string and and object, or\\njust a string.</p>\\n<p>Now, if you read the full <code>fs</code> docs, you'll see that actually path can ALSO\\nbe a buffer.  And options can be a string, that is:</p>\\n<pre><code>path &#x3C;String> | &#x3C;Buffer>\\noptions &#x3C;String> | &#x3C;Object>\\n</code></pre>\\n<p>To reproduce this you have to fully enumerate all of the possible\\ncombinations and that implies a signature of <code>SO|SS|OO|OS|S|O</code>.  The\\nawkwardness is a feature: It reminds you of the complexity you're adding to\\nyour API when you do this sort of thing.</p>\\n<h3>Why this exists</h3>\\n<p>I wanted a very simple argument validator. It needed to do two things:</p>\\n<ol>\\n<li>\\n<p>Be more concise and easier to use than assertions</p>\\n</li>\\n<li>\\n<p>Not encourage an infinite bikeshed of DSLs</p>\\n</li>\\n</ol>\\n<p>This is why types are specified by a single character and there's no such\\nthing as an optional argument. </p>\\n<p>This is not intended to validate user data. This is specifically about\\nasserting the interface of your functions.</p>\\n<p>If you need greater validation, I encourage you to write them by hand or\\nlook elsewhere.</p>\",\"docPath\":\"argo-ci/node_modules/fsevents/node_modules/aproba/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-fsevents-node-modules-aproba-readme-html.json\n// module id = 2368\n// module chunks = 251282898854083"],"sourceRoot":""}