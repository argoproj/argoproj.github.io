{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-rimraf-readme-html-4cf4e83c0e15d1fe8bfd.js","webpack:///./.cache/json/docs-argo-ci-node-modules-rimraf-readme-html.json"],"names":["webpackJsonp","3128","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,qrIAA4/HC,QAAA,qCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-rimraf-readme-html-4cf4e83c0e15d1fe8bfd.js","sourcesContent":["webpackJsonp([118678657047299],{\n\n/***/ 3128:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<p><a href=\\\"https://travis-ci.org/isaacs/rimraf\\\"><img src=\\\"https://travis-ci.org/isaacs/rimraf.svg?branch=master\\\" alt=\\\"Build Status\\\"></a> <a href=\\\"https://david-dm.org/isaacs/rimraf\\\"><img src=\\\"https://david-dm.org/isaacs/rimraf.svg\\\" alt=\\\"Dependency Status\\\"></a> <a href=\\\"https://david-dm.org/isaacs/rimraf#info=devDependencies\\\"><img src=\\\"https://david-dm.org/isaacs/rimraf/dev-status.svg\\\" alt=\\\"devDependency Status\\\"></a></p>\\n<p>The <a href=\\\"http://en.wikipedia.org/wiki/Rm_(Unix)\\\">UNIX command</a> <code>rm -rf</code> for node.</p>\\n<p>Install with <code>npm install rimraf</code>, or just drop rimraf.js somewhere.</p>\\n<h2>API</h2>\\n<p><code>rimraf(f, [opts], callback)</code></p>\\n<p>The first parameter will be interpreted as a globbing pattern for files. If you\\nwant to disable globbing you can do so with <code>opts.disableGlob</code> (defaults to\\n<code>false</code>). This might be handy, for instance, if you have filenames that contain\\nglobbing wildcard characters.</p>\\n<p>The callback will be called with an error if there is one.  Certain\\nerrors are handled for you:</p>\\n<ul>\\n<li>Windows: <code>EBUSY</code> and <code>ENOTEMPTY</code> - rimraf will back off a maximum of\\n<code>opts.maxBusyTries</code> times before giving up, adding 100ms of wait\\nbetween each attempt.  The default <code>maxBusyTries</code> is 3.</li>\\n<li><code>ENOENT</code> - If the file doesn't exist, rimraf will return\\nsuccessfully, since your desired outcome is already the case.</li>\\n<li><code>EMFILE</code> - Since <code>readdir</code> requires opening a file descriptor, it's\\npossible to hit <code>EMFILE</code> if too many file descriptors are in use.\\nIn the sync case, there's nothing to be done for this.  But in the\\nasync case, rimraf will gradually back off with timeouts up to\\n<code>opts.emfileWait</code> ms, which defaults to 1000.</li>\\n</ul>\\n<h2>options</h2>\\n<ul>\\n<li>\\n<p>unlink, chmod, stat, lstat, rmdir, readdir,\\nunlinkSync, chmodSync, statSync, lstatSync, rmdirSync, readdirSync</p>\\n<p>In order to use a custom file system library, you can override\\nspecific fs functions on the options object.</p>\\n<p>If any of these functions are present on the options object, then\\nthe supplied function will be used instead of the default fs\\nmethod.</p>\\n<p>Sync methods are only relevant for <code>rimraf.sync()</code>, of course.</p>\\n<p>For example:</p>\\n<pre><code class=\\\"language-javascript\\\">var myCustomFS = require('some-custom-fs')\\n\\nrimraf('some-thing', myCustomFS, callback)\\n</code></pre>\\n</li>\\n<li>\\n<p>maxBusyTries</p>\\n<p>If an <code>EBUSY</code>, <code>ENOTEMPTY</code>, or <code>EPERM</code> error code is encountered\\non Windows systems, then rimraf will retry with a linear backoff\\nwait of 100ms longer on each try.  The default maxBusyTries is 3.</p>\\n<p>Only relevant for async usage.</p>\\n</li>\\n<li>\\n<p>emfileWait</p>\\n<p>If an <code>EMFILE</code> error is encountered, then rimraf will retry\\nrepeatedly with a linear backoff of 1ms longer on each try, until\\nthe timeout counter hits this max.  The default limit is 1000.</p>\\n<p>If you repeatedly encounter <code>EMFILE</code> errors, then consider using\\n<a href=\\\"http://npm.im/graceful-fs\\\">graceful-fs</a> in your program.</p>\\n<p>Only relevant for async usage.</p>\\n</li>\\n<li>\\n<p>glob</p>\\n<p>Set to <code>false</code> to disable <a href=\\\"http://npm.im/glob\\\">glob</a> pattern\\nmatching.</p>\\n<p>Set to an object to pass options to the glob module.  The default\\nglob options are <code>{ nosort: true, silent: true }</code>.</p>\\n<p>Glob version 6 is used in this module.</p>\\n<p>Relevant for both sync and async usage.</p>\\n</li>\\n<li>\\n<p>disableGlob</p>\\n<p>Set to any non-falsey value to disable globbing entirely.\\n(Equivalent to setting <code>glob: false</code>.)</p>\\n</li>\\n</ul>\\n<h2>rimraf.sync</h2>\\n<p>It can remove stuff synchronously, too.  But that's not so good.  Use\\nthe async API.  It's better.</p>\\n<h2>CLI</h2>\\n<p>If installed with <code>npm install rimraf -g</code> it can be used as a global\\ncommand <code>rimraf &#x3C;path> [&#x3C;path> ...]</code> which is useful for cross platform support.</p>\\n<h2>mkdirp</h2>\\n<p>If you need to create a directory recursively, check out\\n<a href=\\\"https://github.com/substack/node-mkdirp\\\">mkdirp</a>.</p>\",\"docPath\":\"argo-ci/node_modules/rimraf/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-rimraf-readme-html-4cf4e83c0e15d1fe8bfd.js","module.exports = {\"pathContext\":{\"docHtml\":\"<p><a href=\\\"https://travis-ci.org/isaacs/rimraf\\\"><img src=\\\"https://travis-ci.org/isaacs/rimraf.svg?branch=master\\\" alt=\\\"Build Status\\\"></a> <a href=\\\"https://david-dm.org/isaacs/rimraf\\\"><img src=\\\"https://david-dm.org/isaacs/rimraf.svg\\\" alt=\\\"Dependency Status\\\"></a> <a href=\\\"https://david-dm.org/isaacs/rimraf#info=devDependencies\\\"><img src=\\\"https://david-dm.org/isaacs/rimraf/dev-status.svg\\\" alt=\\\"devDependency Status\\\"></a></p>\\n<p>The <a href=\\\"http://en.wikipedia.org/wiki/Rm_(Unix)\\\">UNIX command</a> <code>rm -rf</code> for node.</p>\\n<p>Install with <code>npm install rimraf</code>, or just drop rimraf.js somewhere.</p>\\n<h2>API</h2>\\n<p><code>rimraf(f, [opts], callback)</code></p>\\n<p>The first parameter will be interpreted as a globbing pattern for files. If you\\nwant to disable globbing you can do so with <code>opts.disableGlob</code> (defaults to\\n<code>false</code>). This might be handy, for instance, if you have filenames that contain\\nglobbing wildcard characters.</p>\\n<p>The callback will be called with an error if there is one.  Certain\\nerrors are handled for you:</p>\\n<ul>\\n<li>Windows: <code>EBUSY</code> and <code>ENOTEMPTY</code> - rimraf will back off a maximum of\\n<code>opts.maxBusyTries</code> times before giving up, adding 100ms of wait\\nbetween each attempt.  The default <code>maxBusyTries</code> is 3.</li>\\n<li><code>ENOENT</code> - If the file doesn't exist, rimraf will return\\nsuccessfully, since your desired outcome is already the case.</li>\\n<li><code>EMFILE</code> - Since <code>readdir</code> requires opening a file descriptor, it's\\npossible to hit <code>EMFILE</code> if too many file descriptors are in use.\\nIn the sync case, there's nothing to be done for this.  But in the\\nasync case, rimraf will gradually back off with timeouts up to\\n<code>opts.emfileWait</code> ms, which defaults to 1000.</li>\\n</ul>\\n<h2>options</h2>\\n<ul>\\n<li>\\n<p>unlink, chmod, stat, lstat, rmdir, readdir,\\nunlinkSync, chmodSync, statSync, lstatSync, rmdirSync, readdirSync</p>\\n<p>In order to use a custom file system library, you can override\\nspecific fs functions on the options object.</p>\\n<p>If any of these functions are present on the options object, then\\nthe supplied function will be used instead of the default fs\\nmethod.</p>\\n<p>Sync methods are only relevant for <code>rimraf.sync()</code>, of course.</p>\\n<p>For example:</p>\\n<pre><code class=\\\"language-javascript\\\">var myCustomFS = require('some-custom-fs')\\n\\nrimraf('some-thing', myCustomFS, callback)\\n</code></pre>\\n</li>\\n<li>\\n<p>maxBusyTries</p>\\n<p>If an <code>EBUSY</code>, <code>ENOTEMPTY</code>, or <code>EPERM</code> error code is encountered\\non Windows systems, then rimraf will retry with a linear backoff\\nwait of 100ms longer on each try.  The default maxBusyTries is 3.</p>\\n<p>Only relevant for async usage.</p>\\n</li>\\n<li>\\n<p>emfileWait</p>\\n<p>If an <code>EMFILE</code> error is encountered, then rimraf will retry\\nrepeatedly with a linear backoff of 1ms longer on each try, until\\nthe timeout counter hits this max.  The default limit is 1000.</p>\\n<p>If you repeatedly encounter <code>EMFILE</code> errors, then consider using\\n<a href=\\\"http://npm.im/graceful-fs\\\">graceful-fs</a> in your program.</p>\\n<p>Only relevant for async usage.</p>\\n</li>\\n<li>\\n<p>glob</p>\\n<p>Set to <code>false</code> to disable <a href=\\\"http://npm.im/glob\\\">glob</a> pattern\\nmatching.</p>\\n<p>Set to an object to pass options to the glob module.  The default\\nglob options are <code>{ nosort: true, silent: true }</code>.</p>\\n<p>Glob version 6 is used in this module.</p>\\n<p>Relevant for both sync and async usage.</p>\\n</li>\\n<li>\\n<p>disableGlob</p>\\n<p>Set to any non-falsey value to disable globbing entirely.\\n(Equivalent to setting <code>glob: false</code>.)</p>\\n</li>\\n</ul>\\n<h2>rimraf.sync</h2>\\n<p>It can remove stuff synchronously, too.  But that's not so good.  Use\\nthe async API.  It's better.</p>\\n<h2>CLI</h2>\\n<p>If installed with <code>npm install rimraf -g</code> it can be used as a global\\ncommand <code>rimraf &#x3C;path> [&#x3C;path> ...]</code> which is useful for cross platform support.</p>\\n<h2>mkdirp</h2>\\n<p>If you need to create a directory recursively, check out\\n<a href=\\\"https://github.com/substack/node-mkdirp\\\">mkdirp</a>.</p>\",\"docPath\":\"argo-ci/node_modules/rimraf/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-rimraf-readme-html.json\n// module id = 3128\n// module chunks = 118678657047299"],"sourceRoot":""}