webpackJsonp([47283196319842],{2502:function(e,n){e.exports={pathContext:{docHtml:'<h1>json-stringify-safe</h1>\n<p>Like JSON.stringify, but doesn\'t throw on circular references.</p>\n<h2>Usage</h2>\n<p>Takes the same arguments as <code>JSON.stringify</code>.</p>\n<pre><code class="language-javascript">var stringify = require(\'json-stringify-safe\');\nvar circularObj = {};\ncircularObj.circularRef = circularObj;\ncircularObj.list = [ circularObj, circularObj ];\nconsole.log(stringify(circularObj, null, 2));\n</code></pre>\n<p>Output:</p>\n<pre><code class="language-json">{\n  "circularRef": "[Circular]",\n  "list": [\n    "[Circular]",\n    "[Circular]"\n  ]\n}\n</code></pre>\n<h2>Details</h2>\n<pre><code>stringify(obj, serializer, indent, decycler)\n</code></pre>\n<p>The first three arguments are the same as to JSON.stringify.  The last\nis an argument that\'s only used when the object has been seen already.</p>\n<p>The default <code>decycler</code> function returns the string <code>\'[Circular]\'</code>.\nIf, for example, you pass in <code>function(k,v){}</code> (return nothing) then it\nwill prune cycles.  If you pass in <code>function(k,v){ return {foo: \'bar\'}}</code>,\nthen cyclical objects will always be represented as <code>{"foo":"bar"}</code> in\nthe result.</p>\n<pre><code>stringify.getSerialize(serializer, decycler)\n</code></pre>\n<p>Returns a serializer that can be used elsewhere.  This is the actual\nfunction that\'s passed to JSON.stringify.</p>\n<p><strong>Note</strong> that the function returned from <code>getSerialize</code> is stateful for now, so\ndo <strong>not</strong> use it more than once.</p>',docPath:"argo-ci/node_modules/fsevents/node_modules/json-stringify-safe/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-fsevents-node-modules-json-stringify-safe-readme-html-ba0ed12f19d3f5753367.js.map