webpackJsonp([0x698f74f79509],{3250:function(e,t){e.exports={pathContext:{docHtml:'<h1>The <code>__generator</code> helper</h1>\n<p>The <code>__generator</code> helper is a function designed to support TypeScript\'s down-level emit for\nasync functions when targeting ES5 and earlier. But how, exactly, does it work?</p>\n<p>Here\'s the body of the <code>__generator</code> helper:</p>\n<pre><code class="language-js">__generator = function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] &#x26; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;\n    return { next: verb(0), "throw": verb(1), "return": verb(2) };\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y &#x26;&#x26; (t = y[op[0] &#x26; 2 ? "return" : op[0] ? "throw" : "next"]) &#x26;&#x26; !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 &#x26;&#x26; t[t.length - 1]) &#x26;&#x26; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 &#x26;&#x26; (!t || (op[1] > t[0] &#x26;&#x26; op[1] &#x3C; t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 &#x26;&#x26; _.label &#x3C; t[1]) { _.label = t[1]; t = op; break; }\n                    if (t &#x26;&#x26; _.label &#x3C; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] &#x26; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n</code></pre>\n<p>And here\'s an example of it in use:</p>\n<pre><code class="language-ts">// source\nasync function func(x) {\n    try {\n        await x;\n    }\n    catch (e) {\n        console.error(e);\n    }\n    finally {\n        console.log("finally");\n    }\n}\n\n// generated\nfunction func(x) {\n    return __awaiter(this, void 0, void 0, function () {\n        var e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 1, 3, 4]);\n                    return [4 /*yield*/, x];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 2:\n                    e_1 = _a.sent();\n                    console.error(e_1);\n                    return [3 /*break*/, 4];\n                case 3:\n                    console.log("finally");\n                    return [7 /*endfinally*/];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\n</code></pre>\n<p>There is a lot going on in this function, so the following will break down what each part of the\n<code>__generator</code> helper does and how it works.</p>\n<h1>Opcodes</h1>\n<p>The <code>__generator</code> helper uses opcodes which represent various operations that are interpreted by\nthe helper to affect its internal state. The following table lists the various opcodes, their\narguments, and their purpose:</p>\n<table>\n<thead>\n<tr>\n<th>Opcode</th>\n<th>Arguments</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0 (next)</td>\n<td><em>value</em></td>\n<td>Starts the generator, or resumes the generator with \n<em>value</em>\n as the result of the \n<code>AwaitExpression</code>\n where execution was paused.</td>\n</tr>\n<tr>\n<td>1 (throw)</td>\n<td><em>value</em></td>\n<td>Resumes the generator, throwing \n<em>value</em>\n at \n<code>AwaitExpression</code>\n where execution was paused.</td>\n</tr>\n<tr>\n<td>2 (return)</td>\n<td><em>value</em></td>\n<td>Exits the generator, executing any \n<code>finally</code>\n blocks starting at the \n<code>AwaitExpression</code>\n where execution was paused.</td>\n</tr>\n<tr>\n<td>3 (break)</td>\n<td><em>label</em></td>\n<td>Performs an unconditional jump to the specified label, executing any \n<code>finally</code>\n between the current instruction and the label.</td>\n</tr>\n<tr>\n<td>4 (yield)</td>\n<td><em>value</em></td>\n<td>Suspends the generator, setting the resume point at the next label and yielding the value.</td>\n</tr>\n<tr>\n<td>5 (yieldstar)</td>\n<td><em>value</em></td>\n<td>Suspends the generator, setting the resume point at the next label and delegating operations to the supplied value.</td>\n</tr>\n<tr>\n<td>6 (catch)</td>\n<td><em>error</em></td>\n<td>An internal instruction used to indicate an exception that was thrown from the body of the generator.</td>\n</tr>\n<tr>\n<td>7 (endfinally)</td>\n<td></td>\n<td>Exits a finally block, resuming any previous operation (such as a break, return, throw, etc.)</td>\n</tr>\n</tbody>\n</table>\n<h1>State</h1>\n<p>The <code>_</code>, <code>f</code>, <code>y</code>, and <code>t</code> variables make up the persistent state of the <code>__generator</code> function. Each variable\nhas a specific purpose, as described in the following sections:</p>\n<h2>The <code>_</code> variable</h2>\n<p>The <code>__generator</code> helper must share state between its internal <code>step</code> orchestration function and\nthe <code>body</code> function passed to the helper.</p>\n<pre><code class="language-ts">var _ = {\n    label: 0,\n    sent: function() {\n        if (t[0] &#x26; 1) // NOTE: true for `throw`, but not `next` or `catch`\n            throw t[1];\n        return sent[1];\n    },\n    trys: [],\n    ops: []\n};\n</code></pre>\n<p>The following table describes the members of the <code>_</code> state object and their purpose:</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>label</code></td>\n<td>Specifies the next switch case to execute in the \n<code>body</code>\n function.</td>\n</tr>\n<tr>\n<td><code>sent</code></td>\n<td>Handles the completion result passed to the generator.</td>\n</tr>\n<tr>\n<td><code>trys</code></td>\n<td>A stack of \n<strong>Protected Regions</strong>\n, which are 4-tuples that describe the labels that make up a \n<code>try..catch..finally</code>\n block.</td>\n</tr>\n<tr>\n<td><code>ops</code></td>\n<td>A stack of pending operations used for \n<code>try..finally</code>\n blocks.</td>\n</tr>\n</tbody>\n</table>\n<p>The <code>__generator</code> helper passes this state object to the <code>body</code> function for use with switching\nbetween switch cases in the body, handling completions from <code>AwaitExpression</code>, etc.</p>\n<h2>The <code>f</code> variable</h2>\n<p>The <code>f</code> variable indicates whether the generator is currently executing, to prevent re-entry of\nthe same generator during its execution.</p>\n<h2>The <code>y</code> variable</h2>\n<p>The <code>y</code> variable stores the iterator passed to a <code>yieldstar</code> instruction to which operations should be delegated.</p>\n<h2>The <code>t</code> variable</h2>\n<p>The <code>t</code> variable is a temporary variable that stores one of the following values:</p>\n<ul>\n<li>The completion value when resuming from a <code>yield</code> or <code>yield*</code>.</li>\n<li>The error value for a catch block.</li>\n<li>The current <strong>Protected Region</strong>.</li>\n<li>The verb (<code>next</code>, <code>throw</code>, or <code>return</code> method) to delegate to the expression of a <code>yield*</code>.</li>\n<li>The result of evaluating the verb delegated to the expression of a <code>yield*</code>.</li>\n</ul>\n<blockquote>\n<p>NOTE: None of the above cases overlap.</p>\n</blockquote>\n<h1>Protected Regions</h1>\n<p>A <strong>Protected Region</strong> is a region within the <code>body</code> function that indicates a\n<code>try..catch..finally</code> statement. It consists of a 4-tuple that contains 4 labels:</p>\n<table>\n<thead>\n<tr>\n<th>Offset</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td><em>Required</em>\n The label that indicates the beginning of a \n<code>try..catch..finally</code>\n statement.</td>\n</tr>\n<tr>\n<td>1</td>\n<td><em>Optional</em>\n The label that indicates the beginning of a \n<code>catch</code>\n clause.</td>\n</tr>\n<tr>\n<td>2</td>\n<td><em>Optional</em>\n The label that indicates the beginning of a \n<code>finally</code>\n clause.</td>\n</tr>\n<tr>\n<td>3</td>\n<td><em>Required</em>\n The label that indicates the end of the \n<code>try..catch..finally</code>\n statement.</td>\n</tr>\n</tbody>\n</table>\n<h1>The generator object</h1>\n<p>The final step of the <code>__generator</code> helper is the allocation of an object that implements the\n<code>Generator</code> protocol, to be used by the <code>__awaiter</code> helper:</p>\n<pre><code class="language-ts">return { next: verb(0), "throw": verb(1), "return": verb(2) };\nfunction verb(n) { return function (v) { return step([n, v]); }; }\n</code></pre>\n<p>This object translates calls to <code>next</code>, <code>throw</code>, and <code>return</code> to the appropriate Opcodes and\ninvokes the <code>step</code> orchestration function to continue execution. The <code>throw</code> and <code>return</code> method\nnames are quoted to better support ES3.</p>\n<h1>Orchestration</h1>\n<p>The <code>step</code> function is the main orechestration mechanism for the <code>__generator</code> helper. It\ninterprets opcodes, handles <strong>protected regions</strong>, and communicates results back to the caller.</p>\n<p>Here\'s a closer look at the <code>step</code> function:</p>\n<pre><code class="language-ts">function step(op) {\n    if (f) throw new TypeError("Generator is already executing.");\n    while (_) try {\n        if (f = 1, y &#x26;&#x26; (t = y[op[0] &#x26; 2 ? "return" : op[0] ? "throw" : "next"]) &#x26;&#x26; !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n        switch (op[0]) {\n            case 0: case 1: t = op; break;\n            case 4: _.label++; return { value: op[1], done: false };\n            case 5: _.label++; y = op[1]; op = [0]; continue;\n            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n            default:\n                if (!(t = _.trys, t = t.length > 0 &#x26;&#x26; t[t.length - 1]) &#x26;&#x26; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                if (op[0] === 3 &#x26;&#x26; (!t || (op[1] > t[0] &#x26;&#x26; op[1] &#x3C; t[3]))) { _.label = op[1]; break; }\n                if (op[0] === 6 &#x26;&#x26; _.label &#x3C; t[1]) { _.label = t[1]; t = op; break; }\n                if (t &#x26;&#x26; _.label &#x3C; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                if (t[2]) _.ops.pop();\n                _.trys.pop(); continue;\n        }\n        op = body.call(thisArg, _);\n    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n    if (op[0] &#x26; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n}\n</code></pre>\n<p>The main body of <code>step</code> exists in a <code>while</code> loop. This allows us to continually interpret\noperations until we have reached some completion value, be it a <code>return</code>, <code>await</code>, or <code>throw</code>.</p>\n<h2>Preventing re-entry</h2>\n<p>The first part of the <code>step</code> function is used as a check to prevent re-entry into a currently\nexecuting generator:</p>\n<pre><code class="language-ts">if (f) throw new TypeError("Generator is already executing.");\n</code></pre>\n<h2>Running the generator</h2>\n<p>The main body of the <code>step</code> function consists of a <code>while</code> loop which continues to evaluate\ninstructions until the generator exits or is suspended:</p>\n<pre><code class="language-ts">while (_) try ...\n</code></pre>\n<p>When the generator has run to completion, the <code>_</code> state variable will be cleared, forcing the loop\nto exit.</p>\n<h2>Evaluating the generator body.</h2>\n<pre><code class="language-ts">try {\n    ...\n    op = body.call(thisArg, _);\n}\ncatch (e) {\n    op = [6, e];\n    y = 0;\n}\nfinally {\n    f = t = 0;\n}\n</code></pre>\n<p>Depending on the current operation, we re-enter the generator body to start or continue execution.\nHere we invoke <code>body</code> with <code>thisArg</code> as the <code>this</code> binding and the <code>_</code> state object as the only\nargument. The result is a tuple that contains the next Opcode and argument.</p>\n<p>If evaluation of the body resulted in an exception, we convert this into an Opcode 6 ("catch")\noperation to be handled in the next spin of the <code>while</code> loop. We also clear the <code>y</code> variable in\ncase it is set to ensure we are no longer delegating operations as the exception occurred in\nuser code <em>outside</em> of, or at the function boundary of, the delegated iterator (otherwise the\niterator would have handled the exception itself).</p>\n<p>After executing user code, we clear the <code>f</code> flag that indicates we are executing the generator,\nas well as the <code>t</code> temporary value so that we don\'t hold onto values sent to the generator for\nlonger than necessary.</p>\n<p>Inside of the <code>try..finally</code> statement are a series of statements that are used to evaluate the\noperations of the transformed generator body.</p>\n<p>The first thing we do is mark the generator as executing:</p>\n<pre><code class="language-ts">if (f = 1, ...)\n</code></pre>\n<p>Despite the fact this expression is part of the head of an <code>if</code> statement, the comma operator\ncauses it to be evaluated and the result thrown out. This is a minification added purely to\nreduce the overall footprint of the helper.</p>\n<h2>Delegating <code>yield*</code></h2>\n<p>The first two statements of the <code>try..finally</code> statement handle delegation for <code>yield*</code>:</p>\n<pre><code class="language-ts">if (f = 1, y &#x26;&#x26; (t = y[op[0] &#x26; 2 ? "return" : op[0] ? "throw" : "next"]) &#x26;&#x26; !(t = t.call(y, op[1])).done) return t;\nif (y = 0, t) op = [0, t.value];\n</code></pre>\n<p>If the <code>y</code> variable is set, and <code>y</code> has a <code>next</code>, <code>throw</code>, or <code>return</code> method (depending on the\ncurrent operation), we invoke this method and store the return value (an IteratorResult) in <code>t</code>.</p>\n<p>If <code>t</code> indicates it is a yielded value (e.g. <code>t.done === false</code>), we return <code>t</code> to the caller.\nIf <code>t</code> indicates it is a returned value (e.g. <code>t.done === true</code>), we mark the operation with the\n<code>next</code> Opcode, and the returned value.\nIf <code>y</code> did not have the appropriate method, or <code>t</code> was a returned value, we reset <code>y</code> to a falsey\nvalue and continue processing the operation.</p>\n<h2>Handling operations</h2>\n<p>The various Opcodes are handled in the following switch statement:</p>\n<pre><code class="language-ts">switch (op[0]) {\n    case 0: case 1: t = op; break;\n    case 4: _.label++; return { value: op[1], done: false };\n    case 5: _.label++; y = op[1]; op = [0]; continue;\n    case 7: op = _.ops.pop(); _.trys.pop(); continue;\n    default:\n        if (!(t = _.trys, t = t.length > 0 &#x26;&#x26; t[t.length - 1]) &#x26;&#x26; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n        if (op[0] === 3 &#x26;&#x26; (!t || (op[1] > t[0] &#x26;&#x26; op[1] &#x3C; t[3]))) { _.label = op[1]; break; }\n        if (op[0] === 6 &#x26;&#x26; _.label &#x3C; t[1]) { _.label = t[1]; t = op; break; }\n        if (t &#x26;&#x26; _.label &#x3C; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n        if (t[2]) _.ops.pop();\n        _.trys.pop(); continue;\n}\n</code></pre>\n<p>The following sections describe the various Opcodes:</p>\n<h3>Opcode 0 ("next") and Opcode 1 ("throw")</h3>\n<pre><code class="language-ts">case 0: // next\ncase 1: // throw\n    t = op;\n    break;\n</code></pre>\n<p>Both Opcode 0 ("next") and Opcode 1 ("throw") have the same behavior. The current operation is\nstored in the <code>t</code> variable and the <code>body</code> function is invoked. The <code>body</code> function should call\n<code>_.sent()</code> which will evaluate the appropriate completion result.</p>\n<h3>Opcode 4 ("yield")</h3>\n<pre><code class="language-ts">case 4: // yield\n    _.label++;\n    return { value: op[1], done: false };\n</code></pre>\n<p>When we encounter Opcode 4 ("yield"), we increment the label by one to indicate the point at which\nthe generator will resume execution. We then return an <code>IteratorResult</code> whose <code>value</code> is the\nyielded value, and <code>done</code> is <code>false</code>.</p>\n<h3>Opcode 5 ("yieldstar")</h3>\n<pre><code class="language-ts">case 5: // yieldstar\n    _.label++;\n    y = op[1];\n    op = [0];\n    continue;\n</code></pre>\n<p>When we receive Opcode 5 ("yieldstar"), we increment the label by one to indicate the point at which\nthe generator will resume execution. We then store the iterator in <code>op[1]</code> in the <code>y</code> variable, and\nset the operation to delegate to Opcode 0 ("next") with no value. Finally, we continue execution at\nthe top of the loop to start delegation.</p>\n<h3>Opcode 7 ("endfinally")</h3>\n<pre><code class="language-ts">case 7:\n    op = _.ops.pop();\n    _.trys.pop();\n    continue;\n</code></pre>\n<p>Opcode 7 ("endfinally") indicates that we have hit the end of a <code>finally</code> clause, and that the last\noperation recorded before entering the <code>finally</code> block should be evaluated.</p>\n<h3>Opcode 2 ("return"), Opcode 3 ("break"), and Opcode 6 ("catch")</h3>\n<pre><code class="language-ts">default:\n    if (!(t = _.trys, t = t.length > 0 &#x26;&#x26; t[t.length - 1]) &#x26;&#x26; (op[0] === 6 || op[0] === 2)) {\n        _ = 0;\n        continue;\n    }\n    if (op[0] === 3 &#x26;&#x26; (!t || (op[1] > t[0] &#x26;&#x26; op[1] &#x3C; t[3]))) {\n        _.label = op[1];\n        break;\n    }\n    if (op[0] === 6 &#x26;&#x26; _.label &#x3C; t[1]) {\n        _.label = t[1];\n        t = op;\n        break;\n    }\n    if (t &#x26;&#x26; _.label &#x3C; t[2]) {\n        _.label = t[2];\n        _.ops.push(op);\n        break;\n    }\n    if (t[2])\n        _.ops.pop();\n    _.trys.pop();\n    continue;\n}\n</code></pre>\n<p>The handling for Opcode 2 ("return"), Opcode 3 ("break") and Opcode 6 ("catch") is more\ncomplicated, as we must obey the specified runtime semantics of generators. The first line in this\nclause gets the current <strong>Protected Region</strong> if found and stores it in the <code>t</code> temp variable:</p>\n<pre><code class="language-ts">if (!(t = _.trys, t = t.length > 0 &#x26;&#x26; t[t.length - 1]) &#x26;&#x26; ...) ...\n</code></pre>\n<p>The remainder of this statement, as well as the following by several <code>if</code> statements test for more\ncomplex conditions. The first of these is the following:</p>\n<pre><code class="language-ts">if (!(t = ...) &#x26;&#x26; (op[0] === 6 || op[0] === 2)) {\n    _ = 0;\n    continue;\n}\n</code></pre>\n<p>If we encounter an Opcode 6 ("catch") or Opcode 2 ("return"), and we are not in a protected region,\nthen this operation completes the generator by setting the <code>_</code> variable to a falsey value. The\n<code>continue</code> statement resumes execution at the top of the <code>while</code> statement, which will exit the loop\nso that we continue execution at the statement following the loop.</p>\n<pre><code class="language-ts">if (op[0] === 3 &#x26;&#x26; (!t || (op[1] > t[0] &#x26;&#x26; op[1] &#x3C; t[3]))) {\n    _.label = op[1];\n    break;\n}\n</code></pre>\n<p>The <code>if</code> statement above handles Opcode 3 ("break") when we are either not in a <strong>protected region</strong>, or\nare performing an unconditional jump to a label inside of the current <strong>protected region</strong>. In this case\nwe can unconditionally jump to the specified label.</p>\n<pre><code class="language-ts">if (op[0] === 6 &#x26;&#x26; _.label &#x3C; t[1]) {\n    _.label = t[1];\n    t = op;\n    break;\n}\n</code></pre>\n<p>The <code>if</code> statement above handles Opcode 6 ("catch") when inside the <code>try</code> block of a <strong>protected\nregion</strong>. In this case we jump to the <code>catch</code> block, if present. We replace the value of <code>t</code> with\nthe operation so that the exception can be read as the first statement of the transformed <code>catch</code>\nclause of the transformed generator body.</p>\n<pre><code class="language-ts">if (t &#x26;&#x26; _.label &#x3C; t[2]) {\n    _.label = t[2];\n    _.ops.push(op);\n    break;\n}\n</code></pre>\n<p>This <code>if</code> statement handles all Opcodes when in a <strong>protected region</strong> with a <code>finally</code> clause.\nAs long as we are not already inside the <code>finally</code> clause, we jump to the <code>finally</code> clause and\npush the pending operation onto the <code>_.ops</code> stack. This allows us to resume execution of the\npending operation once we have completed execution of the <code>finally</code> clause, as long as it does not\nsupersede this operation with its own completion value.</p>\n<pre><code class="language-ts">if (t[2])\n    _.ops.pop();\n</code></pre>\n<p>Any other completion value inside of a <code>finally</code> clause will supersede the pending completion value\nfrom the <code>try</code> or <code>catch</code> clauses. The above <code>if</code> statement pops the pending completion from the\nstack.</p>\n<pre><code class="language-ts">_.trys.pop();\ncontinue;\n</code></pre>\n<p>The remaining statements handle the point at which we exit a <strong>protected region</strong>. Here we pop the\ncurrent <strong>protected region</strong> from the stack and spin the <code>while</code> statement to evaluate the current\noperation again in the next <strong>protected region</strong> or at the function boundary.</p>\n<h2>Handling a completed generator</h2>\n<p>Once the generator has completed, the <code>_</code> state variable will be falsey. As a result, the <code>while</code>\nloop will terminate and hand control off to the final statement of the orchestration function,\nwhich deals with how a completed generator is evaluated:</p>\n<pre><code class="language-ts">if (op[0] &#x26; 5)\n    throw op[1];\nreturn { value: op[0] ? op[1] : void 0, done: true };\n</code></pre>\n<p>If the caller calls <code>throw</code> on the generator it will send Opcode 1 ("throw"). If an exception\nis uncaught within the body of the generator, it will send Opcode 6 ("catch"). As the generator has\ncompleted, it throws the exception. Both of these cases are caught by the bitmask <code>5</code>, which does\nnot collide with the only two other valid completion Opcodes.</p>\n<p>If the caller calls <code>next</code> on the generator, it will send Opcode 0 ("next"). As the generator has\ncompleted, it returns an <code>IteratorResult</code> where <code>value</code> is <code>undefined</code> and <code>done</code> is true.</p>\n<p>If the caller calls <code>return</code> on the generator, it will send Opcode 2 ("return"). As the generator\nhas completed, it returns an <code>IteratorResult</code> where <code>value</code> is the value provided to <code>return</code>, and\n<code>done</code> is true.</p>',docPath:"argo-ci/node_modules/tslib/docs/generator",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-tslib-docs-generator-html-4605d727104bec43e19d.js.map