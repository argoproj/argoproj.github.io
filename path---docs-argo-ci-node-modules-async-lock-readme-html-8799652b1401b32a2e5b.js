webpackJsonp([0x729cd14705cb],{2064:function(e,n){e.exports={pathContext:{docHtml:"<h1>async-lock</h1>\n<p>Lock on asynchronous code</p>\n<p><a href=\"https://travis-ci.org/rogierschouten/async-lock\"><img src=\"https://travis-ci.org/rogierschouten/async-lock.svg?branch=master\" alt=\"Build Status\"></a></p>\n<ul>\n<li>ES6 promise supported</li>\n<li>Multiple keys lock supported</li>\n<li>Timeout supported</li>\n<li>Pending task limit supported</li>\n<li>Domain reentrant supported</li>\n<li>100% code coverage</li>\n</ul>\n<h2>Why you need locking on single threaded nodejs?</h2>\n<p>Nodejs is single threaded, and the code execution is never get interrupted inside an event loop, so locking is unnecessary? This is true ONLY IF your critical section can be executed inside a single event loop.\nHowever, if you have any async code inside your critical section (it can be simply triggered by any I/O operation, or timer), your critical logic will across multiple event loops, therefore it's not concurrency safe!</p>\n<p>Consider the following code</p>\n<pre><code class=\"language-js\">redis.get('key', function(err, value){\n    redis.set('key', value * 2);\n});\n</code></pre>\n<p>The above code simply multiply a redis key by 2.\nHowever, if two users run concurrency, the execution order may like this</p>\n<pre><code>user1: redis.get('key') -> 1\nuser2: redis.get('key') -> 1\nuser1: redis.set('key', 1 x 2) -> 2\nuser2: redis.set('key', 1 x 2) -> 2\n</code></pre>\n<p>Obviously it's not what you expected</p>\n<p>With asyncLock, you can easily write your async critical section</p>\n<pre><code class=\"language-js\">lock.acquire('key', function(cb){\n    // Concurrency safe\n    redis.get('key', function(err, value){\n        redis.set('key', value * 2, cb);\n    });\n}, function(err, ret){\n});\n</code></pre>\n<h2>Get Started</h2>\n<pre><code>var AsyncLock = require('async-lock');\nvar lock = new AsyncLock();\n\n/**\n * @param {String|Array} key    resource key or keys to lock\n * @param {function} fn     execute function\n * @param {function} cb     (optional) callback function, otherwise will return a promise\n * @param {Object} opts     (optional) options\n */\nlock.acquire(key, function(done){\n    // async work\n    done(err, ret);\n}, function(err, ret){\n    // lock released\n}, opts);\n\n// Promise mode\nlock.acquire(key, function(){\n    // return value or promise\n}, opts).then(function(){\n    // lock released\n});\n</code></pre>\n<h2>Error Handling</h2>\n<pre><code>// Callback mode\nlock.acquire(key, function(done){\n    done(new Error('error'));\n}, function(err, ret){\n    console.log(err.message) // output: error\n});\n\n// Promise mode\nlock.acquire(key, function(){\n    throw new Error('error');\n}).catch(function(err){\n    console.log(err.message) // output: error\n});\n</code></pre>\n<h2>Acquire multiple keys</h2>\n<pre><code>lock.acquire([key1, key2], fn, cb);\n</code></pre>\n<h2>Domain reentrant lock</h2>\n<p>Lock is reentrant in the same domain</p>\n<pre><code>var domain = require('domain');\nvar lock = new AsyncLock({domainReentrant : true});\n\nvar d = domain.create();\nd.run(function(){\n    lock.acquire('key', function(){\n        //Enter lock\n        return lock.acquire('key', function(){\n            //Enter same lock twice\n        });\n    });\n});\n</code></pre>\n<h2>Options</h2>\n<pre><code>// Specify timeout\nvar lock = new AsyncLock({timeout : 5000});\nlock.acquire(key, fn, function(err, ret){\n    // timed out error will be returned here if lock not acquired in given time\n});\n\n// Set max pending tasks\nvar lock = new AsyncLock({maxPending : 1000});\nlock.acquire(key, fn, function(err, ret){\n    // Handle too much pending error\n})\n\n// Whether there is any running or pending async function\nlock.isBusy();\n\n// Use your own promise library instead of the global Promise variable\nvar lock = new AsyncLock({Promise : require('bluebird')}); // Bluebird\nvar lock = new AsyncLock({Promise : require('q')}); // Q\n\n// Add a task to the front of the queue waiting for a given lock\nlock.acquire(key, fn1, cb); // runs immediately\nlock.acquire(key, fn2, cb); // added to queue\nlock.acquire(key, priorityFn, cb, {skipQueue: true}); // jumps queue and runs before fn2\n</code></pre>\n<h2>Changelog</h2>\n<p>See <a href=\"./History.html\">Changelog</a></p>\n<h2>Issues</h2>\n<p>See <a href=\"https://github.com/rogierschouten/async-lock/issues\">isse tracker</a>.</p>\n<h2>License</h2>\n<p>MIT, see <a href=\"./LICENSE\">LICENSE</a></p>",docPath:"argo-ci/node_modules/async-lock/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-async-lock-readme-html-8799652b1401b32a2e5b.js.map