{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-ansi-align-node-modules-ansi-regex-readme-html-91adcb9cf767f99fa88f.js","webpack:///./.cache/json/docs-argo-ci-node-modules-ansi-align-node-modules-ansi-regex-readme-html.json"],"names":["webpackJsonp","2007","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,mgEAA2rDC,QAAA,iEAAAC,KAAA","file":"path---docs-argo-ci-node-modules-ansi-align-node-modules-ansi-regex-readme-html-91adcb9cf767f99fa88f.js","sourcesContent":["webpackJsonp([21397896060372],{\n\n/***/ 2007:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>ansi-regex <a href=\\\"https://travis-ci.org/chalk/ansi-regex\\\"><img src=\\\"https://travis-ci.org/chalk/ansi-regex.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></h1>\\n<blockquote>\\n<p>Regular expression for matching <a href=\\\"https://en.wikipedia.org/wiki/ANSI_escape_code\\\">ANSI escape codes</a></p>\\n</blockquote>\\n<h2>Install</h2>\\n<pre><code>$ npm install ansi-regex\\n</code></pre>\\n<h2>Usage</h2>\\n<pre><code class=\\\"language-js\\\">const ansiRegex = require('ansi-regex');\\n\\nansiRegex().test('\\\\u001B[4mcake\\\\u001B[0m');\\n//=> true\\n\\nansiRegex().test('cake');\\n//=> false\\n\\n'\\\\u001B[4mcake\\\\u001B[0m'.match(ansiRegex());\\n//=> ['\\\\u001B[4m', '\\\\u001B[0m']\\n</code></pre>\\n<h2>FAQ</h2>\\n<h3>Why do you test for codes not in the ECMA 48 standard?</h3>\\n<p>Some of the codes we run as a test are codes that we acquired finding various lists of non-standard or manufacturer specific codes. We test for both standard and non-standard codes, as most of them follow the same or similar format and can be safely matched in strings without the risk of removing actual string content. There are a few non-standard control codes that do not follow the traditional format (i.e. they end in numbers) thus forcing us to exclude them from the test because we cannot reliably match them.</p>\\n<p>On the historical side, those ECMA standards were established in the early 90's whereas the VT100, for example, was designed in the mid/late 70's. At that point in time, control codes were still pretty ungoverned and engineers used them for a multitude of things, namely to activate hardware ports that may have been proprietary. Somewhere else you see a similar 'anarchy' of codes is in the x86 architecture for processors; there are a ton of \\\"interrupts\\\" that can mean different things on certain brands of processors, most of which have been phased out.</p>\\n<h2>Maintainers</h2>\\n<ul>\\n<li><a href=\\\"https://github.com/sindresorhus\\\">Sindre Sorhus</a></li>\\n<li><a href=\\\"https://github.com/qix-\\\">Josh Junon</a></li>\\n</ul>\\n<h2>License</h2>\\n<p>MIT</p>\",\"docPath\":\"argo-ci/node_modules/ansi-align/node_modules/ansi-regex/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-ansi-align-node-modules-ansi-regex-readme-html-91adcb9cf767f99fa88f.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>ansi-regex <a href=\\\"https://travis-ci.org/chalk/ansi-regex\\\"><img src=\\\"https://travis-ci.org/chalk/ansi-regex.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></h1>\\n<blockquote>\\n<p>Regular expression for matching <a href=\\\"https://en.wikipedia.org/wiki/ANSI_escape_code\\\">ANSI escape codes</a></p>\\n</blockquote>\\n<h2>Install</h2>\\n<pre><code>$ npm install ansi-regex\\n</code></pre>\\n<h2>Usage</h2>\\n<pre><code class=\\\"language-js\\\">const ansiRegex = require('ansi-regex');\\n\\nansiRegex().test('\\\\u001B[4mcake\\\\u001B[0m');\\n//=> true\\n\\nansiRegex().test('cake');\\n//=> false\\n\\n'\\\\u001B[4mcake\\\\u001B[0m'.match(ansiRegex());\\n//=> ['\\\\u001B[4m', '\\\\u001B[0m']\\n</code></pre>\\n<h2>FAQ</h2>\\n<h3>Why do you test for codes not in the ECMA 48 standard?</h3>\\n<p>Some of the codes we run as a test are codes that we acquired finding various lists of non-standard or manufacturer specific codes. We test for both standard and non-standard codes, as most of them follow the same or similar format and can be safely matched in strings without the risk of removing actual string content. There are a few non-standard control codes that do not follow the traditional format (i.e. they end in numbers) thus forcing us to exclude them from the test because we cannot reliably match them.</p>\\n<p>On the historical side, those ECMA standards were established in the early 90's whereas the VT100, for example, was designed in the mid/late 70's. At that point in time, control codes were still pretty ungoverned and engineers used them for a multitude of things, namely to activate hardware ports that may have been proprietary. Somewhere else you see a similar 'anarchy' of codes is in the x86 architecture for processors; there are a ton of \\\"interrupts\\\" that can mean different things on certain brands of processors, most of which have been phased out.</p>\\n<h2>Maintainers</h2>\\n<ul>\\n<li><a href=\\\"https://github.com/sindresorhus\\\">Sindre Sorhus</a></li>\\n<li><a href=\\\"https://github.com/qix-\\\">Josh Junon</a></li>\\n</ul>\\n<h2>License</h2>\\n<p>MIT</p>\",\"docPath\":\"argo-ci/node_modules/ansi-align/node_modules/ansi-regex/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-ansi-align-node-modules-ansi-regex-readme-html.json\n// module id = 2007\n// module chunks = 21397896060372"],"sourceRoot":""}