{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-kubernetes-client-8436ceb24057cc170658.js","webpack:///./.cache/json/docs-argo-ci-node-modules-kubernetes-client.json"],"names":["webpackJsonp","2815","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,s7XAA+/VC,QAAA,gDAAAC,KAAA","file":"path---docs-argo-ci-node-modules-kubernetes-client-8436ceb24057cc170658.js","sourcesContent":["webpackJsonp([77660504496275],{\n\n/***/ 2815:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>kubernetes-client</h1>\\n<p><a href=\\\"https://travis-ci.org/godaddy/kubernetes-client\\\"><img src=\\\"https://travis-ci.org/godaddy/kubernetes-client.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></p>\\n<p>Simplified <a href=\\\"http://kubernetes.io/\\\">Kubernetes API</a> client for Node.js.</p>\\n<h2>Installation</h2>\\n<p>Install via npm:</p>\\n<pre><code class=\\\"language-console\\\">$ npm i kubernetes-client --save\\n</code></pre>\\n<h2>Examples</h2>\\n<p>kubernetes-client provides access to all the Kubernetes objects and\\nincludes some niceties for writing simpler code.</p>\\n<h3>Basics</h3>\\n<p>kubernetes-client maps the URI paths in the Kubernetes API to\\nsequences of objects chained together via properties and ending in a\\nfunction. For example, to GET the <code>ReplicationController</code> named\\n'http-rc' in the <code>Namespace</code> 'my-project':</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst core = new Api.Core({\\n  url: 'http://my-k8s-api-server.com',\\n  version: 'v1',  // Defaults to 'v1'\\n  namespace: 'my-project' // Defaults to 'default'\\n});\\n\\nfunction print(err, result) {\\n  console.log(JSON.stringify(err || result, null, 2));\\n}\\n\\ncore.namespaces.replicationcontrollers('http-rc').get(print);\\n</code></pre>\\n<p>kubernetes-client supports the Extensions API group. For example, GET\\nthe <code>Deployment</code> named <code>http-deployment</code>:</p>\\n<pre><code class=\\\"language-js\\\">const ext = new Api.Extensions({\\n  url: 'http://my-k8s-api-server.com',\\n  version: 'v1beta1',  // Defaults to 'v1beta1'\\n  namespace: 'my-project' // Defaults to 'default'\\n});\\n\\next.namespaces.deployments('http-deployment').get(print);\\n</code></pre>\\n<p>kubernetes-client provides a helper to get in-cluster config and accessing the API from a Pod:</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst core = new Api.Core(Api.config.getInCluster());\\n</code></pre>\\n<p>and a helper to get the current-context config from <code>~/.kube/config</code>:</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst core = new Api.Core(Api.config.fromKubeconfig());\\n</code></pre>\\n<h3><strong>Experimental</strong> support for promises and async/await</h3>\\n<p>kubernetes-client exposes <strong>experimental</strong> support for promises via\\nthe <code>promises</code> option passed to API group constructors. The API is the\\nsame, except for the functions that previously took a callback\\n(<em>e.g.</em>, <code>.get</code>). Those functions now return a promise.</p>\\n<pre><code class=\\\"language-js\\\">// Notice the promises: true\\nconst core = new Api.Core({\\n  url: 'http://my-k8s-api-server.com',\\n  version: 'v1',  // Defaults to 'v1'\\n  promises: true,  // Enable promises\\n  namespace: 'my-project' // Defaults to 'default'\\n});\\n</code></pre>\\n<p>and then:</p>\\n<pre><code class=\\\"language-js\\\">core.namespaces.replicationcontrollers('http-rc').get()\\n  .then(result => print(null, result));\\n</code></pre>\\n<p>or with <code>async/await</code>:</p>\\n<pre><code class=\\\"language-js\\\">print(null, await core.namespaces.replicationcontrollers('http-rc').get());\\n</code></pre>\\n<p>You can invoke promise-based and callback-based functions explictly:</p>\\n<pre><code class=\\\"language-js\\\">print(null, await core.namespaces.replicationcontrollers('http-rc').getPromise());\\ncore.namespaces.replicationcontrollers('http-rc').getCb(print);\\n</code></pre>\\n<h3>Creating and updating</h3>\\n<p>kubernetes-client objects expose <code>.post</code>, <code>.patch</code>, and <code>.put</code>\\nmethods. Create the ReplicationController from the example above:</p>\\n<pre><code class=\\\"language-js\\\">const manifestObject = require('./rc.json');\\ncore.namespaces.replicationcontrollers.post({ body: manifestObject }, print);\\n</code></pre>\\n<p>or update the number of replicas:</p>\\n<pre><code class=\\\"language-js\\\">const patch = { spec: { replicas: 10 } };\\ncore.namespaces.replicationcontrollers('http-rc').patch({\\n  body: patch\\n}, print);\\n</code></pre>\\n<h3>Using the correct API group and version</h3>\\n<p>kubernetes-client client includes functionality to help determine the\\ncorrect Kubernetes API group and version to use based on manifests:</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst api = new Api.Api({\\n  url: 'http://my-k8s-api-server.com',\\n  namespace: 'my-project'\\n});\\n\\nconst manifest0 = {\\n  kind: 'Deployment',\\n  apiVersion: 'extensions/v1beta1'\\n  ...\\n};\\nconst manifest1 = {\\n  kind: 'ReplicationController',\\n  apiVersion: 'v1'\\n  ...\\n};\\n\\napi.group(manifest0).ns.kind(manifest0).post({ body: manifest0 }, print);\\napi.group(manifest1).ns.kind(manifest1).post({ body: manifest1 }, print);\\n</code></pre>\\n<h3>Object name aliases</h3>\\n<p>kubernetes-client supports the same aliases as\\n<a href=\\\"http://kubernetes.io/docs/user-guide/kubectl-overview/\\\"><code>kubectl</code></a>\\n(<em>e.g.</em>, <code>ns</code> for <code>namespaces</code>) and the singular versions of the\\nresource name (<em>e.g.</em>, <code>namespace</code> for <code>namespaces</code>). We can shorten\\nthe example above:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc('http-rc').get(print);\\n</code></pre>\\n<h3>Switching namespaces</h3>\\n<p>You can call the <code>namespace</code> object to specify the namespace:</p>\\n<pre><code class=\\\"language-js\\\">core.ns('other-project').rc('http-rc').get(print);\\n</code></pre>\\n<h3>Query parameters</h3>\\n<p>You can optionally specify query string object <code>qs</code> to GET\\nendpoints. kubernetes-client passes <code>qs</code> directly to\\n<a href=\\\"https://www.npmjs.com/package/request#requestoptions-callback\\\"><code>request</code></a>.\\nFor example to filter based on <a href=\\\"http://kubernetes.io/docs/user-guide/labels/\\\">label\\nselector</a>:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.get({ qs: { labelSelector: 'service=http,component=api' } }, print);\\n</code></pre>\\n<h3>Label selector filtering</h3>\\n<p>kubernetes-client has a shortcut, <code>matchLabels</code>, for filtering on label\\nselector equality:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.matchLabels({ service: 'http' }).get(print);\\n</code></pre>\\n<p>and a more general <code>match</code> method based on Kubernetes Match Expressions:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.match([{\\n  key: 'service',\\n  operator: 'In',\\n  values: ['http']\\n}, {\\n  key: 'deploy',\\n  operator: 'NotIn',\\n  values: ['production', 'staging']\\n}]).get(print);\\n</code></pre>\\n<p><strong>Note:</strong> The Kubernetes API supports label selector filtering <a href=\\\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\\\">for GET\\nmethods\\nonly</a>. The\\nKubernetes API does not support label selector filtering for POST,\\nPUT, PATCH, or DELETE.</p>\\n<h3>ThirdPartyResources</h3>\\n<p>You can extend the Kubernetes API using a\\n<a href=\\\"https://kubernetes.io/docs/user-guide/thirdpartyresources/\\\">ThirdPartyResource</a>\\nand kubernetes-client:</p>\\n<pre><code class=\\\"language-js\\\">const newResoure = {\\n  apiVersion: 'extensions/v1beta1',\\n  kind: 'ThirdPartyResource',\\n  metadata: {\\n    name: 'new-resource.kubernetes-client.io'\\n  },\\n  description: 'Example resource',\\n  versions: [{\\n    name: 'v1'\\n  }]\\n};\\n\\next.thirdpartyresources.post({ body: newResource }, print);\\n</code></pre>\\n<p>and then extend an <code>ThirdPartyResource</code> API client with your new resources:</p>\\n<pre><code class=\\\"language-js\\\">const thirdPartyResources = new Api.ThirdPartyResources({\\n  url: 'http://my-k8s-api-server.com',\\n  group: 'kubernetes-client.io',\\n  resources: ['customresources']  // Notice pluralization!\\n});\\n\\n// Access `customresources` as if they were a regular Kubernetes object\\nthirdPartyResources.ns.customresources.get(print);\\nthirdPartyResources.addResource('newresources');  // Notice pluralization!\\n// Now access `newresources`\\nthirdPartyResources.ns.newresources.get(print);\\n</code></pre>\\n<h3>ReplicationController Pods</h3>\\n<p>kubernetes-client provides a shortcut for listing all Pods matching a\\nReplicationController selector:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.po.get(print);\\n</code></pre>\\n<p>kubernetes-client deletes all the Pods associated with a\\nReplicationController when it deletes the ReplicationController. You\\ncan preserve the Pods:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.delete({ name: 'http-rc', preservePods: true }, print);\\n</code></pre>\\n<h3>Watching and streaming</h3>\\n<p>You can call <code>.getStream</code> to stream results. This is useful for watching:</p>\\n<pre><code class=\\\"language-js\\\">const JSONStream = require('json-stream');\\nconst jsonStream = new JSONStream();\\n\\nconst stream = core.ns.po.getStream({ qs: { watch: true } });\\nstream.pipe(jsonStream);\\njsonStream.on('data', object => {\\n  console.log('Pod:', JSON.stringify(object, null, 2));\\n});\\n</code></pre>\\n<p>You can access logs in a similar fashion:</p>\\n<pre><code class=\\\"language-js\\\">const stream = core.ns.po('http-123').log.getStream({ qs: { follow: true } });\\nstream.on('data', chunk => {\\n  process.stdout.write(chunk.toString());\\n});\\n</code></pre>\\n<p><strong>Note:</strong> the kube-apiserver will close watch connections eventually\\naccording to the\\n[<code>--min-request-timeout</code>](<a href=\\\"http://kubernetes.io/docs/admin/kube-apiserver/\\\">http://kubernetes.io/docs/admin/kube-apiserver/</a>\\ncommand line argument. kubernetes-client does not attempt to reconnect\\nwhen the kube-apiserver closes a connection.</p>\\n<h3>Authenticating</h3>\\n<p>kubernetes-client supports Kubernetes <a href=\\\"http://kubernetes.io/docs/admin/authentication/\\\">apiserver\\nauthentication</a>.</p>\\n<p>Basic authentication (with optional certificate authority):</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  ca: fs.readFileSync('cluster-ca.pem'),\\n  auth: {\\n    user: 'user',\\n    pass: 'pass'\\n  }\\n});\\n</code></pre>\\n<p>or without a certificate authority:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  insecureSkipTlsVerify: true,\\n  auth: {\\n    user: 'user',\\n    pass: 'pass'\\n  }\\n});\\n</code></pre>\\n<p>token authentication:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  auth: {\\n    bearer: 'token'\\n  }\\n});\\n</code></pre>\\n<p>and client certificate authentication:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  ca: fs.readFileSync('cluster-ca.pem'),\\n  cert: fs.readFileSync('my-user-cert.pem'),\\n  key: fs.readFileSync('my-user-key.pem')\\n});\\n</code></pre>\\n<h3>Passing options to <code>request</code></h3>\\n<p>kubernetes-client uses\\n<a href=\\\"https://github.com/request/request\\\"><code>request</code></a>. You can specify\\n<a href=\\\"https://github.com/request/request#requestoptions-callback\\\"><code>request</code>\\noptions</a>\\nfor kubernetes-client to pass to <code>request</code>:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  request: {\\n    timeout: 3000\\n  }\\n});\\n</code></pre>\\n<h2>Testing</h2>\\n<p>kubernetes-client includes unit tests and integration tests.\\n<a href=\\\"https://github.com/kubernetes/minikube\\\">Minikube</a> is a tool that\\nmakes it easy to run integration tests locally.</p>\\n<p>Run the unit tests:</p>\\n<pre><code class=\\\"language-console\\\">$ npm test\\n</code></pre>\\n<p>The integration tests use a running Kubernetes server. You specify the\\nKubernetes server context via the <code>CONTEXT</code> environment variable. For\\nexample, run the integration tests with the <code>minikube</code> context:</p>\\n<pre><code class=\\\"language-console\\\">$ CONTEXT=minikube npm run test-integration\\n</code></pre>\\n<h2>More Documentation</h2>\\n<ul>\\n<li><a href=\\\"http://kubernetes.io/docs/reference/\\\">Kubernetes Reference Documentation</a></li>\\n<li><a href=\\\"http://kubernetes.io/kubernetes/third_party/swagger-ui/\\\">Kubernetes Swagger Spec</a></li>\\n</ul>\\n<h2>License</h2>\\n<p><a href=\\\"LICENSE\\\">MIT</a></p>\",\"docPath\":\"argo-ci/node_modules/kubernetes-client/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-kubernetes-client-8436ceb24057cc170658.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>kubernetes-client</h1>\\n<p><a href=\\\"https://travis-ci.org/godaddy/kubernetes-client\\\"><img src=\\\"https://travis-ci.org/godaddy/kubernetes-client.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></p>\\n<p>Simplified <a href=\\\"http://kubernetes.io/\\\">Kubernetes API</a> client for Node.js.</p>\\n<h2>Installation</h2>\\n<p>Install via npm:</p>\\n<pre><code class=\\\"language-console\\\">$ npm i kubernetes-client --save\\n</code></pre>\\n<h2>Examples</h2>\\n<p>kubernetes-client provides access to all the Kubernetes objects and\\nincludes some niceties for writing simpler code.</p>\\n<h3>Basics</h3>\\n<p>kubernetes-client maps the URI paths in the Kubernetes API to\\nsequences of objects chained together via properties and ending in a\\nfunction. For example, to GET the <code>ReplicationController</code> named\\n'http-rc' in the <code>Namespace</code> 'my-project':</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst core = new Api.Core({\\n  url: 'http://my-k8s-api-server.com',\\n  version: 'v1',  // Defaults to 'v1'\\n  namespace: 'my-project' // Defaults to 'default'\\n});\\n\\nfunction print(err, result) {\\n  console.log(JSON.stringify(err || result, null, 2));\\n}\\n\\ncore.namespaces.replicationcontrollers('http-rc').get(print);\\n</code></pre>\\n<p>kubernetes-client supports the Extensions API group. For example, GET\\nthe <code>Deployment</code> named <code>http-deployment</code>:</p>\\n<pre><code class=\\\"language-js\\\">const ext = new Api.Extensions({\\n  url: 'http://my-k8s-api-server.com',\\n  version: 'v1beta1',  // Defaults to 'v1beta1'\\n  namespace: 'my-project' // Defaults to 'default'\\n});\\n\\next.namespaces.deployments('http-deployment').get(print);\\n</code></pre>\\n<p>kubernetes-client provides a helper to get in-cluster config and accessing the API from a Pod:</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst core = new Api.Core(Api.config.getInCluster());\\n</code></pre>\\n<p>and a helper to get the current-context config from <code>~/.kube/config</code>:</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst core = new Api.Core(Api.config.fromKubeconfig());\\n</code></pre>\\n<h3><strong>Experimental</strong> support for promises and async/await</h3>\\n<p>kubernetes-client exposes <strong>experimental</strong> support for promises via\\nthe <code>promises</code> option passed to API group constructors. The API is the\\nsame, except for the functions that previously took a callback\\n(<em>e.g.</em>, <code>.get</code>). Those functions now return a promise.</p>\\n<pre><code class=\\\"language-js\\\">// Notice the promises: true\\nconst core = new Api.Core({\\n  url: 'http://my-k8s-api-server.com',\\n  version: 'v1',  // Defaults to 'v1'\\n  promises: true,  // Enable promises\\n  namespace: 'my-project' // Defaults to 'default'\\n});\\n</code></pre>\\n<p>and then:</p>\\n<pre><code class=\\\"language-js\\\">core.namespaces.replicationcontrollers('http-rc').get()\\n  .then(result => print(null, result));\\n</code></pre>\\n<p>or with <code>async/await</code>:</p>\\n<pre><code class=\\\"language-js\\\">print(null, await core.namespaces.replicationcontrollers('http-rc').get());\\n</code></pre>\\n<p>You can invoke promise-based and callback-based functions explictly:</p>\\n<pre><code class=\\\"language-js\\\">print(null, await core.namespaces.replicationcontrollers('http-rc').getPromise());\\ncore.namespaces.replicationcontrollers('http-rc').getCb(print);\\n</code></pre>\\n<h3>Creating and updating</h3>\\n<p>kubernetes-client objects expose <code>.post</code>, <code>.patch</code>, and <code>.put</code>\\nmethods. Create the ReplicationController from the example above:</p>\\n<pre><code class=\\\"language-js\\\">const manifestObject = require('./rc.json');\\ncore.namespaces.replicationcontrollers.post({ body: manifestObject }, print);\\n</code></pre>\\n<p>or update the number of replicas:</p>\\n<pre><code class=\\\"language-js\\\">const patch = { spec: { replicas: 10 } };\\ncore.namespaces.replicationcontrollers('http-rc').patch({\\n  body: patch\\n}, print);\\n</code></pre>\\n<h3>Using the correct API group and version</h3>\\n<p>kubernetes-client client includes functionality to help determine the\\ncorrect Kubernetes API group and version to use based on manifests:</p>\\n<pre><code class=\\\"language-js\\\">const Api = require('kubernetes-client');\\nconst api = new Api.Api({\\n  url: 'http://my-k8s-api-server.com',\\n  namespace: 'my-project'\\n});\\n\\nconst manifest0 = {\\n  kind: 'Deployment',\\n  apiVersion: 'extensions/v1beta1'\\n  ...\\n};\\nconst manifest1 = {\\n  kind: 'ReplicationController',\\n  apiVersion: 'v1'\\n  ...\\n};\\n\\napi.group(manifest0).ns.kind(manifest0).post({ body: manifest0 }, print);\\napi.group(manifest1).ns.kind(manifest1).post({ body: manifest1 }, print);\\n</code></pre>\\n<h3>Object name aliases</h3>\\n<p>kubernetes-client supports the same aliases as\\n<a href=\\\"http://kubernetes.io/docs/user-guide/kubectl-overview/\\\"><code>kubectl</code></a>\\n(<em>e.g.</em>, <code>ns</code> for <code>namespaces</code>) and the singular versions of the\\nresource name (<em>e.g.</em>, <code>namespace</code> for <code>namespaces</code>). We can shorten\\nthe example above:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc('http-rc').get(print);\\n</code></pre>\\n<h3>Switching namespaces</h3>\\n<p>You can call the <code>namespace</code> object to specify the namespace:</p>\\n<pre><code class=\\\"language-js\\\">core.ns('other-project').rc('http-rc').get(print);\\n</code></pre>\\n<h3>Query parameters</h3>\\n<p>You can optionally specify query string object <code>qs</code> to GET\\nendpoints. kubernetes-client passes <code>qs</code> directly to\\n<a href=\\\"https://www.npmjs.com/package/request#requestoptions-callback\\\"><code>request</code></a>.\\nFor example to filter based on <a href=\\\"http://kubernetes.io/docs/user-guide/labels/\\\">label\\nselector</a>:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.get({ qs: { labelSelector: 'service=http,component=api' } }, print);\\n</code></pre>\\n<h3>Label selector filtering</h3>\\n<p>kubernetes-client has a shortcut, <code>matchLabels</code>, for filtering on label\\nselector equality:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.matchLabels({ service: 'http' }).get(print);\\n</code></pre>\\n<p>and a more general <code>match</code> method based on Kubernetes Match Expressions:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.match([{\\n  key: 'service',\\n  operator: 'In',\\n  values: ['http']\\n}, {\\n  key: 'deploy',\\n  operator: 'NotIn',\\n  values: ['production', 'staging']\\n}]).get(print);\\n</code></pre>\\n<p><strong>Note:</strong> The Kubernetes API supports label selector filtering <a href=\\\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\\\">for GET\\nmethods\\nonly</a>. The\\nKubernetes API does not support label selector filtering for POST,\\nPUT, PATCH, or DELETE.</p>\\n<h3>ThirdPartyResources</h3>\\n<p>You can extend the Kubernetes API using a\\n<a href=\\\"https://kubernetes.io/docs/user-guide/thirdpartyresources/\\\">ThirdPartyResource</a>\\nand kubernetes-client:</p>\\n<pre><code class=\\\"language-js\\\">const newResoure = {\\n  apiVersion: 'extensions/v1beta1',\\n  kind: 'ThirdPartyResource',\\n  metadata: {\\n    name: 'new-resource.kubernetes-client.io'\\n  },\\n  description: 'Example resource',\\n  versions: [{\\n    name: 'v1'\\n  }]\\n};\\n\\next.thirdpartyresources.post({ body: newResource }, print);\\n</code></pre>\\n<p>and then extend an <code>ThirdPartyResource</code> API client with your new resources:</p>\\n<pre><code class=\\\"language-js\\\">const thirdPartyResources = new Api.ThirdPartyResources({\\n  url: 'http://my-k8s-api-server.com',\\n  group: 'kubernetes-client.io',\\n  resources: ['customresources']  // Notice pluralization!\\n});\\n\\n// Access `customresources` as if they were a regular Kubernetes object\\nthirdPartyResources.ns.customresources.get(print);\\nthirdPartyResources.addResource('newresources');  // Notice pluralization!\\n// Now access `newresources`\\nthirdPartyResources.ns.newresources.get(print);\\n</code></pre>\\n<h3>ReplicationController Pods</h3>\\n<p>kubernetes-client provides a shortcut for listing all Pods matching a\\nReplicationController selector:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.po.get(print);\\n</code></pre>\\n<p>kubernetes-client deletes all the Pods associated with a\\nReplicationController when it deletes the ReplicationController. You\\ncan preserve the Pods:</p>\\n<pre><code class=\\\"language-js\\\">core.ns.rc.delete({ name: 'http-rc', preservePods: true }, print);\\n</code></pre>\\n<h3>Watching and streaming</h3>\\n<p>You can call <code>.getStream</code> to stream results. This is useful for watching:</p>\\n<pre><code class=\\\"language-js\\\">const JSONStream = require('json-stream');\\nconst jsonStream = new JSONStream();\\n\\nconst stream = core.ns.po.getStream({ qs: { watch: true } });\\nstream.pipe(jsonStream);\\njsonStream.on('data', object => {\\n  console.log('Pod:', JSON.stringify(object, null, 2));\\n});\\n</code></pre>\\n<p>You can access logs in a similar fashion:</p>\\n<pre><code class=\\\"language-js\\\">const stream = core.ns.po('http-123').log.getStream({ qs: { follow: true } });\\nstream.on('data', chunk => {\\n  process.stdout.write(chunk.toString());\\n});\\n</code></pre>\\n<p><strong>Note:</strong> the kube-apiserver will close watch connections eventually\\naccording to the\\n[<code>--min-request-timeout</code>](<a href=\\\"http://kubernetes.io/docs/admin/kube-apiserver/\\\">http://kubernetes.io/docs/admin/kube-apiserver/</a>\\ncommand line argument. kubernetes-client does not attempt to reconnect\\nwhen the kube-apiserver closes a connection.</p>\\n<h3>Authenticating</h3>\\n<p>kubernetes-client supports Kubernetes <a href=\\\"http://kubernetes.io/docs/admin/authentication/\\\">apiserver\\nauthentication</a>.</p>\\n<p>Basic authentication (with optional certificate authority):</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  ca: fs.readFileSync('cluster-ca.pem'),\\n  auth: {\\n    user: 'user',\\n    pass: 'pass'\\n  }\\n});\\n</code></pre>\\n<p>or without a certificate authority:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  insecureSkipTlsVerify: true,\\n  auth: {\\n    user: 'user',\\n    pass: 'pass'\\n  }\\n});\\n</code></pre>\\n<p>token authentication:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  auth: {\\n    bearer: 'token'\\n  }\\n});\\n</code></pre>\\n<p>and client certificate authentication:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  ca: fs.readFileSync('cluster-ca.pem'),\\n  cert: fs.readFileSync('my-user-cert.pem'),\\n  key: fs.readFileSync('my-user-key.pem')\\n});\\n</code></pre>\\n<h3>Passing options to <code>request</code></h3>\\n<p>kubernetes-client uses\\n<a href=\\\"https://github.com/request/request\\\"><code>request</code></a>. You can specify\\n<a href=\\\"https://github.com/request/request#requestoptions-callback\\\"><code>request</code>\\noptions</a>\\nfor kubernetes-client to pass to <code>request</code>:</p>\\n<pre><code class=\\\"language-js\\\">const core = new Api.Core({\\n  url: 'https://my-k8s-api-server.com',\\n  request: {\\n    timeout: 3000\\n  }\\n});\\n</code></pre>\\n<h2>Testing</h2>\\n<p>kubernetes-client includes unit tests and integration tests.\\n<a href=\\\"https://github.com/kubernetes/minikube\\\">Minikube</a> is a tool that\\nmakes it easy to run integration tests locally.</p>\\n<p>Run the unit tests:</p>\\n<pre><code class=\\\"language-console\\\">$ npm test\\n</code></pre>\\n<p>The integration tests use a running Kubernetes server. You specify the\\nKubernetes server context via the <code>CONTEXT</code> environment variable. For\\nexample, run the integration tests with the <code>minikube</code> context:</p>\\n<pre><code class=\\\"language-console\\\">$ CONTEXT=minikube npm run test-integration\\n</code></pre>\\n<h2>More Documentation</h2>\\n<ul>\\n<li><a href=\\\"http://kubernetes.io/docs/reference/\\\">Kubernetes Reference Documentation</a></li>\\n<li><a href=\\\"http://kubernetes.io/kubernetes/third_party/swagger-ui/\\\">Kubernetes Swagger Spec</a></li>\\n</ul>\\n<h2>License</h2>\\n<p><a href=\\\"LICENSE\\\">MIT</a></p>\",\"docPath\":\"argo-ci/node_modules/kubernetes-client/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-kubernetes-client.json\n// module id = 2815\n// module chunks = 77660504496275"],"sourceRoot":""}