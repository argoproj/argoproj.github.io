{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-logform-6936cfbfbdffcdc188c9.js","webpack:///./.cache/json/docs-argo-ci-node-modules-logform.json"],"names":["webpackJsonp","2855","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,00MAAkiMC,QAAA,sCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-logform-6936cfbfbdffcdc188c9.js","sourcesContent":["webpackJsonp([109220266579175],{\n\n/***/ 2855:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>logform</h1>\\n<p>An mutable object-based log format designed for chaining &#x26; objectMode streams.</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\n\\nconst alignedWithColorsAndTime = format.combine(\\n  format.colorize(),\\n  format.timestamp(),\\n  format.align(),\\n  format.printf(info => `${info.timestamp} ${info.level}: ${info.message}`)\\n);\\n</code></pre>\\n<ul>\\n<li><a href=\\\"#info-objects\\\"><code>info</code> Objects</a></li>\\n<li>\\n<p><a href=\\\"#understanding-formats\\\">Understanding formats</a></p>\\n<ul>\\n<li><a href=\\\"#combining-formats\\\">Combining formats</a></li>\\n<li><a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> objects</a></li>\\n</ul>\\n</li>\\n</ul>\\n<h2><code>info</code> Objects</h2>\\n<p>The <code>info</code> parameter provided to a given format represents a single log message. The object itself is mutable. Every <code>info</code> must have at least the <code>level</code> and <code>message</code> properties:</p>\\n<pre><code class=\\\"language-js\\\">{\\n  level: 'info',                 // Level of the logging message  \\n  message: 'Hey! Log something?' // Descriptive message being logged.\\n}\\n</code></pre>\\n<p><code>logform</code> itself exposes several additional properties:</p>\\n<ul>\\n<li><code>splat</code>: string interpolation splat for <code>%d %s</code>-style messages.</li>\\n<li><code>timestamp</code>: timestamp the message was received.</li>\\n<li><code>label</code>: custom label associated with each message.</li>\\n</ul>\\n<p>As a consumer you may add whatever properties you wish – <em>internal state is maintained by <code>Symbol</code> properties:</em></p>\\n<ul>\\n<li><code>Symbol.for('level')</code> <em><strong>(READ-ONLY)</strong>:</em> equal to <code>level</code> property. Is treated as immutable by all code.</li>\\n<li><code>Symbol.for('message'):</code> complete string message set by \\\"finalizing formats\\\": <code>json</code>, <code>logstash</code>, <code>printf</code>, <code>prettyPrint</code>, and <code>simple</code>. </li>\\n</ul>\\n<h2>Understanding formats</h2>\\n<p>Formats are prototypal objects (i.e. class instances) that define a single method: <code>transform(info, opts)</code> and return the mutated <code>info</code></p>\\n<ul>\\n<li><code>info</code>: an object representing the log message.</li>\\n<li><code>opts</code>: setting specific to the current instance of the format.</li>\\n</ul>\\n<p>They are expected to return one of two things:</p>\\n<ul>\\n<li><strong>An <code>info</code> Object</strong> representing the modified <code>info</code> argument. Object references need not be preserved if immutability is preferred. All current built-in formats consider <code>info</code> mutable, but [immutablejs] is being considered for future releases.</li>\\n<li><strong>A falsey value</strong> indicating that the <code>info</code> argument should be ignored by the caller. (See: <a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> Objects</a>) below.</li>\\n</ul>\\n<p><code>logform.format</code>  is designed to be as simple as possible. To define a new format simple pass it a <code>transform(info, opts)</code> function to get a new <code>Format</code>. </p>\\n<p>The named <code>Format</code> returned can be used to create as many copies of the given <code>Format</code> as desired:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\n\\nconst volume = format((info, opts) => {\\n  if (opts.yell) {\\n    info.message = info.message.toUpperCase(); \\n  } else if (opts.whisper) {\\n    info.message = info.message.toLowerCase();\\n  }\\n\\n  return info;\\n});\\n\\n// `volume` is now a function that returns instances of the format.\\nconst scream = volume({ yell: true });\\nconsole.dir(scream.transform({\\n  level: 'info',\\n  message: `sorry for making you YELL in your head!`\\n}, scream.options));\\n// {\\n//   level: 'info'\\n//   message: 'SORRY FOR MAKING YOU YELL IN YOUR HEAD!'\\n// }\\n\\n// `volume` can be used multiple times to create different formats.\\nconst whisper = volume({ whisper: true });\\nconsole.dir(whisper.transform({ \\n  level: 'info', \\n  message: `WHY ARE THEY MAKING US YELL SO MUCH!` \\n}), whisper.options);\\n// {\\n//   level: 'info'\\n//   message: 'why are they making us yell so much!'\\n// }\\n</code></pre>\\n<h3>Combining formats</h3>\\n<p>Any number of formats may be combined into a single format using <code>format.combine</code>. Since <code>format.combine</code> takes no <code>opts</code>, as a convenience it returns pre-created instance of the combined format.</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\nconst { combine, timestamp, label } = format;\\n\\nconst labelTimestamp = combine(\\n  label({ label: 'right meow!' }),\\n  timestamp()\\n);\\n\\nconst info = labelTimestamp.transform({\\n  level: 'info',\\n  message: 'What time is the testing at?'\\n});\\n\\nconsole.dir(info);\\n// { level: 'info',\\n//   message: 'What time is the testing at?',\\n//   label: 'right meow!',\\n//   timestamp: '2017-09-30T03:57:26.875Z' }\\n</code></pre>\\n<h3>Filtering <code>info</code> Objects</h3>\\n<p>If you wish to filter out a given <code>info</code> Object completely then simply return a falsey value.</p>\\n<pre><code class=\\\"language-js\\\">const ignorePrivate = format((info, opts) => {\\n  if (info.private) { return false; }\\n  return info;\\n});\\n\\nconsole.dir(ignorePrivate.transform({\\n  level: 'error',\\n  message: 'Public error to share'\\n}));\\n// { level: 'error', message: 'Public error to share' }\\n\\nconsole.dir(ignorePrivate.transform({\\n  level: 'error',\\n  private: true,\\n  message: 'This is super secret - hide it.'\\n}));\\n// false\\n</code></pre>\\n<p>Use of <code>format.combine</code> will respect any falsey values return and stop evaluation of later formats in the series. For example:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\nconst { combine, timestamp, label } = format;\\n\\nconst willNeverThrow = format.combine(\\n  format(info => { return false })(), // Ignores everything\\n  format(info => { throw new Error('Never reached') })()\\n);\\n\\nconsole.dir(willNeverThrow.transform({\\n  level: 'info',\\n  message: 'wow such testing'\\n}))\\n</code></pre>\\n<h2>Tests</h2>\\n<p>Tests are written with <code>mocha</code>, <code>assume</code>, and <code>nyc</code>. They can be run with <code>npm</code>:</p>\\n<pre><code>npm test\\n</code></pre>\\n<h5>LICENSE: MIT</h5>\\n<h5>AUTHOR: <a href=\\\"https://github.com/indexzero\\\">Charlie Robbins</a></h5>\",\"docPath\":\"argo-ci/node_modules/logform/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-logform-6936cfbfbdffcdc188c9.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>logform</h1>\\n<p>An mutable object-based log format designed for chaining &#x26; objectMode streams.</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\n\\nconst alignedWithColorsAndTime = format.combine(\\n  format.colorize(),\\n  format.timestamp(),\\n  format.align(),\\n  format.printf(info => `${info.timestamp} ${info.level}: ${info.message}`)\\n);\\n</code></pre>\\n<ul>\\n<li><a href=\\\"#info-objects\\\"><code>info</code> Objects</a></li>\\n<li>\\n<p><a href=\\\"#understanding-formats\\\">Understanding formats</a></p>\\n<ul>\\n<li><a href=\\\"#combining-formats\\\">Combining formats</a></li>\\n<li><a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> objects</a></li>\\n</ul>\\n</li>\\n</ul>\\n<h2><code>info</code> Objects</h2>\\n<p>The <code>info</code> parameter provided to a given format represents a single log message. The object itself is mutable. Every <code>info</code> must have at least the <code>level</code> and <code>message</code> properties:</p>\\n<pre><code class=\\\"language-js\\\">{\\n  level: 'info',                 // Level of the logging message  \\n  message: 'Hey! Log something?' // Descriptive message being logged.\\n}\\n</code></pre>\\n<p><code>logform</code> itself exposes several additional properties:</p>\\n<ul>\\n<li><code>splat</code>: string interpolation splat for <code>%d %s</code>-style messages.</li>\\n<li><code>timestamp</code>: timestamp the message was received.</li>\\n<li><code>label</code>: custom label associated with each message.</li>\\n</ul>\\n<p>As a consumer you may add whatever properties you wish – <em>internal state is maintained by <code>Symbol</code> properties:</em></p>\\n<ul>\\n<li><code>Symbol.for('level')</code> <em><strong>(READ-ONLY)</strong>:</em> equal to <code>level</code> property. Is treated as immutable by all code.</li>\\n<li><code>Symbol.for('message'):</code> complete string message set by \\\"finalizing formats\\\": <code>json</code>, <code>logstash</code>, <code>printf</code>, <code>prettyPrint</code>, and <code>simple</code>. </li>\\n</ul>\\n<h2>Understanding formats</h2>\\n<p>Formats are prototypal objects (i.e. class instances) that define a single method: <code>transform(info, opts)</code> and return the mutated <code>info</code></p>\\n<ul>\\n<li><code>info</code>: an object representing the log message.</li>\\n<li><code>opts</code>: setting specific to the current instance of the format.</li>\\n</ul>\\n<p>They are expected to return one of two things:</p>\\n<ul>\\n<li><strong>An <code>info</code> Object</strong> representing the modified <code>info</code> argument. Object references need not be preserved if immutability is preferred. All current built-in formats consider <code>info</code> mutable, but [immutablejs] is being considered for future releases.</li>\\n<li><strong>A falsey value</strong> indicating that the <code>info</code> argument should be ignored by the caller. (See: <a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> Objects</a>) below.</li>\\n</ul>\\n<p><code>logform.format</code>  is designed to be as simple as possible. To define a new format simple pass it a <code>transform(info, opts)</code> function to get a new <code>Format</code>. </p>\\n<p>The named <code>Format</code> returned can be used to create as many copies of the given <code>Format</code> as desired:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\n\\nconst volume = format((info, opts) => {\\n  if (opts.yell) {\\n    info.message = info.message.toUpperCase(); \\n  } else if (opts.whisper) {\\n    info.message = info.message.toLowerCase();\\n  }\\n\\n  return info;\\n});\\n\\n// `volume` is now a function that returns instances of the format.\\nconst scream = volume({ yell: true });\\nconsole.dir(scream.transform({\\n  level: 'info',\\n  message: `sorry for making you YELL in your head!`\\n}, scream.options));\\n// {\\n//   level: 'info'\\n//   message: 'SORRY FOR MAKING YOU YELL IN YOUR HEAD!'\\n// }\\n\\n// `volume` can be used multiple times to create different formats.\\nconst whisper = volume({ whisper: true });\\nconsole.dir(whisper.transform({ \\n  level: 'info', \\n  message: `WHY ARE THEY MAKING US YELL SO MUCH!` \\n}), whisper.options);\\n// {\\n//   level: 'info'\\n//   message: 'why are they making us yell so much!'\\n// }\\n</code></pre>\\n<h3>Combining formats</h3>\\n<p>Any number of formats may be combined into a single format using <code>format.combine</code>. Since <code>format.combine</code> takes no <code>opts</code>, as a convenience it returns pre-created instance of the combined format.</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\nconst { combine, timestamp, label } = format;\\n\\nconst labelTimestamp = combine(\\n  label({ label: 'right meow!' }),\\n  timestamp()\\n);\\n\\nconst info = labelTimestamp.transform({\\n  level: 'info',\\n  message: 'What time is the testing at?'\\n});\\n\\nconsole.dir(info);\\n// { level: 'info',\\n//   message: 'What time is the testing at?',\\n//   label: 'right meow!',\\n//   timestamp: '2017-09-30T03:57:26.875Z' }\\n</code></pre>\\n<h3>Filtering <code>info</code> Objects</h3>\\n<p>If you wish to filter out a given <code>info</code> Object completely then simply return a falsey value.</p>\\n<pre><code class=\\\"language-js\\\">const ignorePrivate = format((info, opts) => {\\n  if (info.private) { return false; }\\n  return info;\\n});\\n\\nconsole.dir(ignorePrivate.transform({\\n  level: 'error',\\n  message: 'Public error to share'\\n}));\\n// { level: 'error', message: 'Public error to share' }\\n\\nconsole.dir(ignorePrivate.transform({\\n  level: 'error',\\n  private: true,\\n  message: 'This is super secret - hide it.'\\n}));\\n// false\\n</code></pre>\\n<p>Use of <code>format.combine</code> will respect any falsey values return and stop evaluation of later formats in the series. For example:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('logform');\\nconst { combine, timestamp, label } = format;\\n\\nconst willNeverThrow = format.combine(\\n  format(info => { return false })(), // Ignores everything\\n  format(info => { throw new Error('Never reached') })()\\n);\\n\\nconsole.dir(willNeverThrow.transform({\\n  level: 'info',\\n  message: 'wow such testing'\\n}))\\n</code></pre>\\n<h2>Tests</h2>\\n<p>Tests are written with <code>mocha</code>, <code>assume</code>, and <code>nyc</code>. They can be run with <code>npm</code>:</p>\\n<pre><code>npm test\\n</code></pre>\\n<h5>LICENSE: MIT</h5>\\n<h5>AUTHOR: <a href=\\\"https://github.com/indexzero\\\">Charlie Robbins</a></h5>\",\"docPath\":\"argo-ci/node_modules/logform/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-logform.json\n// module id = 2855\n// module chunks = 109220266579175"],"sourceRoot":""}