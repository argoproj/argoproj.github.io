webpackJsonp([0xe3491c29fbb1],{2888:function(e,t){e.exports={pathContext:{docHtml:'<h1>minimatch</h1>\n<p>A minimal matching utility.</p>\n<p><a href="http://travis-ci.org/isaacs/minimatch"><img src="https://secure.travis-ci.org/isaacs/minimatch.svg" alt="Build Status"></a></p>\n<p>This is the matching library used internally by npm.</p>\n<p>It works by converting glob expressions into JavaScript <code>RegExp</code>\nobjects.</p>\n<h2>Usage</h2>\n<pre><code class="language-javascript">var minimatch = require("minimatch")\n\nminimatch("bar.foo", "*.foo") // true!\nminimatch("bar.foo", "*.bar") // false!\nminimatch("bar.foo", "*.+(bar|foo)", { debug: true }) // true, and noisy!\n</code></pre>\n<h2>Features</h2>\n<p>Supports these glob features:</p>\n<ul>\n<li>Brace Expansion</li>\n<li>Extended glob matching</li>\n<li>"Globstar" <code>**</code> matching</li>\n</ul>\n<p>See:</p>\n<ul>\n<li><code>man sh</code></li>\n<li><code>man bash</code></li>\n<li><code>man 3 fnmatch</code></li>\n<li><code>man 5 gitignore</code></li>\n</ul>\n<h2>Minimatch Class</h2>\n<p>Create a minimatch object by instantiating the <code>minimatch.Minimatch</code> class.</p>\n<pre><code class="language-javascript">var Minimatch = require("minimatch").Minimatch\nvar mm = new Minimatch(pattern, options)\n</code></pre>\n<h3>Properties</h3>\n<ul>\n<li>\n<p><code>pattern</code> The original pattern the minimatch object represents.</p>\n</li>\n<li>\n<p><code>options</code> The options supplied to the constructor.</p>\n</li>\n<li>\n<p><code>set</code> A 2-dimensional array of regexp or string expressions.\nEach row in the\narray corresponds to a brace-expanded pattern.  Each item in the row\ncorresponds to a single path-part.  For example, the pattern\n<code>{a,b/c}/d</code> would expand to a set of patterns like:</p>\n<pre><code>[ [ a, d ]\n, [ b, c, d ] ]\n</code></pre>\n<p>If a portion of the pattern doesn\'t have any "magic" in it\n(that is, it\'s something like <code>"foo"</code> rather than <code>fo*o?</code>), then it\nwill be left as a string rather than converted to a regular\nexpression.</p>\n</li>\n<li>\n<p><code>regexp</code> Created by the <code>makeRe</code> method.  A single regular expression\nexpressing the entire pattern.  This is useful in cases where you wish\nto use the pattern somewhat like <code>fnmatch(3)</code> with <code>FNM_PATH</code> enabled.</p>\n</li>\n<li>\n<p><code>negate</code> True if the pattern is negated.</p>\n</li>\n<li>\n<p><code>comment</code> True if the pattern is a comment.</p>\n</li>\n<li>\n<p><code>empty</code> True if the pattern is <code>""</code>.</p>\n</li>\n</ul>\n<h3>Methods</h3>\n<ul>\n<li><code>makeRe</code> Generate the <code>regexp</code> member if necessary, and return it.\nWill return <code>false</code> if the pattern is invalid.</li>\n<li><code>match(fname)</code> Return true if the filename matches the pattern, or\nfalse otherwise.</li>\n<li><code>matchOne(fileArray, patternArray, partial)</code> Take a <code>/</code>-split\nfilename, and match it against a single row in the <code>regExpSet</code>.  This\nmethod is mainly for internal use, but is exposed so that it can be\nused by a glob-walker that needs to avoid excessive filesystem calls.</li>\n</ul>\n<p>All other methods are internal, and will be called as necessary.</p>\n<h3>minimatch(path, pattern, options)</h3>\n<p>Main export.  Tests a path against the pattern using the options.</p>\n<pre><code class="language-javascript">var isJS = minimatch(file, "*.js", { matchBase: true })\n</code></pre>\n<h3>minimatch.filter(pattern, options)</h3>\n<p>Returns a function that tests its\nsupplied argument, suitable for use with <code>Array.filter</code>.  Example:</p>\n<pre><code class="language-javascript">var javascripts = fileList.filter(minimatch.filter("*.js", {matchBase: true}))\n</code></pre>\n<h3>minimatch.match(list, pattern, options)</h3>\n<p>Match against the list of\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\noptions.nonull is set, then return a list containing the pattern itself.</p>\n<pre><code class="language-javascript">var javascripts = minimatch.match(fileList, "*.js", {matchBase: true}))\n</code></pre>\n<h3>minimatch.makeRe(pattern, options)</h3>\n<p>Make a regular expression object from the pattern.</p>\n<h2>Options</h2>\n<p>All options are <code>false</code> by default.</p>\n<h3>debug</h3>\n<p>Dump a ton of stuff to stderr.</p>\n<h3>nobrace</h3>\n<p>Do not expand <code>{a,b}</code> and <code>{1..3}</code> brace sets.</p>\n<h3>noglobstar</h3>\n<p>Disable <code>**</code> matching against multiple folder names.</p>\n<h3>dot</h3>\n<p>Allow patterns to match filenames starting with a period, even if\nthe pattern does not explicitly have a period in that spot.</p>\n<p>Note that by default, <code>a/**/b</code> will <strong>not</strong> match <code>a/.d/b</code>, unless <code>dot</code>\nis set.</p>\n<h3>noext</h3>\n<p>Disable "extglob" style patterns like <code>+(a|b)</code>.</p>\n<h3>nocase</h3>\n<p>Perform a case-insensitive match.</p>\n<h3>nonull</h3>\n<p>When a match is not found by <code>minimatch.match</code>, return a list containing\nthe pattern itself if this option is set.  When not set, an empty list\nis returned if there are no matches.</p>\n<h3>matchBase</h3>\n<p>If set, then patterns without slashes will be matched\nagainst the basename of the path if it contains slashes.  For example,\n<code>a?b</code> would match the path <code>/xyz/123/acb</code>, but not <code>/xyz/acb/123</code>.</p>\n<h3>nocomment</h3>\n<p>Suppress the behavior of treating <code>#</code> at the start of a pattern as a\ncomment.</p>\n<h3>nonegate</h3>\n<p>Suppress the behavior of treating a leading <code>!</code> character as negation.</p>\n<h3>flipNegate</h3>\n<p>Returns from negate expressions the same as if they were not negated.\n(Ie, true on a hit, false on a miss.)</p>\n<h2>Comparisons to other fnmatch/glob implementations</h2>\n<p>While strict compliance with the existing standards is a worthwhile\ngoal, some discrepancies exist between minimatch and other\nimplementations, and are intentional.</p>\n<p>If the pattern starts with a <code>!</code> character, then it is negated.  Set the\n<code>nonegate</code> flag to suppress this behavior, and treat leading <code>!</code>\ncharacters normally.  This is perhaps relevant if you wish to start the\npattern with a negative extglob pattern like <code>!(a|B)</code>.  Multiple <code>!</code>\ncharacters at the start of a pattern will negate the pattern multiple\ntimes.</p>\n<p>If a pattern starts with <code>#</code>, then it is treated as a comment, and\nwill not match anything.  Use <code>\\#</code> to match a literal <code>#</code> at the\nstart of a line, or set the <code>nocomment</code> flag to suppress this behavior.</p>\n<p>The double-star character <code>**</code> is supported by default, unless the\n<code>noglobstar</code> flag is set.  This is supported in the manner of bsdglob\nand bash 4.1, where <code>**</code> only has special significance if it is the only\nthing in a path part.  That is, <code>a/**/b</code> will match <code>a/x/y/b</code>, but\n<code>a/**b</code> will not.</p>\n<p>If an escaped pattern has no matches, and the <code>nonull</code> flag is set,\nthen minimatch.match returns the pattern as-provided, rather than\ninterpreting the character escapes.  For example,\n<code>minimatch.match([], "\\\\*a\\\\?")</code> will return <code>"\\\\*a\\\\?"</code> rather than\n<code>"*a?"</code>.  This is akin to setting the <code>nullglob</code> option in bash, except\nthat it does not resolve escaped pattern characters.</p>\n<p>If brace expansion is not disabled, then it is performed before any\nother interpretation of the glob pattern.  Thus, a pattern like\n<code>+(a|{b),c)}</code>, which would not be valid in bash or zsh, is expanded\n<strong>first</strong> into the set of <code>+(a|b)</code> and <code>+(a|c)</code>, and those patterns are\nchecked for validity.  Since those two are valid, matching proceeds.</p>',docPath:"argo-ci/node_modules/minimatch/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-minimatch-86da378a58cb9e6a60c3.js.map