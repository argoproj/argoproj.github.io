webpackJsonp([3759642540701],{2686:function(e,o){e.exports={pathContext:{docHtml:"<h1>he <a href=\"https://travis-ci.org/mathiasbynens/he\"><img src=\"https://travis-ci.org/mathiasbynens/he.svg?branch=master\" alt=\"Build status\"></a> <a href=\"https://codecov.io/github/mathiasbynens/he?branch=master\"><img src=\"https://codecov.io/github/mathiasbynens/he/coverage.svg?branch=master\" alt=\"Code coverage status\"></a> <a href=\"https://gemnasium.com/mathiasbynens/he\"><img src=\"https://gemnasium.com/mathiasbynens/he.svg\" alt=\"Dependency status\"></a></h1>\n<p><em>he</em> (for “HTML entities”) is a robust HTML entity encoder/decoder written in JavaScript. It supports <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#named-character-references\">all standardized named character references as per HTML</a>, handles <a href=\"https://mathiasbynens.be/notes/ambiguous-ampersands\">ambiguous ampersands</a> and other edge cases <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#tokenizing-character-references\">just like a browser would</a>, has an extensive test suite, and — contrary to many other JavaScript solutions — <em>he</em> handles astral Unicode symbols just fine. <a href=\"https://mothereff.in/html-entities\">An online demo is available.</a></p>\n<h2>Installation</h2>\n<p>Via <a href=\"https://www.npmjs.com/\">npm</a>:</p>\n<pre><code class=\"language-bash\">npm install he\n</code></pre>\n<p>Via <a href=\"http://bower.io/\">Bower</a>:</p>\n<pre><code class=\"language-bash\">bower install he\n</code></pre>\n<p>Via <a href=\"https://github.com/component/component\">Component</a>:</p>\n<pre><code class=\"language-bash\">component install mathiasbynens/he\n</code></pre>\n<p>In a browser:</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"he.js\">&#x3C;/script>\n</code></pre>\n<p>In <a href=\"https://nodejs.org/\">Node.js</a>, <a href=\"https://iojs.org/\">io.js</a>, <a href=\"http://narwhaljs.org/\">Narwhal</a>, and <a href=\"http://ringojs.org/\">RingoJS</a>:</p>\n<pre><code class=\"language-js\">var he = require('he');\n</code></pre>\n<p>In <a href=\"http://www.mozilla.org/rhino/\">Rhino</a>:</p>\n<pre><code class=\"language-js\">load('he.js');\n</code></pre>\n<p>Using an AMD loader like <a href=\"http://requirejs.org/\">RequireJS</a>:</p>\n<pre><code class=\"language-js\">require(\n  {\n    'paths': {\n      'he': 'path/to/he'\n    }\n  },\n  ['he'],\n  function(he) {\n    console.log(he);\n  }\n);\n</code></pre>\n<h2>API</h2>\n<h3><code>he.version</code></h3>\n<p>A string representing the semantic version number.</p>\n<h3><code>he.encode(text, options)</code></h3>\n<p>This function takes a string of text and encodes (by default) any symbols that aren’t printable ASCII symbols and <code>&#x26;</code>, <code>&#x3C;</code>, <code>></code>, <code>\"</code>, <code>'</code>, and <code>`</code>, replacing them with character references.</p>\n<pre><code class=\"language-js\">he.encode('foo © bar ≠ baz 𝌆 qux');\n// → 'foo &#x26;#xA9; bar &#x26;#x2260; baz &#x26;#x1D306; qux'\n</code></pre>\n<p>As long as the input string contains <a href=\"https://html.spec.whatwg.org/multipage/parsing.html#preprocessing-the-input-stream\">allowed code points</a> only, the return value of this function is always valid HTML. Any <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\">(invalid) code points that cannot be represented using a character reference</a> in the input are not encoded:</p>\n<pre><code class=\"language-js\">he.encode('foo \\0 bar');\n// → 'foo \\0 bar'\n</code></pre>\n<p>However, enabling <a href=\"https://github.com/mathiasbynens/he#strict\">the <code>strict</code> option</a> causes invalid code points to throw an exception. With <code>strict</code> enabled, <code>he.encode</code> either throws (if the input contains invalid code points) or returns a string of valid HTML.</p>\n<p>The <code>options</code> object is optional. It recognizes the following properties:</p>\n<h4><code>useNamedReferences</code></h4>\n<p>The default value for the <code>useNamedReferences</code> option is <code>false</code>. This means that <code>encode()</code> will not use any named character references (e.g. <code>&#x26;copy;</code>) in the output — hexadecimal escapes (e.g. <code>&#x26;#xA9;</code>) will be used instead. Set it to <code>true</code> to enable the use of named references.</p>\n<p><strong>Note that if compatibility with older browsers is a concern, this option should remain disabled.</strong></p>\n<pre><code class=\"language-js\">// Using the global default setting (defaults to `false`):\nhe.encode('foo © bar ≠ baz 𝌆 qux');\n// → 'foo &#x26;#xA9; bar &#x26;#x2260; baz &#x26;#x1D306; qux'\n\n// Passing an `options` object to `encode`, to explicitly disallow named references:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'useNamedReferences': false\n});\n// → 'foo &#x26;#xA9; bar &#x26;#x2260; baz &#x26;#x1D306; qux'\n\n// Passing an `options` object to `encode`, to explicitly allow named references:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'useNamedReferences': true\n});\n// → 'foo &#x26;copy; bar &#x26;ne; baz &#x26;#x1D306; qux'\n</code></pre>\n<h4><code>decimal</code></h4>\n<p>The default value for the <code>decimal</code> option is <code>false</code>. If the option is enabled, <code>encode</code> will generally use decimal escapes (e.g. <code>&#x26;#169;</code>) rather than hexadecimal escapes (e.g. <code>&#x26;#xA9;</code>). Beside of this replacement, the basic behavior remains the same when combined with other options. For example: if both options <code>useNamedReferences</code> and <code>decimal</code> are enabled, named references (e.g. <code>&#x26;copy;</code>) are used over decimal escapes. HTML entities without a named reference are encoded using decimal escapes.</p>\n<pre><code class=\"language-js\">// Using the global default setting (defaults to `false`):\nhe.encode('foo © bar ≠ baz 𝌆 qux');\n// → 'foo &#x26;#xA9; bar &#x26;#x2260; baz &#x26;#x1D306; qux'\n\n// Passing an `options` object to `encode`, to explicitly disable decimal escapes:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'decimal': false\n});\n// → 'foo &#x26;#xA9; bar &#x26;#x2260; baz &#x26;#x1D306; qux'\n\n// Passing an `options` object to `encode`, to explicitly enable decimal escapes:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'decimal': true\n});\n// → 'foo &#x26;#169; bar &#x26;#8800; baz &#x26;#119558; qux'\n\n// Passing an `options` object to `encode`, to explicitly allow named references and decimal escapes:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'useNamedReferences': true,\n  'decimal': true\n});\n// → 'foo &#x26;copy; bar &#x26;ne; baz &#x26;#119558; qux'\n</code></pre>\n<h4><code>encodeEverything</code></h4>\n<p>The default value for the <code>encodeEverything</code> option is <code>false</code>. This means that <code>encode()</code> will not use any character references for printable ASCII symbols that don’t need escaping. Set it to <code>true</code> to encode every symbol in the input string. When set to <code>true</code>, this option takes precedence over <code>allowUnsafeSymbols</code> (i.e. setting the latter to <code>true</code> in such a case has no effect).</p>\n<pre><code class=\"language-js\">// Using the global default setting (defaults to `false`):\nhe.encode('foo © bar ≠ baz 𝌆 qux');\n// → 'foo &#x26;#xA9; bar &#x26;#x2260; baz &#x26;#x1D306; qux'\n\n// Passing an `options` object to `encode`, to explicitly encode all symbols:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'encodeEverything': true\n});\n// → '&#x26;#x66;&#x26;#x6F;&#x26;#x6F;&#x26;#x20;&#x26;#xA9;&#x26;#x20;&#x26;#x62;&#x26;#x61;&#x26;#x72;&#x26;#x20;&#x26;#x2260;&#x26;#x20;&#x26;#x62;&#x26;#x61;&#x26;#x7A;&#x26;#x20;&#x26;#x1D306;&#x26;#x20;&#x26;#x71;&#x26;#x75;&#x26;#x78;'\n\n// This setting can be combined with the `useNamedReferences` option:\nhe.encode('foo © bar ≠ baz 𝌆 qux', {\n  'encodeEverything': true,\n  'useNamedReferences': true\n});\n// → '&#x26;#x66;&#x26;#x6F;&#x26;#x6F;&#x26;#x20;&#x26;copy;&#x26;#x20;&#x26;#x62;&#x26;#x61;&#x26;#x72;&#x26;#x20;&#x26;ne;&#x26;#x20;&#x26;#x62;&#x26;#x61;&#x26;#x7A;&#x26;#x20;&#x26;#x1D306;&#x26;#x20;&#x26;#x71;&#x26;#x75;&#x26;#x78;'\n</code></pre>\n<h4><code>strict</code></h4>\n<p>The default value for the <code>strict</code> option is <code>false</code>. This means that <code>encode()</code> will encode any HTML text content you feed it, even if it contains any symbols that cause <a href=\"https://html.spec.whatwg.org/multipage/parsing.html#preprocessing-the-input-stream\">parse errors</a>. To throw an error when such invalid HTML is encountered, set the <code>strict</code> option to <code>true</code>. This option makes it possible to use <em>he</em> as part of HTML parsers and HTML validators.</p>\n<pre><code class=\"language-js\">// Using the global default setting (defaults to `false`, i.e. error-tolerant mode):\nhe.encode('\\x01');\n// → '&#x26;#x1;'\n\n// Passing an `options` object to `encode`, to explicitly enable error-tolerant mode:\nhe.encode('\\x01', {\n  'strict': false\n});\n// → '&#x26;#x1;'\n\n// Passing an `options` object to `encode`, to explicitly enable strict mode:\nhe.encode('\\x01', {\n  'strict': true\n});\n// → Parse error\n</code></pre>\n<h4><code>allowUnsafeSymbols</code></h4>\n<p>The default value for the <code>allowUnsafeSymbols</code> option is <code>false</code>. This means that characters that are unsafe for use in HTML content (<code>&#x26;</code>, <code>&#x3C;</code>, <code>></code>, <code>\"</code>, <code>'</code>, and <code>`</code>) will be encoded. When set to <code>true</code>, only non-ASCII characters will be encoded. If the <code>encodeEverything</code> option is set to <code>true</code>, this option will be ignored.</p>\n<pre><code class=\"language-js\">he.encode('foo © and &#x26; ampersand', {\n  'allowUnsafeSymbols': true\n});\n// → 'foo &#x26;#xA9; and &#x26; ampersand'\n</code></pre>\n<h4>Overriding default <code>encode</code> options globally</h4>\n<p>The global default setting can be overridden by modifying the <code>he.encode.options</code> object. This saves you from passing in an <code>options</code> object for every call to <code>encode</code> if you want to use the non-default setting.</p>\n<pre><code class=\"language-js\">// Read the global default setting:\nhe.encode.options.useNamedReferences;\n// → `false` by default\n\n// Override the global default setting:\nhe.encode.options.useNamedReferences = true;\n\n// Using the global default setting, which is now `true`:\nhe.encode('foo © bar ≠ baz 𝌆 qux');\n// → 'foo &#x26;copy; bar &#x26;ne; baz &#x26;#x1D306; qux'\n</code></pre>\n<h3><code>he.decode(html, options)</code></h3>\n<p>This function takes a string of HTML and decodes any named and numerical character references in it using <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#tokenizing-character-references\">the algorithm described in section 12.2.4.69 of the HTML spec</a>.</p>\n<pre><code class=\"language-js\">he.decode('foo &#x26;copy; bar &#x26;ne; baz &#x26;#x1D306; qux');\n// → 'foo © bar ≠ baz 𝌆 qux'\n</code></pre>\n<p>The <code>options</code> object is optional. It recognizes the following properties:</p>\n<h4><code>isAttributeValue</code></h4>\n<p>The default value for the <code>isAttributeValue</code> option is <code>false</code>. This means that <code>decode()</code> will decode the string as if it were used in <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#data-state\">a text context in an HTML document</a>. HTML has different rules for <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#character-reference-in-attribute-value-state\">parsing character references in attribute values</a> — set this option to <code>true</code> to treat the input string as if it were used as an attribute value.</p>\n<pre><code class=\"language-js\">// Using the global default setting (defaults to `false`, i.e. HTML text context):\nhe.decode('foo&#x26;ampbar');\n// → 'foo&#x26;bar'\n\n// Passing an `options` object to `decode`, to explicitly assume an HTML text context:\nhe.decode('foo&#x26;ampbar', {\n  'isAttributeValue': false\n});\n// → 'foo&#x26;bar'\n\n// Passing an `options` object to `decode`, to explicitly assume an HTML attribute value context:\nhe.decode('foo&#x26;ampbar', {\n  'isAttributeValue': true\n});\n// → 'foo&#x26;ampbar'\n</code></pre>\n<h4><code>strict</code></h4>\n<p>The default value for the <code>strict</code> option is <code>false</code>. This means that <code>decode()</code> will decode any HTML text content you feed it, even if it contains any entities that cause <a href=\"https://html.spec.whatwg.org/multipage/syntax.html#tokenizing-character-references\">parse errors</a>. To throw an error when such invalid HTML is encountered, set the <code>strict</code> option to <code>true</code>. This option makes it possible to use <em>he</em> as part of HTML parsers and HTML validators.</p>\n<pre><code class=\"language-js\">// Using the global default setting (defaults to `false`, i.e. error-tolerant mode):\nhe.decode('foo&#x26;ampbar');\n// → 'foo&#x26;bar'\n\n// Passing an `options` object to `decode`, to explicitly enable error-tolerant mode:\nhe.decode('foo&#x26;ampbar', {\n  'strict': false\n});\n// → 'foo&#x26;bar'\n\n// Passing an `options` object to `decode`, to explicitly enable strict mode:\nhe.decode('foo&#x26;ampbar', {\n  'strict': true\n});\n// → Parse error\n</code></pre>\n<h4>Overriding default <code>decode</code> options globally</h4>\n<p>The global default settings for the <code>decode</code> function can be overridden by modifying the <code>he.decode.options</code> object. This saves you from passing in an <code>options</code> object for every call to <code>decode</code> if you want to use a non-default setting.</p>\n<pre><code class=\"language-js\">// Read the global default setting:\nhe.decode.options.isAttributeValue;\n// → `false` by default\n\n// Override the global default setting:\nhe.decode.options.isAttributeValue = true;\n\n// Using the global default setting, which is now `true`:\nhe.decode('foo&#x26;ampbar');\n// → 'foo&#x26;ampbar'\n</code></pre>\n<h3><code>he.escape(text)</code></h3>\n<p>This function takes a string of text and escapes it for use in text contexts in XML or HTML documents. Only the following characters are escaped: <code>&#x26;</code>, <code>&#x3C;</code>, <code>></code>, <code>\"</code>, <code>'</code>, and <code>`</code>.</p>\n<pre><code class=\"language-js\">he.escape('&#x3C;img src=\\'x\\' onerror=\"prompt(1)\">');\n// → '&#x26;lt;img src=&#x26;#x27;x&#x26;#x27; onerror=&#x26;quot;prompt(1)&#x26;quot;&#x26;gt;'\n</code></pre>\n<h3><code>he.unescape(html, options)</code></h3>\n<p><code>he.unescape</code> is an alias for <code>he.decode</code>. It takes a string of HTML and decodes any named and numerical character references in it.</p>\n<h3>Using the <code>he</code> binary</h3>\n<p>To use the <code>he</code> binary in your shell, simply install <em>he</em> globally using npm:</p>\n<pre><code class=\"language-bash\">npm install -g he\n</code></pre>\n<p>After that you will be able to encode/decode HTML entities from the command line:</p>\n<pre><code class=\"language-bash\">$ he --encode 'föo ♥ bår 𝌆 baz'\nf&#x26;#xF6;o &#x26;#x2665; b&#x26;#xE5;r &#x26;#x1D306; baz\n\n$ he --encode --use-named-refs 'föo ♥ bår 𝌆 baz'\nf&#x26;ouml;o &#x26;hearts; b&#x26;aring;r &#x26;#x1D306; baz\n\n$ he --decode 'f&#x26;ouml;o &#x26;hearts; b&#x26;aring;r &#x26;#x1D306; baz'\nföo ♥ bår 𝌆 baz\n</code></pre>\n<p>Read a local text file, encode it for use in an HTML text context, and save the result to a new file:</p>\n<pre><code class=\"language-bash\">$ he --encode &#x3C; foo.txt > foo-escaped.html\n</code></pre>\n<p>Or do the same with an online text file:</p>\n<pre><code class=\"language-bash\">$ curl -sL \"http://git.io/HnfEaw\" | he --encode > escaped.html\n</code></pre>\n<p>Or, the opposite — read a local file containing a snippet of HTML in a text context, decode it back to plain text, and save the result to a new file:</p>\n<pre><code class=\"language-bash\">$ he --decode &#x3C; foo-escaped.html > foo.txt\n</code></pre>\n<p>Or do the same with an online HTML snippet:</p>\n<pre><code class=\"language-bash\">$ curl -sL \"http://git.io/HnfEaw\" | he --decode > decoded.txt\n</code></pre>\n<p>See <code>he --help</code> for the full list of options.</p>\n<h2>Support</h2>\n<p><em>he</em> has been tested in at least:</p>\n<ul>\n<li>Chrome 27-50</li>\n<li>Firefox 3-45</li>\n<li>Safari 4-9</li>\n<li>Opera 10-12, 15–37</li>\n<li>IE 6–11</li>\n<li>Edge</li>\n<li>Narwhal 0.3.2</li>\n<li>Node.js v0.10, v0.12, v4, v5</li>\n<li>PhantomJS 1.9.0</li>\n<li>Rhino 1.7RC4</li>\n<li>RingoJS 0.8-0.11</li>\n</ul>\n<h2>Unit tests &#x26; code coverage</h2>\n<p>After cloning this repository, run <code>npm install</code> to install the dependencies needed for he development and testing. You may want to install Istanbul <em>globally</em> using <code>npm install istanbul -g</code>.</p>\n<p>Once that’s done, you can run the unit tests in Node using <code>npm test</code> or <code>node tests/tests.js</code>. To run the tests in Rhino, Ringo, Narwhal, and web browsers as well, use <code>grunt test</code>.</p>\n<p>To generate the code coverage report, use <code>grunt cover</code>.</p>\n<h2>Acknowledgements</h2>\n<p>Thanks to <a href=\"https://simon.html5.org/\">Simon Pieters</a> (<a href=\"https://twitter.com/zcorpan\">@zcorpan</a>) for the many suggestions.</p>\n<h2>Author</h2>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://twitter.com/mathias\" title=\"Follow @mathias on Twitter\"><img src=\"https://gravatar.com/avatar/24e08a9ea84deb17ae121074d0f17125?s=70\" alt=\"twitter/mathias\"></a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://mathiasbynens.be/\">Mathias Bynens</a></td>\n</tr>\n</tbody>\n</table>\n<h2>License</h2>\n<p><em>he</em> is available under the <a href=\"https://mths.be/mit\">MIT</a> license.</p>",docPath:"argo-ci/node_modules/he/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-he-e40c45b018e9647d877d.js.map