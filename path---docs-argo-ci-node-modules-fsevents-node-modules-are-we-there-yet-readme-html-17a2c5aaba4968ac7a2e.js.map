{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-fsevents-node-modules-are-we-there-yet-readme-html-17a2c5aaba4968ac7a2e.js","webpack:///./.cache/json/docs-argo-ci-node-modules-fsevents-node-modules-are-we-there-yet-readme-html.json"],"names":["webpackJsonp","2371","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,ysPAA60CC,QAAA,qEAAAC,KAAA","file":"path---docs-argo-ci-node-modules-fsevents-node-modules-are-we-there-yet-readme-html-17a2c5aaba4968ac7a2e.js","sourcesContent":["webpackJsonp([147454265739153],{\n\n/***/ 2371:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h2>are-we-there-yet</h2>\\n<p>Track complex hiearchies of asynchronous task completion statuses.  This is\\nintended to give you a way of recording and reporting the progress of the big\\nrecursive fan-out and gather type workflows that are so common in async.</p>\\n<p>What you do with this completion data is up to you, but the most common use case is to\\nfeed it to one of the many progress bar modules.</p>\\n<p>Most progress bar modules include a rudamentary version of this, but my\\nneeds were more complex.</p>\\n<h1>Usage</h1>\\n<pre><code class=\\\"language-javascript\\\">var TrackerGroup = require(\\\"are-we-there-yet\\\").TrackerGroup\\n\\nvar top = new TrackerGroup(\\\"program\\\")\\n\\nvar single = top.newItem(\\\"one thing\\\", 100)\\nsingle.completeWork(20)\\n\\nconsole.log(top.completed()) // 0.2\\n\\nfs.stat(\\\"file\\\", function(er, stat) {\\n  if (er) throw er  \\n  var stream = top.newStream(\\\"file\\\", stat.size)\\n  console.log(top.completed()) // now 0.1 as single is 50% of the job and is 20% complete\\n                              // and 50% * 20% == 10%\\n  fs.createReadStream(\\\"file\\\").pipe(stream).on(\\\"data\\\", function (chunk) {\\n    // do stuff with chunk\\n  })\\n  top.on(\\\"change\\\", function (name) {\\n    // called each time a chunk is read from \\\"file\\\"\\n    // top.completed() will start at 0.1 and fill up to 0.6 as the file is read\\n  })\\n})\\n</code></pre>\\n<h1>Shared Methods</h1>\\n<ul>\\n<li>var completed = tracker.completed()</li>\\n</ul>\\n<p>Implemented in: <code>Tracker</code>, <code>TrackerGroup</code>, <code>TrackerStream</code></p>\\n<p>Returns the ratio of completed work to work to be done. Range of 0 to 1.</p>\\n<ul>\\n<li>tracker.finish()</li>\\n</ul>\\n<p>Implemented in: <code>Tracker</code>, <code>TrackerGroup</code></p>\\n<p>Marks the tracker as completed. With a TrackerGroup this marks all of its\\ncomponents as completed.</p>\\n<p>Marks all of the components of this tracker as finished, which in turn means\\nthat <code>tracker.completed()</code> for this will now be 1.</p>\\n<p>This will result in one or more <code>change</code> events being emitted.</p>\\n<h1>Events</h1>\\n<p>All tracker objects emit <code>change</code> events with the following arguments:</p>\\n<pre><code>function (name, completed, tracker)\\n</code></pre>\\n<p><code>name</code> is the name of the tracker that originally emitted the event,\\nor if it didn't have one, the first containing tracker group that had one.</p>\\n<p><code>completed</code> is the percent complete (as returned by <code>tracker.completed()</code> method).</p>\\n<p><code>tracker</code> is the tracker object that you are listening for events on.</p>\\n<h1>TrackerGroup</h1>\\n<ul>\\n<li>\\n<p>var tracker = new TrackerGroup(<strong>name</strong>)</p>\\n<ul>\\n<li><strong>name</strong> <em>(optional)</em> - The name of this tracker group, used in change\\nnotifications if the component updating didn't have a name. Defaults to undefined.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Creates a new empty tracker aggregation group. These are trackers whose\\ncompletion status is determined by the completion status of other trackers.</p>\\n<ul>\\n<li>\\n<p>tracker.addUnit(<strong>otherTracker</strong>, <strong>weight</strong>)</p>\\n<ul>\\n<li><strong>otherTracker</strong> - Any of the other are-we-there-yet tracker objects</li>\\n<li><strong>weight</strong> <em>(optional)</em> - The weight to give the tracker, defaults to 1.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Adds the <strong>otherTracker</strong> to this aggregation group. The weight determines\\nhow long you expect this tracker to take to complete in proportion to other\\nunits.  So for instance, if you add one tracker with a weight of 1 and\\nanother with a weight of 2, you're saying the second will take twice as long\\nto complete as the first.  As such, the first will account for 33% of the\\ncompletion of this tracker and the second will account for the other 67%.</p>\\n<p>Returns <strong>otherTracker</strong>.</p>\\n<ul>\\n<li>var subGroup = tracker.newGroup(<strong>name</strong>, <strong>weight</strong>)</li>\\n</ul>\\n<p>The above is exactly equivalent to:</p>\\n<pre><code class=\\\"language-javascript\\\">  var subGroup = tracker.addUnit(new TrackerGroup(name), weight)\\n</code></pre>\\n<ul>\\n<li>var subItem = tracker.newItem(<strong>name</strong>, <strong>todo</strong>, <strong>weight</strong>)</li>\\n</ul>\\n<p>The above is exactly equivalent to:</p>\\n<pre><code class=\\\"language-javascript\\\">  var subItem = tracker.addUnit(new Tracker(name, todo), weight)\\n</code></pre>\\n<ul>\\n<li>var subStream = tracker.newStream(<strong>name</strong>, <strong>todo</strong>, <strong>weight</strong>)</li>\\n</ul>\\n<p>The above is exactly equivalent to:</p>\\n<pre><code class=\\\"language-javascript\\\">  var subStream = tracker.addUnit(new TrackerStream(name, todo), weight)\\n</code></pre>\\n<ul>\\n<li>console.log( tracker.debug() )</li>\\n</ul>\\n<p>Returns a tree showing the completion of this tracker group and all of its\\nchildren, including recursively entering all of the children.</p>\\n<h1>Tracker</h1>\\n<ul>\\n<li>\\n<p>var tracker = new Tracker(<strong>name</strong>, <strong>todo</strong>)</p>\\n<ul>\\n<li><strong>name</strong> <em>(optional)</em> The name of this counter to report in change\\nevents.  Defaults to undefined.</li>\\n<li><strong>todo</strong> <em>(optional)</em> The amount of work todo (a number). Defaults to 0.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Ordinarily these are constructed as a part of a tracker group (via\\n<code>newItem</code>).</p>\\n<ul>\\n<li>var completed = tracker.completed()</li>\\n</ul>\\n<p>Returns the ratio of completed work to work to be done. Range of 0 to 1. If\\ntotal work to be done is 0 then it will return 0.</p>\\n<ul>\\n<li>\\n<p>tracker.addWork(<strong>todo</strong>)</p>\\n<ul>\\n<li><strong>todo</strong> A number to add to the amount of work to be done.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Increases the amount of work to be done, thus decreasing the completion\\npercentage.  Triggers a <code>change</code> event.</p>\\n<ul>\\n<li>\\n<p>tracker.completeWork(<strong>completed</strong>)</p>\\n<ul>\\n<li><strong>completed</strong> A number to add to the work complete</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Increase the amount of work complete, thus increasing the completion percentage.\\nWill never increase the work completed past the amount of work todo. That is,\\npercentages > 100% are not allowed. Triggers a <code>change</code> event.</p>\\n<ul>\\n<li>tracker.finish()</li>\\n</ul>\\n<p>Marks this tracker as finished, tracker.completed() will now be 1. Triggers\\na <code>change</code> event.</p>\\n<h1>TrackerStream</h1>\\n<ul>\\n<li>\\n<p>var tracker = new TrackerStream(<strong>name</strong>, <strong>size</strong>, <strong>options</strong>)</p>\\n<ul>\\n<li><strong>name</strong> <em>(optional)</em> The name of this counter to report in change\\nevents.  Defaults to undefined.</li>\\n<li><strong>size</strong> <em>(optional)</em> The number of bytes being sent through this stream.</li>\\n<li><strong>options</strong> <em>(optional)</em> A hash of stream options</li>\\n</ul>\\n</li>\\n</ul>\\n<p>The tracker stream object is a pass through stream that updates an internal\\ntracker object each time a block passes through.  It's intended to track\\ndownloads, file extraction and other related activities. You use it by piping\\nyour data source into it and then using it as your data source.</p>\\n<p>If your data has a length attribute then that's used as the amount of work\\ncompleted when the chunk is passed through.  If it does not (eg, object\\nstreams) then each chunk counts as completing 1 unit of work, so your size\\nshould be the total number of objects being streamed.</p>\\n<ul>\\n<li>\\n<p>tracker.addWork(<strong>todo</strong>)</p>\\n<ul>\\n<li><strong>todo</strong> Increase the expected overall size by <strong>todo</strong> bytes.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Increases the amount of work to be done, thus decreasing the completion\\npercentage.  Triggers a <code>change</code> event.</p>\",\"docPath\":\"argo-ci/node_modules/fsevents/node_modules/are-we-there-yet/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-fsevents-node-modules-are-we-there-yet-readme-html-17a2c5aaba4968ac7a2e.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h2>are-we-there-yet</h2>\\n<p>Track complex hiearchies of asynchronous task completion statuses.  This is\\nintended to give you a way of recording and reporting the progress of the big\\nrecursive fan-out and gather type workflows that are so common in async.</p>\\n<p>What you do with this completion data is up to you, but the most common use case is to\\nfeed it to one of the many progress bar modules.</p>\\n<p>Most progress bar modules include a rudamentary version of this, but my\\nneeds were more complex.</p>\\n<h1>Usage</h1>\\n<pre><code class=\\\"language-javascript\\\">var TrackerGroup = require(\\\"are-we-there-yet\\\").TrackerGroup\\n\\nvar top = new TrackerGroup(\\\"program\\\")\\n\\nvar single = top.newItem(\\\"one thing\\\", 100)\\nsingle.completeWork(20)\\n\\nconsole.log(top.completed()) // 0.2\\n\\nfs.stat(\\\"file\\\", function(er, stat) {\\n  if (er) throw er  \\n  var stream = top.newStream(\\\"file\\\", stat.size)\\n  console.log(top.completed()) // now 0.1 as single is 50% of the job and is 20% complete\\n                              // and 50% * 20% == 10%\\n  fs.createReadStream(\\\"file\\\").pipe(stream).on(\\\"data\\\", function (chunk) {\\n    // do stuff with chunk\\n  })\\n  top.on(\\\"change\\\", function (name) {\\n    // called each time a chunk is read from \\\"file\\\"\\n    // top.completed() will start at 0.1 and fill up to 0.6 as the file is read\\n  })\\n})\\n</code></pre>\\n<h1>Shared Methods</h1>\\n<ul>\\n<li>var completed = tracker.completed()</li>\\n</ul>\\n<p>Implemented in: <code>Tracker</code>, <code>TrackerGroup</code>, <code>TrackerStream</code></p>\\n<p>Returns the ratio of completed work to work to be done. Range of 0 to 1.</p>\\n<ul>\\n<li>tracker.finish()</li>\\n</ul>\\n<p>Implemented in: <code>Tracker</code>, <code>TrackerGroup</code></p>\\n<p>Marks the tracker as completed. With a TrackerGroup this marks all of its\\ncomponents as completed.</p>\\n<p>Marks all of the components of this tracker as finished, which in turn means\\nthat <code>tracker.completed()</code> for this will now be 1.</p>\\n<p>This will result in one or more <code>change</code> events being emitted.</p>\\n<h1>Events</h1>\\n<p>All tracker objects emit <code>change</code> events with the following arguments:</p>\\n<pre><code>function (name, completed, tracker)\\n</code></pre>\\n<p><code>name</code> is the name of the tracker that originally emitted the event,\\nor if it didn't have one, the first containing tracker group that had one.</p>\\n<p><code>completed</code> is the percent complete (as returned by <code>tracker.completed()</code> method).</p>\\n<p><code>tracker</code> is the tracker object that you are listening for events on.</p>\\n<h1>TrackerGroup</h1>\\n<ul>\\n<li>\\n<p>var tracker = new TrackerGroup(<strong>name</strong>)</p>\\n<ul>\\n<li><strong>name</strong> <em>(optional)</em> - The name of this tracker group, used in change\\nnotifications if the component updating didn't have a name. Defaults to undefined.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Creates a new empty tracker aggregation group. These are trackers whose\\ncompletion status is determined by the completion status of other trackers.</p>\\n<ul>\\n<li>\\n<p>tracker.addUnit(<strong>otherTracker</strong>, <strong>weight</strong>)</p>\\n<ul>\\n<li><strong>otherTracker</strong> - Any of the other are-we-there-yet tracker objects</li>\\n<li><strong>weight</strong> <em>(optional)</em> - The weight to give the tracker, defaults to 1.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Adds the <strong>otherTracker</strong> to this aggregation group. The weight determines\\nhow long you expect this tracker to take to complete in proportion to other\\nunits.  So for instance, if you add one tracker with a weight of 1 and\\nanother with a weight of 2, you're saying the second will take twice as long\\nto complete as the first.  As such, the first will account for 33% of the\\ncompletion of this tracker and the second will account for the other 67%.</p>\\n<p>Returns <strong>otherTracker</strong>.</p>\\n<ul>\\n<li>var subGroup = tracker.newGroup(<strong>name</strong>, <strong>weight</strong>)</li>\\n</ul>\\n<p>The above is exactly equivalent to:</p>\\n<pre><code class=\\\"language-javascript\\\">  var subGroup = tracker.addUnit(new TrackerGroup(name), weight)\\n</code></pre>\\n<ul>\\n<li>var subItem = tracker.newItem(<strong>name</strong>, <strong>todo</strong>, <strong>weight</strong>)</li>\\n</ul>\\n<p>The above is exactly equivalent to:</p>\\n<pre><code class=\\\"language-javascript\\\">  var subItem = tracker.addUnit(new Tracker(name, todo), weight)\\n</code></pre>\\n<ul>\\n<li>var subStream = tracker.newStream(<strong>name</strong>, <strong>todo</strong>, <strong>weight</strong>)</li>\\n</ul>\\n<p>The above is exactly equivalent to:</p>\\n<pre><code class=\\\"language-javascript\\\">  var subStream = tracker.addUnit(new TrackerStream(name, todo), weight)\\n</code></pre>\\n<ul>\\n<li>console.log( tracker.debug() )</li>\\n</ul>\\n<p>Returns a tree showing the completion of this tracker group and all of its\\nchildren, including recursively entering all of the children.</p>\\n<h1>Tracker</h1>\\n<ul>\\n<li>\\n<p>var tracker = new Tracker(<strong>name</strong>, <strong>todo</strong>)</p>\\n<ul>\\n<li><strong>name</strong> <em>(optional)</em> The name of this counter to report in change\\nevents.  Defaults to undefined.</li>\\n<li><strong>todo</strong> <em>(optional)</em> The amount of work todo (a number). Defaults to 0.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Ordinarily these are constructed as a part of a tracker group (via\\n<code>newItem</code>).</p>\\n<ul>\\n<li>var completed = tracker.completed()</li>\\n</ul>\\n<p>Returns the ratio of completed work to work to be done. Range of 0 to 1. If\\ntotal work to be done is 0 then it will return 0.</p>\\n<ul>\\n<li>\\n<p>tracker.addWork(<strong>todo</strong>)</p>\\n<ul>\\n<li><strong>todo</strong> A number to add to the amount of work to be done.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Increases the amount of work to be done, thus decreasing the completion\\npercentage.  Triggers a <code>change</code> event.</p>\\n<ul>\\n<li>\\n<p>tracker.completeWork(<strong>completed</strong>)</p>\\n<ul>\\n<li><strong>completed</strong> A number to add to the work complete</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Increase the amount of work complete, thus increasing the completion percentage.\\nWill never increase the work completed past the amount of work todo. That is,\\npercentages > 100% are not allowed. Triggers a <code>change</code> event.</p>\\n<ul>\\n<li>tracker.finish()</li>\\n</ul>\\n<p>Marks this tracker as finished, tracker.completed() will now be 1. Triggers\\na <code>change</code> event.</p>\\n<h1>TrackerStream</h1>\\n<ul>\\n<li>\\n<p>var tracker = new TrackerStream(<strong>name</strong>, <strong>size</strong>, <strong>options</strong>)</p>\\n<ul>\\n<li><strong>name</strong> <em>(optional)</em> The name of this counter to report in change\\nevents.  Defaults to undefined.</li>\\n<li><strong>size</strong> <em>(optional)</em> The number of bytes being sent through this stream.</li>\\n<li><strong>options</strong> <em>(optional)</em> A hash of stream options</li>\\n</ul>\\n</li>\\n</ul>\\n<p>The tracker stream object is a pass through stream that updates an internal\\ntracker object each time a block passes through.  It's intended to track\\ndownloads, file extraction and other related activities. You use it by piping\\nyour data source into it and then using it as your data source.</p>\\n<p>If your data has a length attribute then that's used as the amount of work\\ncompleted when the chunk is passed through.  If it does not (eg, object\\nstreams) then each chunk counts as completing 1 unit of work, so your size\\nshould be the total number of objects being streamed.</p>\\n<ul>\\n<li>\\n<p>tracker.addWork(<strong>todo</strong>)</p>\\n<ul>\\n<li><strong>todo</strong> Increase the expected overall size by <strong>todo</strong> bytes.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>Increases the amount of work to be done, thus decreasing the completion\\npercentage.  Triggers a <code>change</code> event.</p>\",\"docPath\":\"argo-ci/node_modules/fsevents/node_modules/are-we-there-yet/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-fsevents-node-modules-are-we-there-yet-readme-html.json\n// module id = 2371\n// module chunks = 147454265739153"],"sourceRoot":""}