{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-sshpk-readme-html-08d03b26db6664436cc1.js","webpack:///./.cache/json/docs-argo-ci-node-modules-sshpk-readme-html.json"],"names":["webpackJsonp","3184","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,0n0BAAmwTC,QAAA,oCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-sshpk-readme-html-08d03b26db6664436cc1.js","sourcesContent":["webpackJsonp([122746548196320],{\n\n/***/ 3184:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>sshpk</h1>\\n<p>Parse, convert, fingerprint and use SSH keys (both public and private) in pure\\nnode -- no <code>ssh-keygen</code> or other external dependencies.</p>\\n<p>Supports RSA, DSA, ECDSA (nistp-*) and ED25519 key types, in PEM (PKCS#1,\\nPKCS#8) and OpenSSH formats.</p>\\n<p>This library has been extracted from\\n<a href=\\\"https://github.com/joyent/node-http-signature\\\"><code>node-http-signature</code></a>\\n(work by <a href=\\\"https://github.com/mcavage\\\">Mark Cavage</a> and\\n<a href=\\\"https://github.com/bahamas10\\\">Dave Eddy</a>) and\\n<a href=\\\"https://github.com/bahamas10/node-ssh-fingerprint\\\"><code>node-ssh-fingerprint</code></a>\\n(work by Dave Eddy), with additions (including ECDSA support) by\\n<a href=\\\"https://github.com/arekinath\\\">Alex Wilson</a>.</p>\\n<h2>Install</h2>\\n<pre><code>npm install sshpk\\n</code></pre>\\n<h2>Examples</h2>\\n<pre><code class=\\\"language-js\\\">var sshpk = require('sshpk');\\n\\nvar fs = require('fs');\\n\\n/* Read in an OpenSSH-format public key */\\nvar keyPub = fs.readFileSync('id_rsa.pub');\\nvar key = sshpk.parseKey(keyPub, 'ssh');\\n\\n/* Get metadata about the key */\\nconsole.log('type => %s', key.type);\\nconsole.log('size => %d bits', key.size);\\nconsole.log('comment => %s', key.comment);\\n\\n/* Compute key fingerprints, in new OpenSSH (>6.7) format, and old MD5 */\\nconsole.log('fingerprint => %s', key.fingerprint().toString());\\nconsole.log('old-style fingerprint => %s', key.fingerprint('md5').toString());\\n</code></pre>\\n<p>Example output:</p>\\n<pre><code>type => rsa\\nsize => 2048 bits\\ncomment => foo@foo.com\\nfingerprint => SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w\\nold-style fingerprint => a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd\\n</code></pre>\\n<p>More examples: converting between formats:</p>\\n<pre><code class=\\\"language-js\\\">/* Read in a PEM public key */\\nvar keyPem = fs.readFileSync('id_rsa.pem');\\nvar key = sshpk.parseKey(keyPem, 'pem');\\n\\n/* Convert to PEM PKCS#8 public key format */\\nvar pemBuf = key.toBuffer('pkcs8');\\n\\n/* Convert to SSH public key format (and return as a string) */\\nvar sshKey = key.toString('ssh');\\n</code></pre>\\n<p>Signing and verifying:</p>\\n<pre><code class=\\\"language-js\\\">/* Read in an OpenSSH/PEM *private* key */\\nvar keyPriv = fs.readFileSync('id_ecdsa');\\nvar key = sshpk.parsePrivateKey(keyPriv, 'pem');\\n\\nvar data = 'some data';\\n\\n/* Sign some data with the key */\\nvar s = key.createSign('sha1');\\ns.update(data);\\nvar signature = s.sign();\\n\\n/* Now load the public key (could also use just key.toPublic()) */\\nvar keyPub = fs.readFileSync('id_ecdsa.pub');\\nkey = sshpk.parseKey(keyPub, 'ssh');\\n\\n/* Make a crypto.Verifier with this key */\\nvar v = key.createVerify('sha1');\\nv.update(data);\\nvar valid = v.verify(signature);\\n/* => true! */\\n</code></pre>\\n<p>Matching fingerprints with keys:</p>\\n<pre><code class=\\\"language-js\\\">var fp = sshpk.parseFingerprint('SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w');\\n\\nvar keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];\\n\\nkeys.forEach(function (key) {\\n    if (fp.matches(key))\\n        console.log('found it!');\\n});\\n</code></pre>\\n<h2>Usage</h2>\\n<h2>Public keys</h2>\\n<h3><code>parseKey(data[, format = 'auto'[, options]])</code></h3>\\n<p>Parses a key from a given data format and returns a new <code>Key</code> object.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>data</code> -- Either a Buffer or String, containing the key</li>\\n<li>\\n<p><code>format</code> -- String name of format to use, valid options are:</p>\\n<ul>\\n<li><code>auto</code>: choose automatically from all below</li>\\n<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>\\n<li><code>ssh</code>: standard OpenSSH format,</li>\\n<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>\\n<li><code>rfc4253</code>: raw OpenSSH wire format</li>\\n<li><code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by\\n<code>ssh-keygen -o</code></li>\\n</ul>\\n</li>\\n<li>\\n<p><code>options</code> -- Optional Object, extra options, with keys:</p>\\n<ul>\\n<li><code>filename</code> -- Optional String, name for the key being parsed\\n(eg. the filename that was opened). Used to generate\\nError messages</li>\\n<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an\\nencrypted PEM file</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>Key.isKey(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>Key</code> object created by a version\\nof <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>Key#type</code></h3>\\n<p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>\\n<h3><code>Key#size</code></h3>\\n<p>Integer, \\\"size\\\" of the key in bits. For RSA/DSA this is the size of the modulus;\\nfor ECDSA this is the bit size of the curve in use.</p>\\n<h3><code>Key#comment</code></h3>\\n<p>Optional string, a key comment used by some formats (eg the <code>ssh</code> format).</p>\\n<h3><code>Key#curve</code></h3>\\n<p>Only present if <code>this.type === 'ecdsa'</code>, string containing the name of the\\nnamed curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>\\nand <code>nistp521</code>.</p>\\n<h3><code>Key#toBuffer([format = 'ssh'])</code></h3>\\n<p>Convert the key into a given data format and return the serialized key as\\na Buffer.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- String name of format to use, for valid options see <code>parseKey()</code></li>\\n</ul>\\n<h3><code>Key#toString([format = 'ssh])</code></h3>\\n<p>Same as <code>this.toBuffer(format).toString()</code>.</p>\\n<h3><code>Key#fingerprint([algorithm = 'sha256'])</code></h3>\\n<p>Creates a new <code>Fingerprint</code> object representing this Key's fingerprint.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>algorithm</code> -- String name of hash algorithm to use, valid options are <code>md5</code>,\\n<code>sha1</code>, <code>sha256</code>, <code>sha384</code>, <code>sha512</code></li>\\n</ul>\\n<h3><code>Key#createVerify([hashAlgorithm])</code></h3>\\n<p>Creates a <code>crypto.Verifier</code> specialized to use this Key (and the correct public\\nkey algorithm to match it). The returned Verifier has the same API as a regular\\none, except that the <code>verify()</code> function takes only the target signature as an\\nargument.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any\\nsupported by OpenSSL are valid, usually including\\n<code>sha1</code>, <code>sha256</code>.</li>\\n</ul>\\n<p><code>v.verify(signature[, format])</code> Parameters</p>\\n<ul>\\n<li><code>signature</code> -- either a Signature object, or a Buffer or String</li>\\n<li><code>format</code> -- optional String, name of format to interpret given String with.\\nNot valid if <code>signature</code> is a Signature or Buffer.</li>\\n</ul>\\n<h3><code>Key#createDiffieHellman()</code></h3>\\n<h3><code>Key#createDH()</code></h3>\\n<p>Creates a Diffie-Hellman key exchange object initialized with this key and all\\nnecessary parameters. This has the same API as a <code>crypto.DiffieHellman</code>\\ninstance, except that functions take <code>Key</code> and <code>PrivateKey</code> objects as\\narguments, and return them where indicated for.</p>\\n<p>This is only valid for keys belonging to a cryptosystem that supports DHE\\nor a close analogue (i.e. <code>dsa</code>, <code>ecdsa</code> and <code>curve25519</code> keys). An attempt\\nto call this function on other keys will yield an <code>Error</code>.</p>\\n<h2>Private keys</h2>\\n<h3><code>parsePrivateKey(data[, format = 'auto'[, options]])</code></h3>\\n<p>Parses a private key from a given data format and returns a new\\n<code>PrivateKey</code> object.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>data</code> -- Either a Buffer or String, containing the key</li>\\n<li>\\n<p><code>format</code> -- String name of format to use, valid options are:</p>\\n<ul>\\n<li><code>auto</code>: choose automatically from all below</li>\\n<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>\\n<li><code>ssh</code>, <code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by\\n<code>ssh-keygen -o</code></li>\\n<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>\\n<li><code>rfc4253</code>: raw OpenSSH wire format</li>\\n</ul>\\n</li>\\n<li>\\n<p><code>options</code> -- Optional Object, extra options, with keys:</p>\\n<ul>\\n<li><code>filename</code> -- Optional String, name for the key being parsed\\n(eg. the filename that was opened). Used to generate\\nError messages</li>\\n<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an\\nencrypted PEM file</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>generatePrivateKey(type[, options])</code></h3>\\n<p>Generates a new private key of a certain key type, from random data.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>type</code> -- String, type of key to generate. Currently supported are <code>'ecdsa'</code>\\nand <code>'ed25519'</code></li>\\n<li>\\n<p><code>options</code> -- optional Object, with keys:</p>\\n<ul>\\n<li><code>curve</code> -- optional String, for <code>'ecdsa'</code> keys, specifies the curve to use.\\nIf ECDSA is specified and this option is not given, defaults to\\nusing <code>'nistp256'</code>.</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>PrivateKey.isPrivateKey(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>PrivateKey</code> object created by a\\nversion of <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>PrivateKey#type</code></h3>\\n<p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>\\n<h3><code>PrivateKey#size</code></h3>\\n<p>Integer, \\\"size\\\" of the key in bits. For RSA/DSA this is the size of the modulus;\\nfor ECDSA this is the bit size of the curve in use.</p>\\n<h3><code>PrivateKey#curve</code></h3>\\n<p>Only present if <code>this.type === 'ecdsa'</code>, string containing the name of the\\nnamed curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>\\nand <code>nistp521</code>.</p>\\n<h3><code>PrivateKey#toBuffer([format = 'pkcs1'])</code></h3>\\n<p>Convert the key into a given data format and return the serialized key as\\na Buffer.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- String name of format to use, valid options are listed under\\n<code>parsePrivateKey</code>. Note that ED25519 keys default to <code>openssh</code>\\nformat instead (as they have no <code>pkcs1</code> representation).</li>\\n</ul>\\n<h3><code>PrivateKey#toString([format = 'pkcs1'])</code></h3>\\n<p>Same as <code>this.toBuffer(format).toString()</code>.</p>\\n<h3><code>PrivateKey#toPublic()</code></h3>\\n<p>Extract just the public part of this private key, and return it as a <code>Key</code>\\nobject.</p>\\n<h3><code>PrivateKey#fingerprint([algorithm = 'sha256'])</code></h3>\\n<p>Same as <code>this.toPublic().fingerprint()</code>.</p>\\n<h3><code>PrivateKey#createVerify([hashAlgorithm])</code></h3>\\n<p>Same as <code>this.toPublic().createVerify()</code>.</p>\\n<h3><code>PrivateKey#createSign([hashAlgorithm])</code></h3>\\n<p>Creates a <code>crypto.Sign</code> specialized to use this PrivateKey (and the correct\\nkey algorithm to match it). The returned Signer has the same API as a regular\\none, except that the <code>sign()</code> function takes no arguments, and returns a\\n<code>Signature</code> object.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any\\nsupported by OpenSSL are valid, usually including\\n<code>sha1</code>, <code>sha256</code>.</li>\\n</ul>\\n<p><code>v.sign()</code> Parameters</p>\\n<ul>\\n<li>none</li>\\n</ul>\\n<h3><code>PrivateKey#derive(newType)</code></h3>\\n<p>Derives a related key of type <code>newType</code> from this key. Currently this is\\nonly supported to change between <code>ed25519</code> and <code>curve25519</code> keys which are\\nstored with the same private key (but usually distinct public keys in order\\nto avoid degenerate keys that lead to a weak Diffie-Hellman exchange).</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>newType</code> -- String, type of key to derive, either <code>ed25519</code> or <code>curve25519</code></li>\\n</ul>\\n<h2>Fingerprints</h2>\\n<h3><code>parseFingerprint(fingerprint[, algorithms])</code></h3>\\n<p>Pre-parses a fingerprint, creating a <code>Fingerprint</code> object that can be used to\\nquickly locate a key by using the <code>Fingerprint#matches</code> function.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>fingerprint</code> -- String, the fingerprint value, in any supported format</li>\\n<li><code>algorithms</code> -- Optional list of strings, names of hash algorithms to limit\\nsupport to. If <code>fingerprint</code> uses a hash algorithm not on\\nthis list, throws <code>InvalidAlgorithmError</code>.</li>\\n</ul>\\n<h3><code>Fingerprint.isFingerprint(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>Fingerprint</code> object created by a\\nversion of <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>Fingerprint#toString([format])</code></h3>\\n<p>Returns a fingerprint as a string, in the given format.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- Optional String, format to use, valid options are <code>hex</code> and\\n<code>base64</code>. If this <code>Fingerprint</code> uses the <code>md5</code> algorithm, the\\ndefault format is <code>hex</code>. Otherwise, the default is <code>base64</code>.</li>\\n</ul>\\n<h3><code>Fingerprint#matches(key)</code></h3>\\n<p>Verifies whether or not this <code>Fingerprint</code> matches a given <code>Key</code>. This function\\nuses double-hashing to avoid leaking timing information. Returns a boolean.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>key</code> -- a <code>Key</code> object, the key to match this fingerprint against</li>\\n</ul>\\n<h2>Signatures</h2>\\n<h3><code>parseSignature(signature, algorithm, format)</code></h3>\\n<p>Parses a signature in a given format, creating a <code>Signature</code> object. Useful\\nfor converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and\\nalso returned as output from <code>PrivateKey#createSign().sign()</code>.</p>\\n<p>A Signature object can also be passed to a verifier produced by\\n<code>Key#createVerify()</code> and it will automatically be converted internally into the\\ncorrect format for verification.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>signature</code> -- a Buffer (binary) or String (base64), data of the actual\\nsignature in the given format</li>\\n<li><code>algorithm</code> -- a String, name of the algorithm to be used, possible values\\nare <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code></li>\\n<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>\\n</ul>\\n<h3><code>Signature.isSignature(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>Signature</code> object created by a\\nversion of <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>Signature#toBuffer([format = 'asn1'])</code></h3>\\n<p>Converts a Signature to the given format and returns it as a Buffer.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>\\n</ul>\\n<h3><code>Signature#toString([format = 'asn1'])</code></h3>\\n<p>Same as <code>this.toBuffer(format).toString('base64')</code>.</p>\\n<h2>Certificates</h2>\\n<p><code>sshpk</code> includes basic support for parsing certificates in X.509 (PEM) format\\nand the OpenSSH certificate format. This feature is intended to be used mainly\\nto access basic metadata about certificates, extract public keys from them, and\\nalso to generate simple self-signed certificates from an existing key.</p>\\n<p>Notably, there is no implementation of CA chain-of-trust verification, and only\\nvery minimal support for key usage restrictions. Please do the security world\\na favour, and DO NOT use this code for certificate verification in the\\ntraditional X.509 CA chain style.</p>\\n<h3><code>parseCertificate(data, format)</code></h3>\\n<p>Parameters</p>\\n<ul>\\n<li><code>data</code> -- a Buffer or String</li>\\n<li><code>format</code> -- a String, format to use, one of <code>'openssh'</code>, <code>'pem'</code> (X.509 in a\\nPEM wrapper), or <code>'x509'</code> (raw DER encoded)</li>\\n</ul>\\n<h3><code>createSelfSignedCertificate(subject, privateKey[, options])</code></h3>\\n<p>Parameters</p>\\n<ul>\\n<li><code>subject</code> -- an Identity, the subject of the certificate</li>\\n<li><code>privateKey</code> -- a PrivateKey, the key of the subject: will be used both to be\\nplaced in the certificate and also to sign it (since this is\\na self-signed certificate)</li>\\n<li>\\n<p><code>options</code> -- optional Object, with keys:</p>\\n<ul>\\n<li><code>lifetime</code> -- optional Number, lifetime of the certificate from now in\\nseconds</li>\\n<li><code>validFrom</code>, <code>validUntil</code> -- optional Dates, beginning and end of\\ncertificate validity period. If given\\n<code>lifetime</code> will be ignored</li>\\n<li><code>serial</code> -- optional Buffer, the serial number of the certificate</li>\\n<li><code>purposes</code> -- optional Array of String, X.509 key usage restrictions</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>createCertificate(subject, key, issuer, issuerKey[, options])</code></h3>\\n<p>Parameters</p>\\n<ul>\\n<li><code>subject</code> -- an Identity, the subject of the certificate</li>\\n<li><code>key</code> -- a Key, the public key of the subject</li>\\n<li><code>issuer</code> -- an Identity, the issuer of the certificate who will sign it</li>\\n<li><code>issuerKey</code> -- a PrivateKey, the issuer's private key for signing</li>\\n<li>\\n<p><code>options</code> -- optional Object, with keys:</p>\\n<ul>\\n<li><code>lifetime</code> -- optional Number, lifetime of the certificate from now in\\nseconds</li>\\n<li><code>validFrom</code>, <code>validUntil</code> -- optional Dates, beginning and end of\\ncertificate validity period. If given\\n<code>lifetime</code> will be ignored</li>\\n<li><code>serial</code> -- optional Buffer, the serial number of the certificate</li>\\n<li><code>purposes</code> -- optional Array of String, X.509 key usage restrictions</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>Certificate#subjects</code></h3>\\n<p>Array of <code>Identity</code> instances describing the subject of this certificate.</p>\\n<h3><code>Certificate#issuer</code></h3>\\n<p>The <code>Identity</code> of the Certificate's issuer (signer).</p>\\n<h3><code>Certificate#subjectKey</code></h3>\\n<p>The public key of the subject of the certificate, as a <code>Key</code> instance.</p>\\n<h3><code>Certificate#issuerKey</code></h3>\\n<p>The public key of the signing issuer of this certificate, as a <code>Key</code> instance.\\nMay be <code>undefined</code> if the issuer's key is unknown (e.g. on an X509 certificate).</p>\\n<h3><code>Certificate#serial</code></h3>\\n<p>The serial number of the certificate. As this is normally a 64-bit or wider\\ninteger, it is returned as a Buffer.</p>\\n<h3><code>Certificate#purposes</code></h3>\\n<p>Array of Strings indicating the X.509 key usage purposes that this certificate\\nis valid for. The possible strings at the moment are:</p>\\n<ul>\\n<li><code>'signature'</code> -- key can be used for digital signatures</li>\\n<li><code>'identity'</code> -- key can be used to attest about the identity of the signer\\n(X.509 calls this <code>nonRepudiation</code>)</li>\\n<li><code>'codeSigning'</code> -- key can be used to sign executable code</li>\\n<li><code>'keyEncryption'</code> -- key can be used to encrypt other keys</li>\\n<li><code>'encryption'</code> -- key can be used to encrypt data (only applies for RSA)</li>\\n<li><code>'keyAgreement'</code> -- key can be used for key exchange protocols such as\\nDiffie-Hellman</li>\\n<li><code>'ca'</code> -- key can be used to sign other certificates (is a Certificate\\nAuthority)</li>\\n<li><code>'crl'</code> -- key can be used to sign Certificate Revocation Lists (CRLs)</li>\\n</ul>\\n<h3><code>Certificate#isExpired([when])</code></h3>\\n<p>Tests whether the Certificate is currently expired (i.e. the <code>validFrom</code> and\\n<code>validUntil</code> dates specify a range of time that does not include the current\\ntime).</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>when</code> -- optional Date, if specified, tests whether the Certificate was or\\nwill be expired at the specified time instead of now</li>\\n</ul>\\n<p>Returns a Boolean.</p>\\n<h3><code>Certificate#isSignedByKey(key)</code></h3>\\n<p>Tests whether the Certificate was validly signed by the given (public) Key.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>key</code> -- a Key instance</li>\\n</ul>\\n<p>Returns a Boolean.</p>\\n<h3><code>Certificate#isSignedBy(certificate)</code></h3>\\n<p>Tests whether this Certificate was validly signed by the subject of the given\\ncertificate. Also tests that the issuer Identity of this Certificate and the\\nsubject Identity of the other Certificate are equivalent.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>certificate</code> -- another Certificate instance</li>\\n</ul>\\n<p>Returns a Boolean.</p>\\n<h3><code>Certificate#fingerprint([hashAlgo])</code></h3>\\n<p>Returns the X509-style fingerprint of the entire certificate (as a Fingerprint\\ninstance). This matches what a web-browser or similar would display as the\\ncertificate fingerprint and should not be confused with the fingerprint of the\\nsubject's public key.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hashAlgo</code> -- an optional String, any hash function name</li>\\n</ul>\\n<h3><code>Certificate#toBuffer([format])</code></h3>\\n<p>Serializes the Certificate to a Buffer and returns it.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- an optional String, output format, one of <code>'openssh'</code>, <code>'pem'</code> or\\n<code>'x509'</code>. Defaults to <code>'x509'</code>.</li>\\n</ul>\\n<p>Returns a Buffer.</p>\\n<h3><code>Certificate#toString([format])</code></h3>\\n<ul>\\n<li><code>format</code> -- an optional String, output format, one of <code>'openssh'</code>, <code>'pem'</code> or\\n<code>'x509'</code>. Defaults to <code>'pem'</code>.</li>\\n</ul>\\n<p>Returns a String.</p>\\n<h2>Certificate identities</h2>\\n<h3><code>identityForHost(hostname)</code></h3>\\n<p>Constructs a host-type Identity for a given hostname.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hostname</code> -- the fully qualified DNS name of the host</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>identityForUser(uid)</code></h3>\\n<p>Constructs a user-type Identity for a given UID.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>uid</code> -- a String, user identifier (login name)</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>identityForEmail(email)</code></h3>\\n<p>Constructs an email-type Identity for a given email address.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>email</code> -- a String, email address</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>identityFromDN(dn)</code></h3>\\n<p>Parses an LDAP-style DN string (e.g. <code>'CN=foo, C=US'</code>) and turns it into an\\nIdentity instance.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>dn</code> -- a String</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>Identity#toString()</code></h3>\\n<p>Returns the identity as an LDAP-style DN string.\\ne.g. <code>'CN=foo, O=bar corp, C=us'</code></p>\\n<h3><code>Identity#type</code></h3>\\n<p>The type of identity. One of <code>'host'</code>, <code>'user'</code>, <code>'email'</code> or <code>'unknown'</code></p>\\n<h3><code>Identity#hostname</code></h3>\\n<h3><code>Identity#uid</code></h3>\\n<h3><code>Identity#email</code></h3>\\n<p>Set when <code>type</code> is <code>'host'</code>, <code>'user'</code>, or <code>'email'</code>, respectively. Strings.</p>\\n<h3><code>Identity#cn</code></h3>\\n<p>The value of the first <code>CN=</code> in the DN, if any.</p>\\n<h2>Errors</h2>\\n<h3><code>InvalidAlgorithmError</code></h3>\\n<p>The specified algorithm is not valid, either because it is not supported, or\\nbecause it was not included on a list of allowed algorithms.</p>\\n<p>Thrown by <code>Fingerprint.parse</code>, <code>Key#fingerprint</code>.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>algorithm</code> -- the algorithm that could not be validated</li>\\n</ul>\\n<h3><code>FingerprintFormatError</code></h3>\\n<p>The fingerprint string given could not be parsed as a supported fingerprint\\nformat, or the specified fingerprint format is invalid.</p>\\n<p>Thrown by <code>Fingerprint.parse</code>, <code>Fingerprint#toString</code>.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>fingerprint</code> -- if caused by a fingerprint, the string value given</li>\\n<li><code>format</code> -- if caused by an invalid format specification, the string value given</li>\\n</ul>\\n<h3><code>KeyParseError</code></h3>\\n<p>The key data given could not be parsed as a valid key.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>keyName</code> -- <code>filename</code> that was given to <code>parseKey</code></li>\\n<li><code>format</code> -- the <code>format</code> that was trying to parse the key (see <code>parseKey</code>)</li>\\n<li><code>innerErr</code> -- the inner Error thrown by the format parser</li>\\n</ul>\\n<h3><code>KeyEncryptedError</code></h3>\\n<p>The key is encrypted with a symmetric key (ie, it is password protected). The\\nparsing operation would succeed if it was given the <code>passphrase</code> option.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>keyName</code> -- <code>filename</code> that was given to <code>parseKey</code></li>\\n<li><code>format</code> -- the <code>format</code> that was trying to parse the key (currently can only\\nbe <code>\\\"pem\\\"</code>)</li>\\n</ul>\\n<h3><code>CertificateParseError</code></h3>\\n<p>The certificate data given could not be parsed as a valid certificate.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>certName</code> -- <code>filename</code> that was given to <code>parseCertificate</code></li>\\n<li><code>format</code> -- the <code>format</code> that was trying to parse the key\\n(see <code>parseCertificate</code>)</li>\\n<li><code>innerErr</code> -- the inner Error thrown by the format parser</li>\\n</ul>\\n<h2>Friends of sshpk</h2>\\n<ul>\\n<li><a href=\\\"https://github.com/arekinath/node-sshpk-agent\\\"><code>sshpk-agent</code></a> is a library\\nfor speaking the <code>ssh-agent</code> protocol from node.js, which uses <code>sshpk</code></li>\\n</ul>\",\"docPath\":\"argo-ci/node_modules/sshpk/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-sshpk-readme-html-08d03b26db6664436cc1.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>sshpk</h1>\\n<p>Parse, convert, fingerprint and use SSH keys (both public and private) in pure\\nnode -- no <code>ssh-keygen</code> or other external dependencies.</p>\\n<p>Supports RSA, DSA, ECDSA (nistp-*) and ED25519 key types, in PEM (PKCS#1,\\nPKCS#8) and OpenSSH formats.</p>\\n<p>This library has been extracted from\\n<a href=\\\"https://github.com/joyent/node-http-signature\\\"><code>node-http-signature</code></a>\\n(work by <a href=\\\"https://github.com/mcavage\\\">Mark Cavage</a> and\\n<a href=\\\"https://github.com/bahamas10\\\">Dave Eddy</a>) and\\n<a href=\\\"https://github.com/bahamas10/node-ssh-fingerprint\\\"><code>node-ssh-fingerprint</code></a>\\n(work by Dave Eddy), with additions (including ECDSA support) by\\n<a href=\\\"https://github.com/arekinath\\\">Alex Wilson</a>.</p>\\n<h2>Install</h2>\\n<pre><code>npm install sshpk\\n</code></pre>\\n<h2>Examples</h2>\\n<pre><code class=\\\"language-js\\\">var sshpk = require('sshpk');\\n\\nvar fs = require('fs');\\n\\n/* Read in an OpenSSH-format public key */\\nvar keyPub = fs.readFileSync('id_rsa.pub');\\nvar key = sshpk.parseKey(keyPub, 'ssh');\\n\\n/* Get metadata about the key */\\nconsole.log('type => %s', key.type);\\nconsole.log('size => %d bits', key.size);\\nconsole.log('comment => %s', key.comment);\\n\\n/* Compute key fingerprints, in new OpenSSH (>6.7) format, and old MD5 */\\nconsole.log('fingerprint => %s', key.fingerprint().toString());\\nconsole.log('old-style fingerprint => %s', key.fingerprint('md5').toString());\\n</code></pre>\\n<p>Example output:</p>\\n<pre><code>type => rsa\\nsize => 2048 bits\\ncomment => foo@foo.com\\nfingerprint => SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w\\nold-style fingerprint => a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd\\n</code></pre>\\n<p>More examples: converting between formats:</p>\\n<pre><code class=\\\"language-js\\\">/* Read in a PEM public key */\\nvar keyPem = fs.readFileSync('id_rsa.pem');\\nvar key = sshpk.parseKey(keyPem, 'pem');\\n\\n/* Convert to PEM PKCS#8 public key format */\\nvar pemBuf = key.toBuffer('pkcs8');\\n\\n/* Convert to SSH public key format (and return as a string) */\\nvar sshKey = key.toString('ssh');\\n</code></pre>\\n<p>Signing and verifying:</p>\\n<pre><code class=\\\"language-js\\\">/* Read in an OpenSSH/PEM *private* key */\\nvar keyPriv = fs.readFileSync('id_ecdsa');\\nvar key = sshpk.parsePrivateKey(keyPriv, 'pem');\\n\\nvar data = 'some data';\\n\\n/* Sign some data with the key */\\nvar s = key.createSign('sha1');\\ns.update(data);\\nvar signature = s.sign();\\n\\n/* Now load the public key (could also use just key.toPublic()) */\\nvar keyPub = fs.readFileSync('id_ecdsa.pub');\\nkey = sshpk.parseKey(keyPub, 'ssh');\\n\\n/* Make a crypto.Verifier with this key */\\nvar v = key.createVerify('sha1');\\nv.update(data);\\nvar valid = v.verify(signature);\\n/* => true! */\\n</code></pre>\\n<p>Matching fingerprints with keys:</p>\\n<pre><code class=\\\"language-js\\\">var fp = sshpk.parseFingerprint('SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w');\\n\\nvar keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];\\n\\nkeys.forEach(function (key) {\\n    if (fp.matches(key))\\n        console.log('found it!');\\n});\\n</code></pre>\\n<h2>Usage</h2>\\n<h2>Public keys</h2>\\n<h3><code>parseKey(data[, format = 'auto'[, options]])</code></h3>\\n<p>Parses a key from a given data format and returns a new <code>Key</code> object.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>data</code> -- Either a Buffer or String, containing the key</li>\\n<li>\\n<p><code>format</code> -- String name of format to use, valid options are:</p>\\n<ul>\\n<li><code>auto</code>: choose automatically from all below</li>\\n<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>\\n<li><code>ssh</code>: standard OpenSSH format,</li>\\n<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>\\n<li><code>rfc4253</code>: raw OpenSSH wire format</li>\\n<li><code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by\\n<code>ssh-keygen -o</code></li>\\n</ul>\\n</li>\\n<li>\\n<p><code>options</code> -- Optional Object, extra options, with keys:</p>\\n<ul>\\n<li><code>filename</code> -- Optional String, name for the key being parsed\\n(eg. the filename that was opened). Used to generate\\nError messages</li>\\n<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an\\nencrypted PEM file</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>Key.isKey(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>Key</code> object created by a version\\nof <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>Key#type</code></h3>\\n<p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>\\n<h3><code>Key#size</code></h3>\\n<p>Integer, \\\"size\\\" of the key in bits. For RSA/DSA this is the size of the modulus;\\nfor ECDSA this is the bit size of the curve in use.</p>\\n<h3><code>Key#comment</code></h3>\\n<p>Optional string, a key comment used by some formats (eg the <code>ssh</code> format).</p>\\n<h3><code>Key#curve</code></h3>\\n<p>Only present if <code>this.type === 'ecdsa'</code>, string containing the name of the\\nnamed curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>\\nand <code>nistp521</code>.</p>\\n<h3><code>Key#toBuffer([format = 'ssh'])</code></h3>\\n<p>Convert the key into a given data format and return the serialized key as\\na Buffer.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- String name of format to use, for valid options see <code>parseKey()</code></li>\\n</ul>\\n<h3><code>Key#toString([format = 'ssh])</code></h3>\\n<p>Same as <code>this.toBuffer(format).toString()</code>.</p>\\n<h3><code>Key#fingerprint([algorithm = 'sha256'])</code></h3>\\n<p>Creates a new <code>Fingerprint</code> object representing this Key's fingerprint.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>algorithm</code> -- String name of hash algorithm to use, valid options are <code>md5</code>,\\n<code>sha1</code>, <code>sha256</code>, <code>sha384</code>, <code>sha512</code></li>\\n</ul>\\n<h3><code>Key#createVerify([hashAlgorithm])</code></h3>\\n<p>Creates a <code>crypto.Verifier</code> specialized to use this Key (and the correct public\\nkey algorithm to match it). The returned Verifier has the same API as a regular\\none, except that the <code>verify()</code> function takes only the target signature as an\\nargument.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any\\nsupported by OpenSSL are valid, usually including\\n<code>sha1</code>, <code>sha256</code>.</li>\\n</ul>\\n<p><code>v.verify(signature[, format])</code> Parameters</p>\\n<ul>\\n<li><code>signature</code> -- either a Signature object, or a Buffer or String</li>\\n<li><code>format</code> -- optional String, name of format to interpret given String with.\\nNot valid if <code>signature</code> is a Signature or Buffer.</li>\\n</ul>\\n<h3><code>Key#createDiffieHellman()</code></h3>\\n<h3><code>Key#createDH()</code></h3>\\n<p>Creates a Diffie-Hellman key exchange object initialized with this key and all\\nnecessary parameters. This has the same API as a <code>crypto.DiffieHellman</code>\\ninstance, except that functions take <code>Key</code> and <code>PrivateKey</code> objects as\\narguments, and return them where indicated for.</p>\\n<p>This is only valid for keys belonging to a cryptosystem that supports DHE\\nor a close analogue (i.e. <code>dsa</code>, <code>ecdsa</code> and <code>curve25519</code> keys). An attempt\\nto call this function on other keys will yield an <code>Error</code>.</p>\\n<h2>Private keys</h2>\\n<h3><code>parsePrivateKey(data[, format = 'auto'[, options]])</code></h3>\\n<p>Parses a private key from a given data format and returns a new\\n<code>PrivateKey</code> object.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>data</code> -- Either a Buffer or String, containing the key</li>\\n<li>\\n<p><code>format</code> -- String name of format to use, valid options are:</p>\\n<ul>\\n<li><code>auto</code>: choose automatically from all below</li>\\n<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>\\n<li><code>ssh</code>, <code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by\\n<code>ssh-keygen -o</code></li>\\n<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>\\n<li><code>rfc4253</code>: raw OpenSSH wire format</li>\\n</ul>\\n</li>\\n<li>\\n<p><code>options</code> -- Optional Object, extra options, with keys:</p>\\n<ul>\\n<li><code>filename</code> -- Optional String, name for the key being parsed\\n(eg. the filename that was opened). Used to generate\\nError messages</li>\\n<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an\\nencrypted PEM file</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>generatePrivateKey(type[, options])</code></h3>\\n<p>Generates a new private key of a certain key type, from random data.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>type</code> -- String, type of key to generate. Currently supported are <code>'ecdsa'</code>\\nand <code>'ed25519'</code></li>\\n<li>\\n<p><code>options</code> -- optional Object, with keys:</p>\\n<ul>\\n<li><code>curve</code> -- optional String, for <code>'ecdsa'</code> keys, specifies the curve to use.\\nIf ECDSA is specified and this option is not given, defaults to\\nusing <code>'nistp256'</code>.</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>PrivateKey.isPrivateKey(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>PrivateKey</code> object created by a\\nversion of <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>PrivateKey#type</code></h3>\\n<p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>\\n<h3><code>PrivateKey#size</code></h3>\\n<p>Integer, \\\"size\\\" of the key in bits. For RSA/DSA this is the size of the modulus;\\nfor ECDSA this is the bit size of the curve in use.</p>\\n<h3><code>PrivateKey#curve</code></h3>\\n<p>Only present if <code>this.type === 'ecdsa'</code>, string containing the name of the\\nnamed curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>\\nand <code>nistp521</code>.</p>\\n<h3><code>PrivateKey#toBuffer([format = 'pkcs1'])</code></h3>\\n<p>Convert the key into a given data format and return the serialized key as\\na Buffer.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- String name of format to use, valid options are listed under\\n<code>parsePrivateKey</code>. Note that ED25519 keys default to <code>openssh</code>\\nformat instead (as they have no <code>pkcs1</code> representation).</li>\\n</ul>\\n<h3><code>PrivateKey#toString([format = 'pkcs1'])</code></h3>\\n<p>Same as <code>this.toBuffer(format).toString()</code>.</p>\\n<h3><code>PrivateKey#toPublic()</code></h3>\\n<p>Extract just the public part of this private key, and return it as a <code>Key</code>\\nobject.</p>\\n<h3><code>PrivateKey#fingerprint([algorithm = 'sha256'])</code></h3>\\n<p>Same as <code>this.toPublic().fingerprint()</code>.</p>\\n<h3><code>PrivateKey#createVerify([hashAlgorithm])</code></h3>\\n<p>Same as <code>this.toPublic().createVerify()</code>.</p>\\n<h3><code>PrivateKey#createSign([hashAlgorithm])</code></h3>\\n<p>Creates a <code>crypto.Sign</code> specialized to use this PrivateKey (and the correct\\nkey algorithm to match it). The returned Signer has the same API as a regular\\none, except that the <code>sign()</code> function takes no arguments, and returns a\\n<code>Signature</code> object.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any\\nsupported by OpenSSL are valid, usually including\\n<code>sha1</code>, <code>sha256</code>.</li>\\n</ul>\\n<p><code>v.sign()</code> Parameters</p>\\n<ul>\\n<li>none</li>\\n</ul>\\n<h3><code>PrivateKey#derive(newType)</code></h3>\\n<p>Derives a related key of type <code>newType</code> from this key. Currently this is\\nonly supported to change between <code>ed25519</code> and <code>curve25519</code> keys which are\\nstored with the same private key (but usually distinct public keys in order\\nto avoid degenerate keys that lead to a weak Diffie-Hellman exchange).</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>newType</code> -- String, type of key to derive, either <code>ed25519</code> or <code>curve25519</code></li>\\n</ul>\\n<h2>Fingerprints</h2>\\n<h3><code>parseFingerprint(fingerprint[, algorithms])</code></h3>\\n<p>Pre-parses a fingerprint, creating a <code>Fingerprint</code> object that can be used to\\nquickly locate a key by using the <code>Fingerprint#matches</code> function.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>fingerprint</code> -- String, the fingerprint value, in any supported format</li>\\n<li><code>algorithms</code> -- Optional list of strings, names of hash algorithms to limit\\nsupport to. If <code>fingerprint</code> uses a hash algorithm not on\\nthis list, throws <code>InvalidAlgorithmError</code>.</li>\\n</ul>\\n<h3><code>Fingerprint.isFingerprint(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>Fingerprint</code> object created by a\\nversion of <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>Fingerprint#toString([format])</code></h3>\\n<p>Returns a fingerprint as a string, in the given format.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- Optional String, format to use, valid options are <code>hex</code> and\\n<code>base64</code>. If this <code>Fingerprint</code> uses the <code>md5</code> algorithm, the\\ndefault format is <code>hex</code>. Otherwise, the default is <code>base64</code>.</li>\\n</ul>\\n<h3><code>Fingerprint#matches(key)</code></h3>\\n<p>Verifies whether or not this <code>Fingerprint</code> matches a given <code>Key</code>. This function\\nuses double-hashing to avoid leaking timing information. Returns a boolean.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>key</code> -- a <code>Key</code> object, the key to match this fingerprint against</li>\\n</ul>\\n<h2>Signatures</h2>\\n<h3><code>parseSignature(signature, algorithm, format)</code></h3>\\n<p>Parses a signature in a given format, creating a <code>Signature</code> object. Useful\\nfor converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and\\nalso returned as output from <code>PrivateKey#createSign().sign()</code>.</p>\\n<p>A Signature object can also be passed to a verifier produced by\\n<code>Key#createVerify()</code> and it will automatically be converted internally into the\\ncorrect format for verification.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>signature</code> -- a Buffer (binary) or String (base64), data of the actual\\nsignature in the given format</li>\\n<li><code>algorithm</code> -- a String, name of the algorithm to be used, possible values\\nare <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code></li>\\n<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>\\n</ul>\\n<h3><code>Signature.isSignature(obj)</code></h3>\\n<p>Returns <code>true</code> if the given object is a valid <code>Signature</code> object created by a\\nversion of <code>sshpk</code> compatible with this one.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>obj</code> -- Object to identify</li>\\n</ul>\\n<h3><code>Signature#toBuffer([format = 'asn1'])</code></h3>\\n<p>Converts a Signature to the given format and returns it as a Buffer.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>\\n</ul>\\n<h3><code>Signature#toString([format = 'asn1'])</code></h3>\\n<p>Same as <code>this.toBuffer(format).toString('base64')</code>.</p>\\n<h2>Certificates</h2>\\n<p><code>sshpk</code> includes basic support for parsing certificates in X.509 (PEM) format\\nand the OpenSSH certificate format. This feature is intended to be used mainly\\nto access basic metadata about certificates, extract public keys from them, and\\nalso to generate simple self-signed certificates from an existing key.</p>\\n<p>Notably, there is no implementation of CA chain-of-trust verification, and only\\nvery minimal support for key usage restrictions. Please do the security world\\na favour, and DO NOT use this code for certificate verification in the\\ntraditional X.509 CA chain style.</p>\\n<h3><code>parseCertificate(data, format)</code></h3>\\n<p>Parameters</p>\\n<ul>\\n<li><code>data</code> -- a Buffer or String</li>\\n<li><code>format</code> -- a String, format to use, one of <code>'openssh'</code>, <code>'pem'</code> (X.509 in a\\nPEM wrapper), or <code>'x509'</code> (raw DER encoded)</li>\\n</ul>\\n<h3><code>createSelfSignedCertificate(subject, privateKey[, options])</code></h3>\\n<p>Parameters</p>\\n<ul>\\n<li><code>subject</code> -- an Identity, the subject of the certificate</li>\\n<li><code>privateKey</code> -- a PrivateKey, the key of the subject: will be used both to be\\nplaced in the certificate and also to sign it (since this is\\na self-signed certificate)</li>\\n<li>\\n<p><code>options</code> -- optional Object, with keys:</p>\\n<ul>\\n<li><code>lifetime</code> -- optional Number, lifetime of the certificate from now in\\nseconds</li>\\n<li><code>validFrom</code>, <code>validUntil</code> -- optional Dates, beginning and end of\\ncertificate validity period. If given\\n<code>lifetime</code> will be ignored</li>\\n<li><code>serial</code> -- optional Buffer, the serial number of the certificate</li>\\n<li><code>purposes</code> -- optional Array of String, X.509 key usage restrictions</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>createCertificate(subject, key, issuer, issuerKey[, options])</code></h3>\\n<p>Parameters</p>\\n<ul>\\n<li><code>subject</code> -- an Identity, the subject of the certificate</li>\\n<li><code>key</code> -- a Key, the public key of the subject</li>\\n<li><code>issuer</code> -- an Identity, the issuer of the certificate who will sign it</li>\\n<li><code>issuerKey</code> -- a PrivateKey, the issuer's private key for signing</li>\\n<li>\\n<p><code>options</code> -- optional Object, with keys:</p>\\n<ul>\\n<li><code>lifetime</code> -- optional Number, lifetime of the certificate from now in\\nseconds</li>\\n<li><code>validFrom</code>, <code>validUntil</code> -- optional Dates, beginning and end of\\ncertificate validity period. If given\\n<code>lifetime</code> will be ignored</li>\\n<li><code>serial</code> -- optional Buffer, the serial number of the certificate</li>\\n<li><code>purposes</code> -- optional Array of String, X.509 key usage restrictions</li>\\n</ul>\\n</li>\\n</ul>\\n<h3><code>Certificate#subjects</code></h3>\\n<p>Array of <code>Identity</code> instances describing the subject of this certificate.</p>\\n<h3><code>Certificate#issuer</code></h3>\\n<p>The <code>Identity</code> of the Certificate's issuer (signer).</p>\\n<h3><code>Certificate#subjectKey</code></h3>\\n<p>The public key of the subject of the certificate, as a <code>Key</code> instance.</p>\\n<h3><code>Certificate#issuerKey</code></h3>\\n<p>The public key of the signing issuer of this certificate, as a <code>Key</code> instance.\\nMay be <code>undefined</code> if the issuer's key is unknown (e.g. on an X509 certificate).</p>\\n<h3><code>Certificate#serial</code></h3>\\n<p>The serial number of the certificate. As this is normally a 64-bit or wider\\ninteger, it is returned as a Buffer.</p>\\n<h3><code>Certificate#purposes</code></h3>\\n<p>Array of Strings indicating the X.509 key usage purposes that this certificate\\nis valid for. The possible strings at the moment are:</p>\\n<ul>\\n<li><code>'signature'</code> -- key can be used for digital signatures</li>\\n<li><code>'identity'</code> -- key can be used to attest about the identity of the signer\\n(X.509 calls this <code>nonRepudiation</code>)</li>\\n<li><code>'codeSigning'</code> -- key can be used to sign executable code</li>\\n<li><code>'keyEncryption'</code> -- key can be used to encrypt other keys</li>\\n<li><code>'encryption'</code> -- key can be used to encrypt data (only applies for RSA)</li>\\n<li><code>'keyAgreement'</code> -- key can be used for key exchange protocols such as\\nDiffie-Hellman</li>\\n<li><code>'ca'</code> -- key can be used to sign other certificates (is a Certificate\\nAuthority)</li>\\n<li><code>'crl'</code> -- key can be used to sign Certificate Revocation Lists (CRLs)</li>\\n</ul>\\n<h3><code>Certificate#isExpired([when])</code></h3>\\n<p>Tests whether the Certificate is currently expired (i.e. the <code>validFrom</code> and\\n<code>validUntil</code> dates specify a range of time that does not include the current\\ntime).</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>when</code> -- optional Date, if specified, tests whether the Certificate was or\\nwill be expired at the specified time instead of now</li>\\n</ul>\\n<p>Returns a Boolean.</p>\\n<h3><code>Certificate#isSignedByKey(key)</code></h3>\\n<p>Tests whether the Certificate was validly signed by the given (public) Key.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>key</code> -- a Key instance</li>\\n</ul>\\n<p>Returns a Boolean.</p>\\n<h3><code>Certificate#isSignedBy(certificate)</code></h3>\\n<p>Tests whether this Certificate was validly signed by the subject of the given\\ncertificate. Also tests that the issuer Identity of this Certificate and the\\nsubject Identity of the other Certificate are equivalent.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>certificate</code> -- another Certificate instance</li>\\n</ul>\\n<p>Returns a Boolean.</p>\\n<h3><code>Certificate#fingerprint([hashAlgo])</code></h3>\\n<p>Returns the X509-style fingerprint of the entire certificate (as a Fingerprint\\ninstance). This matches what a web-browser or similar would display as the\\ncertificate fingerprint and should not be confused with the fingerprint of the\\nsubject's public key.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hashAlgo</code> -- an optional String, any hash function name</li>\\n</ul>\\n<h3><code>Certificate#toBuffer([format])</code></h3>\\n<p>Serializes the Certificate to a Buffer and returns it.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>format</code> -- an optional String, output format, one of <code>'openssh'</code>, <code>'pem'</code> or\\n<code>'x509'</code>. Defaults to <code>'x509'</code>.</li>\\n</ul>\\n<p>Returns a Buffer.</p>\\n<h3><code>Certificate#toString([format])</code></h3>\\n<ul>\\n<li><code>format</code> -- an optional String, output format, one of <code>'openssh'</code>, <code>'pem'</code> or\\n<code>'x509'</code>. Defaults to <code>'pem'</code>.</li>\\n</ul>\\n<p>Returns a String.</p>\\n<h2>Certificate identities</h2>\\n<h3><code>identityForHost(hostname)</code></h3>\\n<p>Constructs a host-type Identity for a given hostname.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>hostname</code> -- the fully qualified DNS name of the host</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>identityForUser(uid)</code></h3>\\n<p>Constructs a user-type Identity for a given UID.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>uid</code> -- a String, user identifier (login name)</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>identityForEmail(email)</code></h3>\\n<p>Constructs an email-type Identity for a given email address.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>email</code> -- a String, email address</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>identityFromDN(dn)</code></h3>\\n<p>Parses an LDAP-style DN string (e.g. <code>'CN=foo, C=US'</code>) and turns it into an\\nIdentity instance.</p>\\n<p>Parameters</p>\\n<ul>\\n<li><code>dn</code> -- a String</li>\\n</ul>\\n<p>Returns an Identity instance.</p>\\n<h3><code>Identity#toString()</code></h3>\\n<p>Returns the identity as an LDAP-style DN string.\\ne.g. <code>'CN=foo, O=bar corp, C=us'</code></p>\\n<h3><code>Identity#type</code></h3>\\n<p>The type of identity. One of <code>'host'</code>, <code>'user'</code>, <code>'email'</code> or <code>'unknown'</code></p>\\n<h3><code>Identity#hostname</code></h3>\\n<h3><code>Identity#uid</code></h3>\\n<h3><code>Identity#email</code></h3>\\n<p>Set when <code>type</code> is <code>'host'</code>, <code>'user'</code>, or <code>'email'</code>, respectively. Strings.</p>\\n<h3><code>Identity#cn</code></h3>\\n<p>The value of the first <code>CN=</code> in the DN, if any.</p>\\n<h2>Errors</h2>\\n<h3><code>InvalidAlgorithmError</code></h3>\\n<p>The specified algorithm is not valid, either because it is not supported, or\\nbecause it was not included on a list of allowed algorithms.</p>\\n<p>Thrown by <code>Fingerprint.parse</code>, <code>Key#fingerprint</code>.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>algorithm</code> -- the algorithm that could not be validated</li>\\n</ul>\\n<h3><code>FingerprintFormatError</code></h3>\\n<p>The fingerprint string given could not be parsed as a supported fingerprint\\nformat, or the specified fingerprint format is invalid.</p>\\n<p>Thrown by <code>Fingerprint.parse</code>, <code>Fingerprint#toString</code>.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>fingerprint</code> -- if caused by a fingerprint, the string value given</li>\\n<li><code>format</code> -- if caused by an invalid format specification, the string value given</li>\\n</ul>\\n<h3><code>KeyParseError</code></h3>\\n<p>The key data given could not be parsed as a valid key.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>keyName</code> -- <code>filename</code> that was given to <code>parseKey</code></li>\\n<li><code>format</code> -- the <code>format</code> that was trying to parse the key (see <code>parseKey</code>)</li>\\n<li><code>innerErr</code> -- the inner Error thrown by the format parser</li>\\n</ul>\\n<h3><code>KeyEncryptedError</code></h3>\\n<p>The key is encrypted with a symmetric key (ie, it is password protected). The\\nparsing operation would succeed if it was given the <code>passphrase</code> option.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>keyName</code> -- <code>filename</code> that was given to <code>parseKey</code></li>\\n<li><code>format</code> -- the <code>format</code> that was trying to parse the key (currently can only\\nbe <code>\\\"pem\\\"</code>)</li>\\n</ul>\\n<h3><code>CertificateParseError</code></h3>\\n<p>The certificate data given could not be parsed as a valid certificate.</p>\\n<p>Properties</p>\\n<ul>\\n<li><code>certName</code> -- <code>filename</code> that was given to <code>parseCertificate</code></li>\\n<li><code>format</code> -- the <code>format</code> that was trying to parse the key\\n(see <code>parseCertificate</code>)</li>\\n<li><code>innerErr</code> -- the inner Error thrown by the format parser</li>\\n</ul>\\n<h2>Friends of sshpk</h2>\\n<ul>\\n<li><a href=\\\"https://github.com/arekinath/node-sshpk-agent\\\"><code>sshpk-agent</code></a> is a library\\nfor speaking the <code>ssh-agent</code> protocol from node.js, which uses <code>sshpk</code></li>\\n</ul>\",\"docPath\":\"argo-ci/node_modules/sshpk/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-sshpk-readme-html.json\n// module id = 3184\n// module chunks = 122746548196320"],"sourceRoot":""}