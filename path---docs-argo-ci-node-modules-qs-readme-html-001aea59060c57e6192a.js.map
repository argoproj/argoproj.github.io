{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-qs-readme-html-001aea59060c57e6192a.js","webpack:///./.cache/json/docs-argo-ci-node-modules-qs-readme-html.json"],"names":["webpackJsonp","3064","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,gojBAAynjBC,QAAA,iCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-qs-readme-html-001aea59060c57e6192a.js","sourcesContent":["webpackJsonp([8635076245985],{\n\n/***/ 3064:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>qs <sup><a href=\\\"https://npmjs.org/package/qs\\\"><img src=\\\"http://versionbadg.es/ljharb/qs.svg\\\" alt=\\\"Version Badge\\\"></a></sup></h1>\\n<p><a href=\\\"https://travis-ci.org/ljharb/qs\\\"><img src=\\\"https://api.travis-ci.org/ljharb/qs.svg\\\" alt=\\\"Build Status\\\"></a>\\n<a href=\\\"https://david-dm.org/ljharb/qs\\\"><img src=\\\"https://david-dm.org/ljharb/qs.svg\\\" alt=\\\"dependency status\\\"></a>\\n<a href=\\\"https://david-dm.org/ljharb/qs?type=dev\\\"><img src=\\\"https://david-dm.org/ljharb/qs/dev-status.svg\\\" alt=\\\"dev dependency status\\\"></a>\\n<a href=\\\"LICENSE\\\"><img src=\\\"http://img.shields.io/npm/l/qs.svg\\\" alt=\\\"License\\\"></a>\\n<a href=\\\"http://npm-stat.com/charts.html?package=qs\\\"><img src=\\\"http://img.shields.io/npm/dm/qs.svg\\\" alt=\\\"Downloads\\\"></a></p>\\n<p><a href=\\\"https://npmjs.org/package/qs\\\"><img src=\\\"https://nodei.co/npm/qs.png?downloads=true&#x26;stars=true\\\" alt=\\\"npm badge\\\"></a></p>\\n<p>A querystring parsing and stringifying library with some added security.</p>\\n<p>Lead Maintainer: <a href=\\\"https://github.com/ljharb\\\">Jordan Harband</a></p>\\n<p>The <strong>qs</strong> module was originally created and maintained by <a href=\\\"https://github.com/visionmedia/node-querystring\\\">TJ Holowaychuk</a>.</p>\\n<h2>Usage</h2>\\n<pre><code class=\\\"language-javascript\\\">var qs = require('qs');\\nvar assert = require('assert');\\n\\nvar obj = qs.parse('a=c');\\nassert.deepEqual(obj, { a: 'c' });\\n\\nvar str = qs.stringify(obj);\\nassert.equal(str, 'a=c');\\n</code></pre>\\n<h3>Parsing Objects</h3>\\n<p><a href=\\\"#preventEval\\\"></a></p>\\n<pre><code class=\\\"language-javascript\\\">qs.parse(string, [options]);\\n</code></pre>\\n<p><strong>qs</strong> allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets <code>[]</code>.\\nFor example, the string <code>'foo[bar]=baz'</code> converts to:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.deepEqual(qs.parse('foo[bar]=baz'), {\\n    foo: {\\n        bar: 'baz'\\n    }\\n});\\n</code></pre>\\n<p>When using the <code>plainObjects</code> option the parsed value is returned as a null object, created via <code>Object.create(null)</code> and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:</p>\\n<pre><code class=\\\"language-javascript\\\">var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });\\nassert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });\\n</code></pre>\\n<p>By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use <code>plainObjects</code> as mentioned above, or set <code>allowPrototypes</code> to <code>true</code> which will allow user input to overwrite those properties. <em>WARNING</em> It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.</p>\\n<pre><code class=\\\"language-javascript\\\">var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });\\nassert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });\\n</code></pre>\\n<p>URI encoded strings work too:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.deepEqual(qs.parse('a%5Bb%5D=c'), {\\n    a: { b: 'c' }\\n});\\n</code></pre>\\n<p>You can also nest your objects, like <code>'foo[bar][baz]=foobarbaz'</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {\\n    foo: {\\n        bar: {\\n            baz: 'foobarbaz'\\n        }\\n    }\\n});\\n</code></pre>\\n<p>By default, when nesting objects <strong>qs</strong> will only parse up to 5 children deep. This means if you attempt to parse a string like\\n<code>'a[b][c][d][e][f][g][h][i]=j'</code> your resulting object will be:</p>\\n<pre><code class=\\\"language-javascript\\\">var expected = {\\n    a: {\\n        b: {\\n            c: {\\n                d: {\\n                    e: {\\n                        f: {\\n                            '[g][h][i]': 'j'\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\nvar string = 'a[b][c][d][e][f][g][h][i]=j';\\nassert.deepEqual(qs.parse(string), expected);\\n</code></pre>\\n<p>This depth can be overridden by passing a <code>depth</code> option to <code>qs.parse(string, [options])</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });\\nassert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });\\n</code></pre>\\n<p>The depth limit helps mitigate abuse when <strong>qs</strong> is used to parse user input, and it is recommended to keep it a reasonably small number.</p>\\n<p>For similar reasons, by default <strong>qs</strong> will only parse up to 1000 parameters. This can be overridden by passing a <code>parameterLimit</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var limited = qs.parse('a=b&#x26;c=d', { parameterLimit: 1 });\\nassert.deepEqual(limited, { a: 'b' });\\n</code></pre>\\n<p>To bypass the leading question mark, use <code>ignoreQueryPrefix</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var prefixed = qs.parse('?a=b&#x26;c=d', { ignoreQueryPrefix: true });\\nassert.deepEqual(prefixed, { a: 'b', c: 'd' });\\n</code></pre>\\n<p>An optional delimiter can also be passed:</p>\\n<pre><code class=\\\"language-javascript\\\">var delimited = qs.parse('a=b;c=d', { delimiter: ';' });\\nassert.deepEqual(delimited, { a: 'b', c: 'd' });\\n</code></pre>\\n<p>Delimiters can be a regular expression too:</p>\\n<pre><code class=\\\"language-javascript\\\">var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });\\nassert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });\\n</code></pre>\\n<p>Option <code>allowDots</code> can be used to enable dot notation:</p>\\n<pre><code class=\\\"language-javascript\\\">var withDots = qs.parse('a.b=c', { allowDots: true });\\nassert.deepEqual(withDots, { a: { b: 'c' } });\\n</code></pre>\\n<h3>Parsing Arrays</h3>\\n<p><strong>qs</strong> can also parse arrays using a similar <code>[]</code> notation:</p>\\n<pre><code class=\\\"language-javascript\\\">var withArray = qs.parse('a[]=b&#x26;a[]=c');\\nassert.deepEqual(withArray, { a: ['b', 'c'] });\\n</code></pre>\\n<p>You may specify an index as well:</p>\\n<pre><code class=\\\"language-javascript\\\">var withIndexes = qs.parse('a[1]=c&#x26;a[0]=b');\\nassert.deepEqual(withIndexes, { a: ['b', 'c'] });\\n</code></pre>\\n<p>Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number\\nto create an array. When creating arrays with specific indices, <strong>qs</strong> will compact a sparse array to only the existing values preserving\\ntheir order:</p>\\n<pre><code class=\\\"language-javascript\\\">var noSparse = qs.parse('a[1]=b&#x26;a[15]=c');\\nassert.deepEqual(noSparse, { a: ['b', 'c'] });\\n</code></pre>\\n<p>Note that an empty string is also a value, and will be preserved:</p>\\n<pre><code class=\\\"language-javascript\\\">var withEmptyString = qs.parse('a[]=&#x26;a[]=b');\\nassert.deepEqual(withEmptyString, { a: ['', 'b'] });\\n\\nvar withIndexedEmptyString = qs.parse('a[0]=b&#x26;a[1]=&#x26;a[2]=c');\\nassert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });\\n</code></pre>\\n<p><strong>qs</strong> will also limit specifying indices in an array to a maximum index of <code>20</code>. Any array members with an index of greater than <code>20</code> will\\ninstead be converted to an object with the index as the key:</p>\\n<pre><code class=\\\"language-javascript\\\">var withMaxIndex = qs.parse('a[100]=b');\\nassert.deepEqual(withMaxIndex, { a: { '100': 'b' } });\\n</code></pre>\\n<p>This limit can be overridden by passing an <code>arrayLimit</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });\\nassert.deepEqual(withArrayLimit, { a: { '1': 'b' } });\\n</code></pre>\\n<p>To disable array parsing entirely, set <code>parseArrays</code> to <code>false</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });\\nassert.deepEqual(noParsingArrays, { a: { '0': 'b' } });\\n</code></pre>\\n<p>If you mix notations, <strong>qs</strong> will merge the two items into an object:</p>\\n<pre><code class=\\\"language-javascript\\\">var mixedNotation = qs.parse('a[0]=b&#x26;a[b]=c');\\nassert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });\\n</code></pre>\\n<p>You can also create arrays of objects:</p>\\n<pre><code class=\\\"language-javascript\\\">var arraysOfObjects = qs.parse('a[][b]=c');\\nassert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });\\n</code></pre>\\n<h3>Stringifying</h3>\\n<p><a href=\\\"#preventEval\\\"></a></p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify(object, [options]);\\n</code></pre>\\n<p>When stringifying, <strong>qs</strong> by default URI encodes output. Objects are stringified as you would expect:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: 'b' }), 'a=b');\\nassert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');\\n</code></pre>\\n<p>This encoding can be disabled by setting the <code>encode</code> option to <code>false</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });\\nassert.equal(unencoded, 'a[b]=c');\\n</code></pre>\\n<p>Encoding can be disabled for keys by setting the <code>encodeValuesOnly</code> option to <code>true</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var encodedValues = qs.stringify(\\n    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },\\n    { encodeValuesOnly: true }\\n);\\nassert.equal(encodedValues,'a=b&#x26;c[0]=d&#x26;c[1]=e%3Df&#x26;f[0][0]=g&#x26;f[1][0]=h');\\n</code></pre>\\n<p>This encoding can also be replaced by a custom encoding method set as <code>encoder</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {\\n    // Passed in values `a`, `b`, `c`\\n    return // Return encoded string\\n}})\\n</code></pre>\\n<p><em>(Note: the <code>encoder</code> option does not apply if <code>encode</code> is <code>false</code>)</em></p>\\n<p>Analogue to the <code>encoder</code> there is a <code>decoder</code> option for <code>parse</code> to override decoding of properties and values:</p>\\n<pre><code class=\\\"language-javascript\\\">var decoded = qs.parse('x=z', { decoder: function (str) {\\n    // Passed in values `x`, `z`\\n    return // Return decoded string\\n}})\\n</code></pre>\\n<p>Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases <em>will</em> be URI encoded during real usage.</p>\\n<p>When arrays are stringified, by default they are given explicit indices:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: ['b', 'c', 'd'] });\\n// 'a[0]=b&#x26;a[1]=c&#x26;a[2]=d'\\n</code></pre>\\n<p>You may override this by setting the <code>indices</code> option to <code>false</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });\\n// 'a=b&#x26;a=c&#x26;a=d'\\n</code></pre>\\n<p>You may use the <code>arrayFormat</code> option to specify the format of the output array:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })\\n// 'a[0]=b&#x26;a[1]=c'\\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })\\n// 'a[]=b&#x26;a[]=c'\\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })\\n// 'a=b&#x26;a=c'\\n</code></pre>\\n<p>When objects are stringified, by default they use bracket notation:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: { b: { c: 'd', e: 'f' } } });\\n// 'a[b][c]=d&#x26;a[b][e]=f'\\n</code></pre>\\n<p>You may override this to use dot notation by setting the <code>allowDots</code> option to <code>true</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });\\n// 'a.b.c=d&#x26;a.b.e=f'\\n</code></pre>\\n<p>Empty strings and null values will omit the value, but the equals sign (=) remains in place:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: '' }), 'a=');\\n</code></pre>\\n<p>Key with no values (such as an empty object or array) will return nothing:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: [] }), '');\\nassert.equal(qs.stringify({ a: {} }), '');\\nassert.equal(qs.stringify({ a: [{}] }), '');\\nassert.equal(qs.stringify({ a: { b: []} }), '');\\nassert.equal(qs.stringify({ a: { b: {}} }), '');\\n</code></pre>\\n<p>Properties that are set to <code>undefined</code> will be omitted entirely:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');\\n</code></pre>\\n<p>The query string may optionally be prepended with a question mark:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&#x26;c=d');\\n</code></pre>\\n<p>The delimiter may be overridden with stringify as well:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');\\n</code></pre>\\n<p>If you only want to override the serialization of <code>Date</code> objects, you can provide a <code>serializeDate</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var date = new Date(7);\\nassert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));\\nassert.equal(\\n    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),\\n    'a=7'\\n);\\n</code></pre>\\n<p>You may use the <code>sort</code> option to affect the order of parameter keys:</p>\\n<pre><code class=\\\"language-javascript\\\">function alphabeticalSort(a, b) {\\n    return a.localeCompare(b);\\n}\\nassert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&#x26;b=f&#x26;z=y');\\n</code></pre>\\n<p>Finally, you can use the <code>filter</code> option to restrict which keys will be included in the stringified output.\\nIf you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you\\npass an array, it will be used to select properties and array indices for stringification:</p>\\n<pre><code class=\\\"language-javascript\\\">function filterFunc(prefix, value) {\\n    if (prefix == 'b') {\\n        // Return an `undefined` value to omit a property.\\n        return;\\n    }\\n    if (prefix == 'e[f]') {\\n        return value.getTime();\\n    }\\n    if (prefix == 'e[g][0]') {\\n        return value * 2;\\n    }\\n    return value;\\n}\\nqs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });\\n// 'a=b&#x26;c=d&#x26;e[f]=123&#x26;e[g][0]=4'\\nqs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });\\n// 'a=b&#x26;e=f'\\nqs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });\\n// 'a[0]=b&#x26;a[2]=d'\\n</code></pre>\\n<h3>Handling of <code>null</code> values</h3>\\n<p>By default, <code>null</code> values are treated like empty strings:</p>\\n<pre><code class=\\\"language-javascript\\\">var withNull = qs.stringify({ a: null, b: '' });\\nassert.equal(withNull, 'a=&#x26;b=');\\n</code></pre>\\n<p>Parsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.</p>\\n<pre><code class=\\\"language-javascript\\\">var equalsInsensitive = qs.parse('a&#x26;b=');\\nassert.deepEqual(equalsInsensitive, { a: '', b: '' });\\n</code></pre>\\n<p>To distinguish between <code>null</code> values and empty strings use the <code>strictNullHandling</code> flag. In the result string the <code>null</code>\\nvalues have no <code>=</code> sign:</p>\\n<pre><code class=\\\"language-javascript\\\">var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });\\nassert.equal(strictNull, 'a&#x26;b=');\\n</code></pre>\\n<p>To parse values without <code>=</code> back to <code>null</code> use the <code>strictNullHandling</code> flag:</p>\\n<pre><code class=\\\"language-javascript\\\">var parsedStrictNull = qs.parse('a&#x26;b=', { strictNullHandling: true });\\nassert.deepEqual(parsedStrictNull, { a: null, b: '' });\\n</code></pre>\\n<p>To completely skip rendering keys with <code>null</code> values, use the <code>skipNulls</code> flag:</p>\\n<pre><code class=\\\"language-javascript\\\">var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });\\nassert.equal(nullsSkipped, 'a=b');\\n</code></pre>\\n<h3>Dealing with special character sets</h3>\\n<p>By default the encoding and decoding of characters is done in <code>utf-8</code>. If you\\nwish to encode querystrings to a different character set (i.e.\\n<a href=\\\"https://en.wikipedia.org/wiki/Shift_JIS\\\">Shift JIS</a>) you can use the\\n<a href=\\\"https://github.com/martinheidegger/qs-iconv\\\"><code>qs-iconv</code></a> library:</p>\\n<pre><code class=\\\"language-javascript\\\">var encoder = require('qs-iconv/encoder')('shift_jis');\\nvar shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });\\nassert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');\\n</code></pre>\\n<p>This also works for decoding of query strings:</p>\\n<pre><code class=\\\"language-javascript\\\">var decoder = require('qs-iconv/decoder')('shift_jis');\\nvar obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });\\nassert.deepEqual(obj, { a: 'こんにちは！' });\\n</code></pre>\\n<h3>RFC 3986 and RFC 1738 space encoding</h3>\\n<p>RFC3986 used as default option and encodes ' ' to <em>%20</em> which is backward compatible.\\nIn the same time, output can be stringified as per RFC1738 with ' ' equal to '+'.</p>\\n<pre><code>assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');\\nassert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');\\nassert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');\\n</code></pre>\",\"docPath\":\"argo-ci/node_modules/qs/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-qs-readme-html-001aea59060c57e6192a.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>qs <sup><a href=\\\"https://npmjs.org/package/qs\\\"><img src=\\\"http://versionbadg.es/ljharb/qs.svg\\\" alt=\\\"Version Badge\\\"></a></sup></h1>\\n<p><a href=\\\"https://travis-ci.org/ljharb/qs\\\"><img src=\\\"https://api.travis-ci.org/ljharb/qs.svg\\\" alt=\\\"Build Status\\\"></a>\\n<a href=\\\"https://david-dm.org/ljharb/qs\\\"><img src=\\\"https://david-dm.org/ljharb/qs.svg\\\" alt=\\\"dependency status\\\"></a>\\n<a href=\\\"https://david-dm.org/ljharb/qs?type=dev\\\"><img src=\\\"https://david-dm.org/ljharb/qs/dev-status.svg\\\" alt=\\\"dev dependency status\\\"></a>\\n<a href=\\\"LICENSE\\\"><img src=\\\"http://img.shields.io/npm/l/qs.svg\\\" alt=\\\"License\\\"></a>\\n<a href=\\\"http://npm-stat.com/charts.html?package=qs\\\"><img src=\\\"http://img.shields.io/npm/dm/qs.svg\\\" alt=\\\"Downloads\\\"></a></p>\\n<p><a href=\\\"https://npmjs.org/package/qs\\\"><img src=\\\"https://nodei.co/npm/qs.png?downloads=true&#x26;stars=true\\\" alt=\\\"npm badge\\\"></a></p>\\n<p>A querystring parsing and stringifying library with some added security.</p>\\n<p>Lead Maintainer: <a href=\\\"https://github.com/ljharb\\\">Jordan Harband</a></p>\\n<p>The <strong>qs</strong> module was originally created and maintained by <a href=\\\"https://github.com/visionmedia/node-querystring\\\">TJ Holowaychuk</a>.</p>\\n<h2>Usage</h2>\\n<pre><code class=\\\"language-javascript\\\">var qs = require('qs');\\nvar assert = require('assert');\\n\\nvar obj = qs.parse('a=c');\\nassert.deepEqual(obj, { a: 'c' });\\n\\nvar str = qs.stringify(obj);\\nassert.equal(str, 'a=c');\\n</code></pre>\\n<h3>Parsing Objects</h3>\\n<p><a href=\\\"#preventEval\\\"></a></p>\\n<pre><code class=\\\"language-javascript\\\">qs.parse(string, [options]);\\n</code></pre>\\n<p><strong>qs</strong> allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets <code>[]</code>.\\nFor example, the string <code>'foo[bar]=baz'</code> converts to:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.deepEqual(qs.parse('foo[bar]=baz'), {\\n    foo: {\\n        bar: 'baz'\\n    }\\n});\\n</code></pre>\\n<p>When using the <code>plainObjects</code> option the parsed value is returned as a null object, created via <code>Object.create(null)</code> and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:</p>\\n<pre><code class=\\\"language-javascript\\\">var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });\\nassert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });\\n</code></pre>\\n<p>By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use <code>plainObjects</code> as mentioned above, or set <code>allowPrototypes</code> to <code>true</code> which will allow user input to overwrite those properties. <em>WARNING</em> It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.</p>\\n<pre><code class=\\\"language-javascript\\\">var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });\\nassert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });\\n</code></pre>\\n<p>URI encoded strings work too:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.deepEqual(qs.parse('a%5Bb%5D=c'), {\\n    a: { b: 'c' }\\n});\\n</code></pre>\\n<p>You can also nest your objects, like <code>'foo[bar][baz]=foobarbaz'</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {\\n    foo: {\\n        bar: {\\n            baz: 'foobarbaz'\\n        }\\n    }\\n});\\n</code></pre>\\n<p>By default, when nesting objects <strong>qs</strong> will only parse up to 5 children deep. This means if you attempt to parse a string like\\n<code>'a[b][c][d][e][f][g][h][i]=j'</code> your resulting object will be:</p>\\n<pre><code class=\\\"language-javascript\\\">var expected = {\\n    a: {\\n        b: {\\n            c: {\\n                d: {\\n                    e: {\\n                        f: {\\n                            '[g][h][i]': 'j'\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\nvar string = 'a[b][c][d][e][f][g][h][i]=j';\\nassert.deepEqual(qs.parse(string), expected);\\n</code></pre>\\n<p>This depth can be overridden by passing a <code>depth</code> option to <code>qs.parse(string, [options])</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });\\nassert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });\\n</code></pre>\\n<p>The depth limit helps mitigate abuse when <strong>qs</strong> is used to parse user input, and it is recommended to keep it a reasonably small number.</p>\\n<p>For similar reasons, by default <strong>qs</strong> will only parse up to 1000 parameters. This can be overridden by passing a <code>parameterLimit</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var limited = qs.parse('a=b&#x26;c=d', { parameterLimit: 1 });\\nassert.deepEqual(limited, { a: 'b' });\\n</code></pre>\\n<p>To bypass the leading question mark, use <code>ignoreQueryPrefix</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var prefixed = qs.parse('?a=b&#x26;c=d', { ignoreQueryPrefix: true });\\nassert.deepEqual(prefixed, { a: 'b', c: 'd' });\\n</code></pre>\\n<p>An optional delimiter can also be passed:</p>\\n<pre><code class=\\\"language-javascript\\\">var delimited = qs.parse('a=b;c=d', { delimiter: ';' });\\nassert.deepEqual(delimited, { a: 'b', c: 'd' });\\n</code></pre>\\n<p>Delimiters can be a regular expression too:</p>\\n<pre><code class=\\\"language-javascript\\\">var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });\\nassert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });\\n</code></pre>\\n<p>Option <code>allowDots</code> can be used to enable dot notation:</p>\\n<pre><code class=\\\"language-javascript\\\">var withDots = qs.parse('a.b=c', { allowDots: true });\\nassert.deepEqual(withDots, { a: { b: 'c' } });\\n</code></pre>\\n<h3>Parsing Arrays</h3>\\n<p><strong>qs</strong> can also parse arrays using a similar <code>[]</code> notation:</p>\\n<pre><code class=\\\"language-javascript\\\">var withArray = qs.parse('a[]=b&#x26;a[]=c');\\nassert.deepEqual(withArray, { a: ['b', 'c'] });\\n</code></pre>\\n<p>You may specify an index as well:</p>\\n<pre><code class=\\\"language-javascript\\\">var withIndexes = qs.parse('a[1]=c&#x26;a[0]=b');\\nassert.deepEqual(withIndexes, { a: ['b', 'c'] });\\n</code></pre>\\n<p>Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number\\nto create an array. When creating arrays with specific indices, <strong>qs</strong> will compact a sparse array to only the existing values preserving\\ntheir order:</p>\\n<pre><code class=\\\"language-javascript\\\">var noSparse = qs.parse('a[1]=b&#x26;a[15]=c');\\nassert.deepEqual(noSparse, { a: ['b', 'c'] });\\n</code></pre>\\n<p>Note that an empty string is also a value, and will be preserved:</p>\\n<pre><code class=\\\"language-javascript\\\">var withEmptyString = qs.parse('a[]=&#x26;a[]=b');\\nassert.deepEqual(withEmptyString, { a: ['', 'b'] });\\n\\nvar withIndexedEmptyString = qs.parse('a[0]=b&#x26;a[1]=&#x26;a[2]=c');\\nassert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });\\n</code></pre>\\n<p><strong>qs</strong> will also limit specifying indices in an array to a maximum index of <code>20</code>. Any array members with an index of greater than <code>20</code> will\\ninstead be converted to an object with the index as the key:</p>\\n<pre><code class=\\\"language-javascript\\\">var withMaxIndex = qs.parse('a[100]=b');\\nassert.deepEqual(withMaxIndex, { a: { '100': 'b' } });\\n</code></pre>\\n<p>This limit can be overridden by passing an <code>arrayLimit</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });\\nassert.deepEqual(withArrayLimit, { a: { '1': 'b' } });\\n</code></pre>\\n<p>To disable array parsing entirely, set <code>parseArrays</code> to <code>false</code>.</p>\\n<pre><code class=\\\"language-javascript\\\">var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });\\nassert.deepEqual(noParsingArrays, { a: { '0': 'b' } });\\n</code></pre>\\n<p>If you mix notations, <strong>qs</strong> will merge the two items into an object:</p>\\n<pre><code class=\\\"language-javascript\\\">var mixedNotation = qs.parse('a[0]=b&#x26;a[b]=c');\\nassert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });\\n</code></pre>\\n<p>You can also create arrays of objects:</p>\\n<pre><code class=\\\"language-javascript\\\">var arraysOfObjects = qs.parse('a[][b]=c');\\nassert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });\\n</code></pre>\\n<h3>Stringifying</h3>\\n<p><a href=\\\"#preventEval\\\"></a></p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify(object, [options]);\\n</code></pre>\\n<p>When stringifying, <strong>qs</strong> by default URI encodes output. Objects are stringified as you would expect:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: 'b' }), 'a=b');\\nassert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');\\n</code></pre>\\n<p>This encoding can be disabled by setting the <code>encode</code> option to <code>false</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });\\nassert.equal(unencoded, 'a[b]=c');\\n</code></pre>\\n<p>Encoding can be disabled for keys by setting the <code>encodeValuesOnly</code> option to <code>true</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">var encodedValues = qs.stringify(\\n    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },\\n    { encodeValuesOnly: true }\\n);\\nassert.equal(encodedValues,'a=b&#x26;c[0]=d&#x26;c[1]=e%3Df&#x26;f[0][0]=g&#x26;f[1][0]=h');\\n</code></pre>\\n<p>This encoding can also be replaced by a custom encoding method set as <code>encoder</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {\\n    // Passed in values `a`, `b`, `c`\\n    return // Return encoded string\\n}})\\n</code></pre>\\n<p><em>(Note: the <code>encoder</code> option does not apply if <code>encode</code> is <code>false</code>)</em></p>\\n<p>Analogue to the <code>encoder</code> there is a <code>decoder</code> option for <code>parse</code> to override decoding of properties and values:</p>\\n<pre><code class=\\\"language-javascript\\\">var decoded = qs.parse('x=z', { decoder: function (str) {\\n    // Passed in values `x`, `z`\\n    return // Return decoded string\\n}})\\n</code></pre>\\n<p>Examples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases <em>will</em> be URI encoded during real usage.</p>\\n<p>When arrays are stringified, by default they are given explicit indices:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: ['b', 'c', 'd'] });\\n// 'a[0]=b&#x26;a[1]=c&#x26;a[2]=d'\\n</code></pre>\\n<p>You may override this by setting the <code>indices</code> option to <code>false</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });\\n// 'a=b&#x26;a=c&#x26;a=d'\\n</code></pre>\\n<p>You may use the <code>arrayFormat</code> option to specify the format of the output array:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })\\n// 'a[0]=b&#x26;a[1]=c'\\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })\\n// 'a[]=b&#x26;a[]=c'\\nqs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })\\n// 'a=b&#x26;a=c'\\n</code></pre>\\n<p>When objects are stringified, by default they use bracket notation:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: { b: { c: 'd', e: 'f' } } });\\n// 'a[b][c]=d&#x26;a[b][e]=f'\\n</code></pre>\\n<p>You may override this to use dot notation by setting the <code>allowDots</code> option to <code>true</code>:</p>\\n<pre><code class=\\\"language-javascript\\\">qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });\\n// 'a.b.c=d&#x26;a.b.e=f'\\n</code></pre>\\n<p>Empty strings and null values will omit the value, but the equals sign (=) remains in place:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: '' }), 'a=');\\n</code></pre>\\n<p>Key with no values (such as an empty object or array) will return nothing:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: [] }), '');\\nassert.equal(qs.stringify({ a: {} }), '');\\nassert.equal(qs.stringify({ a: [{}] }), '');\\nassert.equal(qs.stringify({ a: { b: []} }), '');\\nassert.equal(qs.stringify({ a: { b: {}} }), '');\\n</code></pre>\\n<p>Properties that are set to <code>undefined</code> will be omitted entirely:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');\\n</code></pre>\\n<p>The query string may optionally be prepended with a question mark:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&#x26;c=d');\\n</code></pre>\\n<p>The delimiter may be overridden with stringify as well:</p>\\n<pre><code class=\\\"language-javascript\\\">assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');\\n</code></pre>\\n<p>If you only want to override the serialization of <code>Date</code> objects, you can provide a <code>serializeDate</code> option:</p>\\n<pre><code class=\\\"language-javascript\\\">var date = new Date(7);\\nassert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));\\nassert.equal(\\n    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),\\n    'a=7'\\n);\\n</code></pre>\\n<p>You may use the <code>sort</code> option to affect the order of parameter keys:</p>\\n<pre><code class=\\\"language-javascript\\\">function alphabeticalSort(a, b) {\\n    return a.localeCompare(b);\\n}\\nassert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&#x26;b=f&#x26;z=y');\\n</code></pre>\\n<p>Finally, you can use the <code>filter</code> option to restrict which keys will be included in the stringified output.\\nIf you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you\\npass an array, it will be used to select properties and array indices for stringification:</p>\\n<pre><code class=\\\"language-javascript\\\">function filterFunc(prefix, value) {\\n    if (prefix == 'b') {\\n        // Return an `undefined` value to omit a property.\\n        return;\\n    }\\n    if (prefix == 'e[f]') {\\n        return value.getTime();\\n    }\\n    if (prefix == 'e[g][0]') {\\n        return value * 2;\\n    }\\n    return value;\\n}\\nqs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });\\n// 'a=b&#x26;c=d&#x26;e[f]=123&#x26;e[g][0]=4'\\nqs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });\\n// 'a=b&#x26;e=f'\\nqs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });\\n// 'a[0]=b&#x26;a[2]=d'\\n</code></pre>\\n<h3>Handling of <code>null</code> values</h3>\\n<p>By default, <code>null</code> values are treated like empty strings:</p>\\n<pre><code class=\\\"language-javascript\\\">var withNull = qs.stringify({ a: null, b: '' });\\nassert.equal(withNull, 'a=&#x26;b=');\\n</code></pre>\\n<p>Parsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.</p>\\n<pre><code class=\\\"language-javascript\\\">var equalsInsensitive = qs.parse('a&#x26;b=');\\nassert.deepEqual(equalsInsensitive, { a: '', b: '' });\\n</code></pre>\\n<p>To distinguish between <code>null</code> values and empty strings use the <code>strictNullHandling</code> flag. In the result string the <code>null</code>\\nvalues have no <code>=</code> sign:</p>\\n<pre><code class=\\\"language-javascript\\\">var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });\\nassert.equal(strictNull, 'a&#x26;b=');\\n</code></pre>\\n<p>To parse values without <code>=</code> back to <code>null</code> use the <code>strictNullHandling</code> flag:</p>\\n<pre><code class=\\\"language-javascript\\\">var parsedStrictNull = qs.parse('a&#x26;b=', { strictNullHandling: true });\\nassert.deepEqual(parsedStrictNull, { a: null, b: '' });\\n</code></pre>\\n<p>To completely skip rendering keys with <code>null</code> values, use the <code>skipNulls</code> flag:</p>\\n<pre><code class=\\\"language-javascript\\\">var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });\\nassert.equal(nullsSkipped, 'a=b');\\n</code></pre>\\n<h3>Dealing with special character sets</h3>\\n<p>By default the encoding and decoding of characters is done in <code>utf-8</code>. If you\\nwish to encode querystrings to a different character set (i.e.\\n<a href=\\\"https://en.wikipedia.org/wiki/Shift_JIS\\\">Shift JIS</a>) you can use the\\n<a href=\\\"https://github.com/martinheidegger/qs-iconv\\\"><code>qs-iconv</code></a> library:</p>\\n<pre><code class=\\\"language-javascript\\\">var encoder = require('qs-iconv/encoder')('shift_jis');\\nvar shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });\\nassert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');\\n</code></pre>\\n<p>This also works for decoding of query strings:</p>\\n<pre><code class=\\\"language-javascript\\\">var decoder = require('qs-iconv/decoder')('shift_jis');\\nvar obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });\\nassert.deepEqual(obj, { a: 'こんにちは！' });\\n</code></pre>\\n<h3>RFC 3986 and RFC 1738 space encoding</h3>\\n<p>RFC3986 used as default option and encodes ' ' to <em>%20</em> which is backward compatible.\\nIn the same time, output can be stringified as per RFC1738 with ' ' equal to '+'.</p>\\n<pre><code>assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');\\nassert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');\\nassert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');\\n</code></pre>\",\"docPath\":\"argo-ci/node_modules/qs/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-qs-readme-html.json\n// module id = 3064\n// module chunks = 8635076245985"],"sourceRoot":""}