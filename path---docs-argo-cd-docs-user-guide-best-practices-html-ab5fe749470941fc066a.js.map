{"version":3,"sources":["webpack:///path---docs-argo-cd-docs-user-guide-best-practices-html-ab5fe749470941fc066a.js","webpack:///./.cache/json/docs-argo-cd-docs-user-guide-best-practices-html.json"],"names":["webpackJsonp","577","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,8jHAAAC,QAAA,yCAAAC,KAAA","file":"path---docs-argo-cd-docs-user-guide-best-practices-html-ab5fe749470941fc066a.js","sourcesContent":["webpackJsonp([243374918559653],{\n\n/***/ 577:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>Best Practices</h1>\\n<h2>Separating Config Vs. Source Code Repositories</h2>\\n<p>Using a separate Git repository to hold your kubernetes manifests, keeping the config separate\\nfrom your application source code, is highly recommended for the following reasons:</p>\\n<ol>\\n<li>\\n<p>It provides a clean separation of application code vs. application config. There will be times\\nwhen you wish to modify just the manifests without triggering an entire CI build. For example,\\nyou likely do <em>not</em> want to trigger a build if you simply wish to bump the number of replicas in\\na Deployment spec.</p>\\n</li>\\n<li>\\n<p>Cleaner audit log. For auditing purposes, a repo which only holds configuration will have a much\\ncleaner Git history of what changes were made, without the noise coming from check-ins due to\\nnormal development activity.</p>\\n</li>\\n<li>\\n<p>Your application may be comprised of services built from multiple Git repositories, but is\\ndeployed as a single unit. Oftentimes, microservices applications are comprised of services\\nwith different versioning schemes, and release cycles (e.g. ELK, Kafka + Zookeeper). It may not\\nmake sense to store the manifests in one of the source code repositories of a single component.</p>\\n</li>\\n<li>\\n<p>Separation of access. The developers who are developing the application, may not necessarily be\\nthe same people who can/should push to production environments, either intentionally or\\nunintentionally. By having separate repos, commit access can be given to the source code repo,\\nand not the application config repo.</p>\\n</li>\\n<li>\\n<p>If you are automating your CI pipeline, pushing manifest changes to the same Cit repository can\\ntrigger an infinite loop of build jobs and Git commit triggers. Having a separate repo to push\\nconfig changes to, prevents this from happening.</p>\\n</li>\\n</ol>\\n<h2>Leaving Rroom For Imperativeness</h2>\\n<p>It may be desired to leave room for some imperativeness/automation, and not have everything defined\\nin your Git manifests. For example, if you want the number of your deployment's replicas to be\\nmanaged by <a href=\\\"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\\\">Horizontal Pod Autoscaler</a>,\\nthen you would not want to track <code>replicas</code> in Git.</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  # do not include replicas in the manifests if you want replicas to be controlled by HPA\\n  # replicas: 1\\n  template:\\n    spec:\\n      containers:\\n      - image: nginx:1.7.9\\n        name: nginx\\n        ports:\\n        - containerPort: 80\\n...\\n</code></pre>\\n<h2>Ensuring Manifests At Git Revisions Are Truly Immutable</h2>\\n<p>When using templating tools like <code>helm</code> or <code>kustomize</code>, it is possible for manifests to change\\ntheir meaning from one day to the next. This is typically caused by changes made to an upstream helm\\nrepository or kustomize base.</p>\\n<p>For example, consider the following kustomization.yaml</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install\\n</code></pre>\\n<p>The above kustomization has a remote base to he HEAD revision of the argo-cd repo. Since this\\nis not stable target, the manifests for this kustomize application can suddenly change meaning, even without\\nany changes to your own Git repository.</p>\\n<p>A better version would be to use a Git tag or commit SHA. For example:</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v0.11.1\\n</code></pre>\",\"docPath\":\"argo-cd/docs/user-guide/best_practices\",\"proj\":\"argo-cd\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-cd-docs-user-guide-best-practices-html-ab5fe749470941fc066a.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>Best Practices</h1>\\n<h2>Separating Config Vs. Source Code Repositories</h2>\\n<p>Using a separate Git repository to hold your kubernetes manifests, keeping the config separate\\nfrom your application source code, is highly recommended for the following reasons:</p>\\n<ol>\\n<li>\\n<p>It provides a clean separation of application code vs. application config. There will be times\\nwhen you wish to modify just the manifests without triggering an entire CI build. For example,\\nyou likely do <em>not</em> want to trigger a build if you simply wish to bump the number of replicas in\\na Deployment spec.</p>\\n</li>\\n<li>\\n<p>Cleaner audit log. For auditing purposes, a repo which only holds configuration will have a much\\ncleaner Git history of what changes were made, without the noise coming from check-ins due to\\nnormal development activity.</p>\\n</li>\\n<li>\\n<p>Your application may be comprised of services built from multiple Git repositories, but is\\ndeployed as a single unit. Oftentimes, microservices applications are comprised of services\\nwith different versioning schemes, and release cycles (e.g. ELK, Kafka + Zookeeper). It may not\\nmake sense to store the manifests in one of the source code repositories of a single component.</p>\\n</li>\\n<li>\\n<p>Separation of access. The developers who are developing the application, may not necessarily be\\nthe same people who can/should push to production environments, either intentionally or\\nunintentionally. By having separate repos, commit access can be given to the source code repo,\\nand not the application config repo.</p>\\n</li>\\n<li>\\n<p>If you are automating your CI pipeline, pushing manifest changes to the same Cit repository can\\ntrigger an infinite loop of build jobs and Git commit triggers. Having a separate repo to push\\nconfig changes to, prevents this from happening.</p>\\n</li>\\n</ol>\\n<h2>Leaving Rroom For Imperativeness</h2>\\n<p>It may be desired to leave room for some imperativeness/automation, and not have everything defined\\nin your Git manifests. For example, if you want the number of your deployment's replicas to be\\nmanaged by <a href=\\\"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\\\">Horizontal Pod Autoscaler</a>,\\nthen you would not want to track <code>replicas</code> in Git.</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  # do not include replicas in the manifests if you want replicas to be controlled by HPA\\n  # replicas: 1\\n  template:\\n    spec:\\n      containers:\\n      - image: nginx:1.7.9\\n        name: nginx\\n        ports:\\n        - containerPort: 80\\n...\\n</code></pre>\\n<h2>Ensuring Manifests At Git Revisions Are Truly Immutable</h2>\\n<p>When using templating tools like <code>helm</code> or <code>kustomize</code>, it is possible for manifests to change\\ntheir meaning from one day to the next. This is typically caused by changes made to an upstream helm\\nrepository or kustomize base.</p>\\n<p>For example, consider the following kustomization.yaml</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install\\n</code></pre>\\n<p>The above kustomization has a remote base to he HEAD revision of the argo-cd repo. Since this\\nis not stable target, the manifests for this kustomize application can suddenly change meaning, even without\\nany changes to your own Git repository.</p>\\n<p>A better version would be to use a Git tag or commit SHA. For example:</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v0.11.1\\n</code></pre>\",\"docPath\":\"argo-cd/docs/user-guide/best_practices\",\"proj\":\"argo-cd\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-cd-docs-user-guide-best-practices-html.json\n// module id = 577\n// module chunks = 243374918559653"],"sourceRoot":""}