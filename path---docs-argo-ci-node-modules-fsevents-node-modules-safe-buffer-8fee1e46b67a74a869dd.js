webpackJsonp([0xa8180ca41dcb],{2570:function(e,o){e.exports={pathContext:{docHtml:'<h1>safe-buffer <a href="https://travis-ci.org/feross/safe-buffer"><img src="https://img.shields.io/travis/feross/safe-buffer.svg" alt="travis"></a> <a href="https://npmjs.org/package/safe-buffer"><img src="https://img.shields.io/npm/v/safe-buffer.svg" alt="npm"></a> <a href="https://npmjs.org/package/safe-buffer"><img src="https://img.shields.io/npm/dm/safe-buffer.svg" alt="downloads"></a></h1>\n<h4>Safer Node.js Buffer API</h4>\n<p><strong>Use the new Node.js v6 Buffer APIs (<code>Buffer.from</code>, <code>Buffer.alloc</code>,\n<code>Buffer.allocUnsafe</code>, <code>Buffer.allocUnsafeSlow</code>) in Node.js v0.10, v0.12, v4.x, and v5.x.</strong></p>\n<p><strong>Uses the built-in implementations when available.</strong></p>\n<h2>install</h2>\n<pre><code>npm install safe-buffer\n</code></pre>\n<h2>usage</h2>\n<p>The goal of this package is to provide a safe replacement for the node.js <code>Buffer</code>.</p>\n<p>It\'s a drop-in replacement for <code>Buffer</code>. You can use it by adding one <code>require</code> line to\nthe top of your node.js modules:</p>\n<pre><code class="language-js">var Buffer = require(\'safe-buffer\').Buffer\n\n// Existing buffer code will continue to work without issues:\n\nnew Buffer(\'hey\', \'utf8\')\nnew Buffer([1, 2, 3], \'utf8\')\nnew Buffer(obj)\nnew Buffer(16) // create an uninitialized buffer (potentially unsafe)\n\n// But you can use these new explicit APIs to make clear what you want:\n\nBuffer.from(\'hey\', \'utf8\') // convert from many types to a Buffer\nBuffer.alloc(16) // create a zero-filled buffer (safe)\nBuffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)\n</code></pre>\n<h2>api</h2>\n<h3>Class Method: Buffer.from(array)</h3>\n<!-- YAML\nadded: v3.0.0\n-->\n<ul>\n<li><code>array</code> {Array}</li>\n</ul>\n<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class="language-js">const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);\n  // creates a new Buffer containing ASCII bytes\n  // [\'b\',\'u\',\'f\',\'f\',\'e\',\'r\']\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>\n<h3>Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])</h3>\n<!-- YAML\nadded: v5.10.0\n-->\n<ul>\n<li><code>arrayBuffer</code> {ArrayBuffer} The <code>.buffer</code> property of a <code>TypedArray</code> or\na <code>new ArrayBuffer()</code></li>\n<li><code>byteOffset</code> {Number} Default: <code>0</code></li>\n<li><code>length</code> {Number} Default: <code>arrayBuffer.length - byteOffset</code></li>\n</ul>\n<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\nTypedArray.</p>\n<pre><code class="language-js">const arr = new Uint16Array(2);\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = Buffer.from(arr.buffer); // shares the memory with arr;\n\nconsole.log(buf);\n  // Prints: &#x3C;Buffer 88 13 a0 0f>\n\n// changing the TypedArray changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n  // Prints: &#x3C;Buffer 88 13 70 17>\n</code></pre>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class="language-js">const ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\nconsole.log(buf.length);\n  // Prints: 2\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <code>ArrayBuffer</code>.</p>\n<h3>Class Method: Buffer.from(buffer)</h3>\n<!-- YAML\nadded: v3.0.0\n-->\n<ul>\n<li><code>buffer</code> {Buffer}</li>\n</ul>\n<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class="language-js">const buf1 = Buffer.from(\'buffer\');\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n  // \'auffer\'\nconsole.log(buf2.toString());\n  // \'buffer\' (copy is not changed)\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>\n<h3>Class Method: Buffer.from(str[, encoding])</h3>\n<!-- YAML\nadded: v5.10.0\n-->\n<ul>\n<li><code>str</code> {String} String to encode.</li>\n<li><code>encoding</code> {String} Encoding to use, Default: <code>\'utf8\'</code></li>\n</ul>\n<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>str</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding.\nIf not provided, <code>encoding</code> defaults to <code>\'utf8\'</code>.</p>\n<pre><code class="language-js">const buf1 = Buffer.from(\'this is a tést\');\nconsole.log(buf1.toString());\n  // prints: this is a tést\nconsole.log(buf1.toString(\'ascii\'));\n  // prints: this is a tC)st\n\nconst buf2 = Buffer.from(\'7468697320697320612074c3a97374\', \'hex\');\nconsole.log(buf2.toString());\n  // prints: this is a tést\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p>\n<h3>Class Method: Buffer.alloc(size[, fill[, encoding]])</h3>\n<!-- YAML\nadded: v5.10.0\n-->\n<ul>\n<li><code>size</code> {Number}</li>\n<li><code>fill</code> {Value} Default: <code>undefined</code></li>\n<li><code>encoding</code> {String} Default: <code>utf8</code></li>\n</ul>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the\n<code>Buffer</code> will be <em>zero-filled</em>.</p>\n<pre><code class="language-js">const buf = Buffer.alloc(5);\nconsole.log(buf);\n  // &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<p>The <code>size</code> must be less than or equal to the value of\n<code>require(\'buffer\').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is\n<code>(2^31)-1</code>). Otherwise, a <a href=""><code>RangeError</code></a> is thrown. A zero-length Buffer will\nbe created if a <code>size</code> less than or equal to 0 is specified.</p>\n<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling\n<code>buf.fill(fill)</code>. See <a href=""><code>buf.fill()</code></a> for more information.</p>\n<pre><code class="language-js">const buf = Buffer.alloc(5, \'a\');\nconsole.log(buf);\n  // &#x3C;Buffer 61 61 61 61 61>\n</code></pre>\n<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be\ninitialized by calling <code>buf.fill(fill, encoding)</code>. For example:</p>\n<pre><code class="language-js">const buf = Buffer.alloc(11, \'aGVsbG8gd29ybGQ=\', \'base64\');\nconsole.log(buf);\n  // &#x3C;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n</code></pre>\n<p>Calling <code>Buffer.alloc(size)</code> can be significantly slower than the alternative\n<code>Buffer.allocUnsafe(size)</code> but ensures that the newly created <code>Buffer</code> instance\ncontents will <em>never contain sensitive data</em>.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<h3>Class Method: Buffer.allocUnsafe(size)</h3>\n<!-- YAML\nadded: v5.10.0\n-->\n<ul>\n<li><code>size</code> {Number}</li>\n</ul>\n<p>Allocates a new <em>non-zero-filled</em> <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must\nbe less than or equal to the value of <code>require(\'buffer\').kMaxLength</code> (on 64-bit\narchitectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href=""><code>RangeError</code></a> is\nthrown. A zero-length Buffer will be created if a <code>size</code> less than or equal to\n0 is specified.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=""><code>buf.fill(0)</code></a> to initialize such\n<code>Buffer</code> instances to zeroes.</p>\n<pre><code class="language-js">const buf = Buffer.allocUnsafe(5);\nconsole.log(buf);\n  // &#x3C;Buffer 78 e0 82 02 01>\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // &#x3C;Buffer 00 00 00 00 00>\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of\nsize <code>Buffer.poolSize</code> that is used as a pool for the fast allocation of new\n<code>Buffer</code> instances created using <code>Buffer.allocUnsafe(size)</code> (and the deprecated\n<code>new Buffer(size)</code> constructor) only when <code>size</code> is less than or equal to\n<code>Buffer.poolSize >> 1</code> (floor of <code>Buffer.poolSize</code> divided by two). The default\nvalue of <code>Buffer.poolSize</code> is <code>8192</code> but can be modified.</p>\n<p>Use of this pre-allocated internal memory pool is a key difference between\ncalling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.\nSpecifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal Buffer\npool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal\nBuffer pool if <code>size</code> is less than or equal to half <code>Buffer.poolSize</code>. The\ndifference is subtle but can be important when an application requires the\nadditional performance that <code>Buffer.allocUnsafe(size)</code> provides.</p>\n<h3>Class Method: Buffer.allocUnsafeSlow(size)</h3>\n<!-- YAML\nadded: v5.10.0\n-->\n<ul>\n<li><code>size</code> {Number}</li>\n</ul>\n<p>Allocates a new <em>non-zero-filled</em> and non-pooled <code>Buffer</code> of <code>size</code> bytes.  The\n<code>size</code> must be less than or equal to the value of\n<code>require(\'buffer\').kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is\n<code>(2^31)-1</code>). Otherwise, a <a href=""><code>RangeError</code></a> is thrown. A zero-length Buffer will\nbe created if a <code>size</code> less than or equal to 0 is specified.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=""><code>buf.fill(0)</code></a> to initialize such\n<code>Buffer</code> instances to zeroes.</p>\n<p>When using <code>Buffer.allocUnsafe()</code> to allocate new <code>Buffer</code> instances,\nallocations under 4KB are, by default, sliced from a single pre-allocated\n<code>Buffer</code>. This allows applications to avoid the garbage collection overhead of\ncreating many individually allocated Buffers. This approach improves both\nperformance and memory usage by eliminating the need to track and cleanup as\nmany <code>Persistent</code> objects.</p>\n<p>However, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled Buffer instance using <code>Buffer.allocUnsafeSlow()</code> then\ncopy out the relevant bits.</p>\n<pre><code class="language-js">// need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(\'readable\', () => {\n  const data = socket.read();\n  // allocate for retained data\n  const sb = Buffer.allocUnsafeSlow(10);\n  // copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort <em>after</em>\na developer has observed undue memory retention in their applications.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<h3>All the Rest</h3>\n<p>The rest of the <code>Buffer</code> API is exactly the same as in node.js.\n<a href="https://nodejs.org/api/buffer.html">See the docs</a>.</p>\n<h2>Related links</h2>\n<ul>\n<li><a href="https://github.com/nodejs/node/issues/4660">Node.js issue: Buffer(number) is unsafe</a></li>\n<li><a href="https://github.com/nodejs/node-eps/pull/4">Node.js Enhancement Proposal: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate</a></li>\n</ul>\n<h2>Why is <code>Buffer</code> unsafe?</h2>\n<p>Today, the node.js <code>Buffer</code> constructor is overloaded to handle many different argument\ntypes like <code>String</code>, <code>Array</code>, <code>Object</code>, <code>TypedArrayView</code> (<code>Uint8Array</code>, etc.),\n<code>ArrayBuffer</code>, and also <code>Number</code>.</p>\n<p>The API is optimized for convenience: you can throw any type at it, and it will try to do\nwhat you want.</p>\n<p>Because the Buffer constructor is so powerful, you often see code like this:</p>\n<pre><code class="language-js">// Convert UTF-8 strings to hex\nfunction toHex (str) {\n  return new Buffer(str).toString(\'hex\')\n}\n</code></pre>\n<p><strong><em>But what happens if <code>toHex</code> is called with a <code>Number</code> argument?</em></strong></p>\n<h3>Remote Memory Disclosure</h3>\n<p>If an attacker can make your program call the <code>Buffer</code> constructor with a <code>Number</code>\nargument, then they can make it allocate uninitialized memory from the node.js process.\nThis could potentially disclose TLS private keys, user data, or database passwords.</p>\n<p>When the <code>Buffer</code> constructor is passed a <code>Number</code> argument, it returns an\n<strong>UNINITIALIZED</strong> block of memory of the specified <code>size</code>. When you create a <code>Buffer</code> like\nthis, you <strong>MUST</strong> overwrite the contents before returning it to the user.</p>\n<p>From the <a href="https://nodejs.org/api/buffer.html#buffer_new_buffer_size">node.js docs</a>:</p>\n<blockquote>\n<p><code>new Buffer(size)</code></p>\n<ul>\n<li><code>size</code> Number</li>\n</ul>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is not initialized.\n<strong>The contents of a newly created <code>Buffer</code> are unknown and could contain sensitive\ndata.</strong> Use <code>buf.fill(0)</code> to initialize a Buffer to zeroes.</p>\n</blockquote>\n<p>(Emphasis our own.)</p>\n<p>Whenever the programmer intended to create an uninitialized <code>Buffer</code> you often see code\nlike this:</p>\n<pre><code class="language-js">var buf = new Buffer(16)\n\n// Immediately overwrite the uninitialized buffer with data from another buffer\nfor (var i = 0; i &#x3C; buf.length; i++) {\n  buf[i] = otherBuf[i]\n}\n</code></pre>\n<h3>Would this ever be a problem in real code?</h3>\n<p>Yes. It\'s surprisingly common to forget to check the type of your variables in a\ndynamically-typed language like JavaScript.</p>\n<p>Usually the consequences of assuming the wrong type is that your program crashes with an\nuncaught exception. But the failure mode for forgetting to check the type of arguments to\nthe <code>Buffer</code> constructor is more catastrophic.</p>\n<p>Here\'s an example of a vulnerable service that takes a JSON payload and converts it to\nhex:</p>\n<pre><code class="language-js">// Take a JSON payload {str: "some string"} and convert it to hex\nvar server = http.createServer(function (req, res) {\n  var data = \'\'\n  req.setEncoding(\'utf8\')\n  req.on(\'data\', function (chunk) {\n    data += chunk\n  })\n  req.on(\'end\', function () {\n    var body = JSON.parse(data)\n    res.end(new Buffer(body.str).toString(\'hex\'))\n  })\n})\n\nserver.listen(8080)\n</code></pre>\n<p>In this example, an http client just has to send:</p>\n<pre><code class="language-json">{\n  "str": 1000\n}\n</code></pre>\n<p>and it will get back 1,000 bytes of uninitialized memory from the server.</p>\n<p>This is a very serious bug. It\'s similar in severity to the\n<a href="http://heartbleed.com/">the Heartbleed bug</a> that allowed disclosure of OpenSSL process\nmemory by remote attackers.</p>\n<h3>Which real-world packages were vulnerable?</h3>\n<h4><a href="https://www.npmjs.com/package/bittorrent-dht"><code>bittorrent-dht</code></a></h4>\n<p><a href="https://github.com/mafintosh">Mathias Buus</a> and I\n(<a href="http://feross.org/">Feross Aboukhadijeh</a>) found this issue in one of our own packages,\n<a href="https://www.npmjs.com/package/bittorrent-dht"><code>bittorrent-dht</code></a>. The bug would allow\nanyone on the internet to send a series of messages to a user of <code>bittorrent-dht</code> and get\nthem to reveal 20 bytes at a time of uninitialized memory from the node.js process.</p>\n<p>Here\'s\n<a href="https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8">the commit</a>\nthat fixed it. We released a new fixed version, created a\n<a href="https://nodesecurity.io/advisories/68">Node Security Project disclosure</a>, and deprecated all\nvulnerable versions on npm so users will get a warning to upgrade to a newer version.</p>\n<h4><a href="https://www.npmjs.com/package/ws"><code>ws</code></a></h4>\n<p>That got us wondering if there were other vulnerable packages. Sure enough, within a short\nperiod of time, we found the same issue in <a href="https://www.npmjs.com/package/ws"><code>ws</code></a>, the\nmost popular WebSocket implementation in node.js.</p>\n<p>If certain APIs were called with <code>Number</code> parameters instead of <code>String</code> or <code>Buffer</code> as\nexpected, then uninitialized server memory would be disclosed to the remote peer.</p>\n<p>These were the vulnerable methods:</p>\n<pre><code class="language-js">socket.send(number)\nsocket.ping(number)\nsocket.pong(number)\n</code></pre>\n<p>Here\'s a vulnerable socket server with some echo functionality:</p>\n<pre><code class="language-js">server.on(\'connection\', function (socket) {\n  socket.on(\'message\', function (message) {\n    message = JSON.parse(message)\n    if (message.type === \'echo\') {\n      socket.send(message.data) // send back the user\'s message\n    }\n  })\n})\n</code></pre>\n<p><code>socket.send(number)</code> called on the server, will disclose server memory.</p>\n<p>Here\'s <a href="https://github.com/websockets/ws/releases/tag/1.0.1">the release</a> where the issue\nwas fixed, with a more detailed explanation. Props to\n<a href="https://github.com/3rd-Eden">Arnout Kazemier</a> for the quick fix. Here\'s the\n<a href="https://nodesecurity.io/advisories/67">Node Security Project disclosure</a>.</p>\n<h3>What\'s the solution?</h3>\n<p>It\'s important that node.js offers a fast way to get memory otherwise performance-critical\napplications would needlessly get a lot slower.</p>\n<p>But we need a better way to <em>signal our intent</em> as programmers. <strong>When we want\nuninitialized memory, we should request it explicitly.</strong></p>\n<p>Sensitive functionality should not be packed into a developer-friendly API that loosely\naccepts many different types. This type of API encourages the lazy practice of passing\nvariables in without checking the type very carefully.</p>\n<h4>A new API: <code>Buffer.allocUnsafe(number)</code></h4>\n<p>The functionality of creating buffers with uninitialized memory should be part of another\nAPI. We propose <code>Buffer.allocUnsafe(number)</code>. This way, it\'s not part of an API that\nfrequently gets user input of all sorts of different types passed into it.</p>\n<pre><code class="language-js">var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!\n\n// Immediately overwrite the uninitialized buffer with data from another buffer\nfor (var i = 0; i &#x3C; buf.length; i++) {\n  buf[i] = otherBuf[i]\n}\n</code></pre>\n<h3>How do we fix node.js core?</h3>\n<p>We sent <a href="https://github.com/nodejs/node/pull/4514">a PR to node.js core</a> (merged as\n<code>semver-major</code>) which defends against one case:</p>\n<pre><code class="language-js">var str = 16\nnew Buffer(str, \'utf8\')\n</code></pre>\n<p>In this situation, it\'s implied that the programmer intended the first argument to be a\nstring, since they passed an encoding as a second argument. Today, node.js will allocate\nuninitialized memory in the case of <code>new Buffer(number, encoding)</code>, which is probably not\nwhat the programmer intended.</p>\n<p>But this is only a partial solution, since if the programmer does <code>new Buffer(variable)</code>\n(without an <code>encoding</code> parameter) there\'s no way to know what they intended. If <code>variable</code>\nis sometimes a number, then uninitialized memory will sometimes be returned.</p>\n<h3>What\'s the real long-term fix?</h3>\n<p>We could deprecate and remove <code>new Buffer(number)</code> and use <code>Buffer.allocUnsafe(number)</code> when\nwe need uninitialized memory. But that would break 1000s of packages.</p>\n<p><del>We believe the best solution is to:</del></p>\n<p><del>1. Change <code>new Buffer(number)</code> to return safe, zeroed-out memory</del></p>\n<p><del>2. Create a new API for creating uninitialized Buffers. We propose: <code>Buffer.allocUnsafe(number)</code></del></p>\n<h4>Update</h4>\n<p>We now support adding three new APIs:</p>\n<ul>\n<li><code>Buffer.from(value)</code> - convert from any type to a buffer</li>\n<li><code>Buffer.alloc(size)</code> - create a zero-filled buffer</li>\n<li><code>Buffer.allocUnsafe(size)</code> - create an uninitialized buffer with given size</li>\n</ul>\n<p>This solves the core problem that affected <code>ws</code> and <code>bittorrent-dht</code> which is\n<code>Buffer(variable)</code> getting tricked into taking a number argument.</p>\n<p>This way, existing code continues working and the impact on the npm ecosystem will be\nminimal. Over time, npm maintainers can migrate performance-critical code to use\n<code>Buffer.allocUnsafe(number)</code> instead of <code>new Buffer(number)</code>.</p>\n<h3>Conclusion</h3>\n<p>We think there\'s a serious design issue with the <code>Buffer</code> API as it exists today. It\npromotes insecure software by putting high-risk functionality into a convenient API\nwith friendly "developer ergonomics".</p>\n<p>This wasn\'t merely a theoretical exercise because we found the issue in some of the\nmost popular npm packages.</p>\n<p>Fortunately, there\'s an easy fix that can be applied today. Use <code>safe-buffer</code> in place of\n<code>buffer</code>.</p>\n<pre><code class="language-js">var Buffer = require(\'safe-buffer\').Buffer\n</code></pre>\n<p>Eventually, we hope that node.js core can switch to this new, safer behavior. We believe\nthe impact on the ecosystem would be minimal since it\'s not a breaking change.\nWell-maintained, popular packages would be updated to use <code>Buffer.alloc</code> quickly, while\nolder, insecure packages would magically become safe from this attack vector.</p>\n<h2>links</h2>\n<ul>\n<li><a href="https://github.com/nodejs/node/pull/4514">Node.js PR: buffer: throw if both length and enc are passed</a></li>\n<li><a href="https://nodesecurity.io/advisories/67">Node Security Project disclosure for <code>ws</code></a></li>\n<li><a href="https://nodesecurity.io/advisories/68">Node Security Project disclosure for<code>bittorrent-dht</code></a></li>\n</ul>\n<h2>credit</h2>\n<p>The original issues in <code>bittorrent-dht</code>\n(<a href="https://nodesecurity.io/advisories/68">disclosure</a>) and\n<code>ws</code> (<a href="https://nodesecurity.io/advisories/67">disclosure</a>) were discovered by\n<a href="https://github.com/mafintosh">Mathias Buus</a> and\n<a href="http://feross.org/">Feross Aboukhadijeh</a>.</p>\n<p>Thanks to <a href="https://github.com/evilpacket">Adam Baldwin</a> for helping disclose these issues\nand for his work running the <a href="https://nodesecurity.io/">Node Security Project</a>.</p>\n<p>Thanks to <a href="https://github.com/jhiesey">John Hiesey</a> for proofreading this README and\nauditing the code.</p>\n<h2>license</h2>\n<p>MIT. Copyright (C) <a href="http://feross.org">Feross Aboukhadijeh</a></p>',docPath:"argo-ci/node_modules/fsevents/node_modules/safe-buffer/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-fsevents-node-modules-safe-buffer-8fee1e46b67a74a869dd.js.map