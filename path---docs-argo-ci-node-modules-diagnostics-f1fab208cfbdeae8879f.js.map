{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-diagnostics-f1fab208cfbdeae8879f.js","webpack:///./.cache/json/docs-argo-ci-node-modules-diagnostics.json"],"names":["webpackJsonp","2249","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,04KAAw0KC,QAAA,0CAAAC,KAAA","file":"path---docs-argo-ci-node-modules-diagnostics-f1fab208cfbdeae8879f.js","sourcesContent":["webpackJsonp([202781127390271],{\n\n/***/ 2249:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>Diagnostics</h1>\\n<p><a href=\\\"https://travis-ci.org/bigpipe/diagnostics\\\"><img src=\\\"https://travis-ci.org/bigpipe/diagnostics.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></p>\\n<p>Diagnostics is a small debugging library which allows you to output your debug\\nlogs by setting an environment variable. The library works for server-side and\\nclient-size applications so it's great for writing isomorphic JavaScript.</p>\\n<p>The debug output can be triggered using environment variables on the server and\\nusing localStorage, hashtags and window.name on the browser. If the debug output\\nis not enabled this module will result in an empty function causing the\\nJavaScript compiler engines to remove it completely from your code so there is\\nabsolutely no performance overhead or excuses left to not use logging in your\\ncode!</p>\\n<h2>Installation</h2>\\n<p>The module is released in the public npm registry and can easily be installed by\\nrunning.</p>\\n<pre><code>npm install --save diagnostics\\n</code></pre>\\n<p>For client-side/front-end facing application we assume that you're using\\n<code>browserify</code> as your build tool as the client code is bundled as the\\n<code>browser.js</code> file in the root of this repository.</p>\\n<h2>Usage</h2>\\n<p>When you require the module it returns a function that expect a name or prefix\\nfor the debug messages. This prefix is what you use to enable specific debug\\nmessages.</p>\\n<p>The exported function of the module accepts 2 arguments:</p>\\n<ol>\\n<li><code>name</code> The namespace of the debug logger.</li>\\n<li><code>options</code> These options can only be applied to the server, not client code:</li>\\n<li><code>colors</code>: Enable or disable colors. Defaults to true if your stdout is a tty.</li>\\n<li><code>stream</code>: The stream instance we should write our logs to. We default to\\n<code>process.stdout</code> (unless you change the default using the <code>.to</code> method).</li>\\n</ol>\\n<pre><code class=\\\"language-js\\\">var debug = require('diagnostics')('foo');\\ndebug('hello world %d', 12);\\n</code></pre>\\n<p>In the example above you can see that we've created a new diagnostics function\\ncalled debug. It's name is set to <code>foo</code>. So when we run this in Node.js using:</p>\\n<pre><code>node index.js\\n</code></pre>\\n<p>We will see nothing in the console as the log messages are disabled by default.\\nBut when set the <code>DEBUG</code> or <code>DIAGNOSTICS</code> environment variables to the name of\\nthe debug function it will show up:</p>\\n<pre><code>DIAGNOSTICS=foo node index.js\\n\\nhello world 12\\n</code></pre>\\n<p>You can enable or disable specific diagnostic instances in the ENV variables by\\nseparating them using a space or comma:</p>\\n<pre><code>DEBUG=foo,-bar,primus:*\\n</code></pre>\\n<p>In the example above you also see an example of a wild card <code>*</code>. This ensures\\nthat anything after it or before it will be allowed.</p>\\n<p>To make it easier to see where the log messages are coming from they are\\ncolored automatically based on the namespace you provide them. The deeper the\\nnamespace, the lighter name will be toned as seen in the following output.</p>\\n<p><img src=\\\"output.PNG\\\" alt=\\\"output\\\"></p>\\n<h2>Browser</h2>\\n<p>The usage for browser is exactly the same as for node. You require the\\n<code>diagnostics</code> method and supply it with a name argument. The big difference is\\nthat no longer can use environment variables as these only work on the server.\\nSo to go around that you can use:</p>\\n<ul>\\n<li><strong>hashtag</strong> The hashtag will be parsed using query string decoding. So if you\\nhave an hash <code>#debug=foo</code> it will trigger all <code>foo</code> lines to be dumped to your\\nbrowser console.</li>\\n<li><strong>localStorage</strong> We will search for a query string in either the <code>env</code> or\\n<code>debug</code> key of <code>localStorage</code>. We again assume that the value has query string\\nencode value which contains either <code>debug</code> or <code>diagnostics</code>.\\n<code>localStorage.env = 'diagnostics=foo'</code>.</li>\\n<li><strong>window.name</strong> As <code>localStorage</code> is not available in all browsers, we provide\\na fallback to <code>window.name</code> which can contain the same values as the\\n<code>localStorage</code>'s env/debug keys.</li>\\n</ul>\\n<p>Unlike the server, the output of the browser is not colored. The reason for this\\nthat it would take a considerable amount of code. Which is not worth the benefit\\nas you usually want your front-end code to be as small as possible.</p>\\n<h4>Multiple streams</h4>\\n<blockquote>\\n<p>Please note that this feature is server-side only as in the browser we can only\\noutput to the console</p>\\n</blockquote>\\n<p>The beauty of this logger is that it allows a custom stream where you can write\\nthe data to. So you can just log it all to a separate server, database and what\\nnot. But we don't just allow one stream we allow multiple streams so you might\\nwant to log to disk AND just output it in your terminal. The only thing you need\\nto do is either use:</p>\\n<pre><code class=\\\"language-js\\\">require('diagnostics').to([\\n  stream1,\\n  stream2\\n]);\\n</code></pre>\\n<p>To set multiple streams as the default streams or supply an array for the logger\\nit self:</p>\\n<pre><code class=\\\"language-js\\\">var debug = require('diagnostics')('example', { stream: [\\n  stream1,\\n  stream2\\n]});\\n\\ndebug('foo');\\n</code></pre>\\n<h2>License</h2>\\n<p><a href=\\\"LICENSE.html\\\">MIT</a></p>\",\"docPath\":\"argo-ci/node_modules/diagnostics/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-diagnostics-f1fab208cfbdeae8879f.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>Diagnostics</h1>\\n<p><a href=\\\"https://travis-ci.org/bigpipe/diagnostics\\\"><img src=\\\"https://travis-ci.org/bigpipe/diagnostics.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></p>\\n<p>Diagnostics is a small debugging library which allows you to output your debug\\nlogs by setting an environment variable. The library works for server-side and\\nclient-size applications so it's great for writing isomorphic JavaScript.</p>\\n<p>The debug output can be triggered using environment variables on the server and\\nusing localStorage, hashtags and window.name on the browser. If the debug output\\nis not enabled this module will result in an empty function causing the\\nJavaScript compiler engines to remove it completely from your code so there is\\nabsolutely no performance overhead or excuses left to not use logging in your\\ncode!</p>\\n<h2>Installation</h2>\\n<p>The module is released in the public npm registry and can easily be installed by\\nrunning.</p>\\n<pre><code>npm install --save diagnostics\\n</code></pre>\\n<p>For client-side/front-end facing application we assume that you're using\\n<code>browserify</code> as your build tool as the client code is bundled as the\\n<code>browser.js</code> file in the root of this repository.</p>\\n<h2>Usage</h2>\\n<p>When you require the module it returns a function that expect a name or prefix\\nfor the debug messages. This prefix is what you use to enable specific debug\\nmessages.</p>\\n<p>The exported function of the module accepts 2 arguments:</p>\\n<ol>\\n<li><code>name</code> The namespace of the debug logger.</li>\\n<li><code>options</code> These options can only be applied to the server, not client code:</li>\\n<li><code>colors</code>: Enable or disable colors. Defaults to true if your stdout is a tty.</li>\\n<li><code>stream</code>: The stream instance we should write our logs to. We default to\\n<code>process.stdout</code> (unless you change the default using the <code>.to</code> method).</li>\\n</ol>\\n<pre><code class=\\\"language-js\\\">var debug = require('diagnostics')('foo');\\ndebug('hello world %d', 12);\\n</code></pre>\\n<p>In the example above you can see that we've created a new diagnostics function\\ncalled debug. It's name is set to <code>foo</code>. So when we run this in Node.js using:</p>\\n<pre><code>node index.js\\n</code></pre>\\n<p>We will see nothing in the console as the log messages are disabled by default.\\nBut when set the <code>DEBUG</code> or <code>DIAGNOSTICS</code> environment variables to the name of\\nthe debug function it will show up:</p>\\n<pre><code>DIAGNOSTICS=foo node index.js\\n\\nhello world 12\\n</code></pre>\\n<p>You can enable or disable specific diagnostic instances in the ENV variables by\\nseparating them using a space or comma:</p>\\n<pre><code>DEBUG=foo,-bar,primus:*\\n</code></pre>\\n<p>In the example above you also see an example of a wild card <code>*</code>. This ensures\\nthat anything after it or before it will be allowed.</p>\\n<p>To make it easier to see where the log messages are coming from they are\\ncolored automatically based on the namespace you provide them. The deeper the\\nnamespace, the lighter name will be toned as seen in the following output.</p>\\n<p><img src=\\\"output.PNG\\\" alt=\\\"output\\\"></p>\\n<h2>Browser</h2>\\n<p>The usage for browser is exactly the same as for node. You require the\\n<code>diagnostics</code> method and supply it with a name argument. The big difference is\\nthat no longer can use environment variables as these only work on the server.\\nSo to go around that you can use:</p>\\n<ul>\\n<li><strong>hashtag</strong> The hashtag will be parsed using query string decoding. So if you\\nhave an hash <code>#debug=foo</code> it will trigger all <code>foo</code> lines to be dumped to your\\nbrowser console.</li>\\n<li><strong>localStorage</strong> We will search for a query string in either the <code>env</code> or\\n<code>debug</code> key of <code>localStorage</code>. We again assume that the value has query string\\nencode value which contains either <code>debug</code> or <code>diagnostics</code>.\\n<code>localStorage.env = 'diagnostics=foo'</code>.</li>\\n<li><strong>window.name</strong> As <code>localStorage</code> is not available in all browsers, we provide\\na fallback to <code>window.name</code> which can contain the same values as the\\n<code>localStorage</code>'s env/debug keys.</li>\\n</ul>\\n<p>Unlike the server, the output of the browser is not colored. The reason for this\\nthat it would take a considerable amount of code. Which is not worth the benefit\\nas you usually want your front-end code to be as small as possible.</p>\\n<h4>Multiple streams</h4>\\n<blockquote>\\n<p>Please note that this feature is server-side only as in the browser we can only\\noutput to the console</p>\\n</blockquote>\\n<p>The beauty of this logger is that it allows a custom stream where you can write\\nthe data to. So you can just log it all to a separate server, database and what\\nnot. But we don't just allow one stream we allow multiple streams so you might\\nwant to log to disk AND just output it in your terminal. The only thing you need\\nto do is either use:</p>\\n<pre><code class=\\\"language-js\\\">require('diagnostics').to([\\n  stream1,\\n  stream2\\n]);\\n</code></pre>\\n<p>To set multiple streams as the default streams or supply an array for the logger\\nit self:</p>\\n<pre><code class=\\\"language-js\\\">var debug = require('diagnostics')('example', { stream: [\\n  stream1,\\n  stream2\\n]});\\n\\ndebug('foo');\\n</code></pre>\\n<h2>License</h2>\\n<p><a href=\\\"LICENSE.html\\\">MIT</a></p>\",\"docPath\":\"argo-ci/node_modules/diagnostics/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-diagnostics.json\n// module id = 2249\n// module chunks = 202781127390271"],"sourceRoot":""}