{"version":3,"sources":["webpack:///path---docs-argo-cd-docs-best-practices-html-765f5061119b826f0bf7.js","webpack:///./.cache/json/docs-argo-cd-docs-best-practices-html.json"],"names":["webpackJsonp","542","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,6jHAAAC,QAAA,8BAAAC,KAAA","file":"path---docs-argo-cd-docs-best-practices-html-765f5061119b826f0bf7.js","sourcesContent":["webpackJsonp([19109435545402],{\n\n/***/ 542:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>Best Practices</h1>\\n<h2>Separating config vs. source code repositories</h2>\\n<p>Using a separate git repository to hold your kubernetes manifests, keeping the config separate\\nfrom your application source code, is highly recommended for the following reasons:</p>\\n<ol>\\n<li>\\n<p>It provides a clean separation of application code vs. application config. There will be times\\nwhen you wish to modify just the manifests without triggering an entire CI build. For example,\\nyou likely do <em>not</em> want to trigger a build if you simply wish to bump the number of replicas in\\na Deployment spec.</p>\\n</li>\\n<li>\\n<p>Cleaner audit log. For auditing purposes, a repo which only holds configuration will have a much\\ncleaner git history of what changes were made, without the noise coming from check-ins due to\\nnormal development activity.</p>\\n</li>\\n<li>\\n<p>Your application may be comprised of services built from multiple git repositories, but is\\ndeployed as a single unit. Oftentimes, microservices applications are comprised of services\\nwith different versioning schemes, and release cycles (e.g. ELK, Kafka + Zookeeper). It may not\\nmake sense to store the manifests in one of the source code repositories of a single component.</p>\\n</li>\\n<li>\\n<p>Separation of access. The developers who are developing the application, may not necessarily be\\nthe same people who can/should push to production environments, either intentionally or\\nunintentionally. By having separate repos, commit access can be given to the source code repo,\\nand not the application config repo.</p>\\n</li>\\n<li>\\n<p>If you are automating your CI pipeline, pushing manifest changes to the same git repository can\\ntrigger an infinite loop of build jobs and git commit triggers. Having a separate repo to push\\nconfig changes to, prevents this from happening.</p>\\n</li>\\n</ol>\\n<h2>Leaving room for imperativeness</h2>\\n<p>It may be desired to leave room for some imperativeness/automation, and not have everything defined\\nin your git manifests. For example, if you want the number of your deployment's replicas to be\\nmanaged by <a href=\\\"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\\\">Horizontal Pod Autoscaler</a>,\\nthen you would not want to track <code>replicas</code> in git.</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  # do not include replicas in the manifests if you want replicas to be controlled by HPA\\n  # replicas: 1\\n  template:\\n    spec:\\n      containers:\\n      - image: nginx:1.7.9\\n        name: nginx\\n        ports:\\n        - containerPort: 80\\n...\\n</code></pre>\\n<h2>Ensuring manifests at git revisions are truly immutable</h2>\\n<p>When using templating tools like <code>helm</code> or <code>kustomize</code>, it is possible for manifests to change\\ntheir meaning from one day to the next. This is typically caused by changes made to an upstream helm\\nrepository or kustomize base.</p>\\n<p>For example, consider the following kustomization.yaml</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install\\n</code></pre>\\n<p>The above kustomization has a remote base to he HEAD revision of the argo-cd repo. Since this\\nis not stable target, the manifests for this kustomize application can suddenly change meaning, even without\\nany changes to your own git repository.</p>\\n<p>A better version would be to use a git tag or commit SHA. For example:</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v0.11.1\\n</code></pre>\",\"docPath\":\"argo-cd/docs/best_practices\",\"proj\":\"argo-cd\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-cd-docs-best-practices-html-765f5061119b826f0bf7.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>Best Practices</h1>\\n<h2>Separating config vs. source code repositories</h2>\\n<p>Using a separate git repository to hold your kubernetes manifests, keeping the config separate\\nfrom your application source code, is highly recommended for the following reasons:</p>\\n<ol>\\n<li>\\n<p>It provides a clean separation of application code vs. application config. There will be times\\nwhen you wish to modify just the manifests without triggering an entire CI build. For example,\\nyou likely do <em>not</em> want to trigger a build if you simply wish to bump the number of replicas in\\na Deployment spec.</p>\\n</li>\\n<li>\\n<p>Cleaner audit log. For auditing purposes, a repo which only holds configuration will have a much\\ncleaner git history of what changes were made, without the noise coming from check-ins due to\\nnormal development activity.</p>\\n</li>\\n<li>\\n<p>Your application may be comprised of services built from multiple git repositories, but is\\ndeployed as a single unit. Oftentimes, microservices applications are comprised of services\\nwith different versioning schemes, and release cycles (e.g. ELK, Kafka + Zookeeper). It may not\\nmake sense to store the manifests in one of the source code repositories of a single component.</p>\\n</li>\\n<li>\\n<p>Separation of access. The developers who are developing the application, may not necessarily be\\nthe same people who can/should push to production environments, either intentionally or\\nunintentionally. By having separate repos, commit access can be given to the source code repo,\\nand not the application config repo.</p>\\n</li>\\n<li>\\n<p>If you are automating your CI pipeline, pushing manifest changes to the same git repository can\\ntrigger an infinite loop of build jobs and git commit triggers. Having a separate repo to push\\nconfig changes to, prevents this from happening.</p>\\n</li>\\n</ol>\\n<h2>Leaving room for imperativeness</h2>\\n<p>It may be desired to leave room for some imperativeness/automation, and not have everything defined\\nin your git manifests. For example, if you want the number of your deployment's replicas to be\\nmanaged by <a href=\\\"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\\\">Horizontal Pod Autoscaler</a>,\\nthen you would not want to track <code>replicas</code> in git.</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  # do not include replicas in the manifests if you want replicas to be controlled by HPA\\n  # replicas: 1\\n  template:\\n    spec:\\n      containers:\\n      - image: nginx:1.7.9\\n        name: nginx\\n        ports:\\n        - containerPort: 80\\n...\\n</code></pre>\\n<h2>Ensuring manifests at git revisions are truly immutable</h2>\\n<p>When using templating tools like <code>helm</code> or <code>kustomize</code>, it is possible for manifests to change\\ntheir meaning from one day to the next. This is typically caused by changes made to an upstream helm\\nrepository or kustomize base.</p>\\n<p>For example, consider the following kustomization.yaml</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install\\n</code></pre>\\n<p>The above kustomization has a remote base to he HEAD revision of the argo-cd repo. Since this\\nis not stable target, the manifests for this kustomize application can suddenly change meaning, even without\\nany changes to your own git repository.</p>\\n<p>A better version would be to use a git tag or commit SHA. For example:</p>\\n<pre><code class=\\\"language-yaml\\\">bases:\\n- github.com/argoproj/argo-cd//manifests/cluster-install?ref=v0.11.1\\n</code></pre>\",\"docPath\":\"argo-cd/docs/best_practices\",\"proj\":\"argo-cd\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-cd-docs-best-practices-html.json\n// module id = 542\n// module chunks = 19109435545402"],"sourceRoot":""}