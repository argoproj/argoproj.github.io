{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-asap-209544bae537e80d4185.js","webpack:///./.cache/json/docs-argo-ci-node-modules-asap.json"],"names":["webpackJsonp","2044","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,4qVAA63IC,QAAA,mCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-asap-209544bae537e80d4185.js","sourcesContent":["webpackJsonp([11218041415418],{\n\n/***/ 2044:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>ASAP</h1>\\n<p><a href=\\\"https://travis-ci.org/kriskowal/asap\\\"><img src=\\\"https://travis-ci.org/kriskowal/asap.png?branch=master\\\" alt=\\\"Build Status\\\"></a></p>\\n<p>Promise and asynchronous observer libraries, as well as hand-rolled callback\\nprograms and libraries, often need a mechanism to postpone the execution of a\\ncallback until the next available event.\\n(See <a href=\\\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\\\">Designing API’s for Asynchrony</a>.)\\nThe <code>asap</code> function executes a task <strong>as soon as possible</strong> but not before it\\nreturns, waiting only for the completion of the current event and previously\\nscheduled tasks.</p>\\n<pre><code class=\\\"language-javascript\\\">asap(function () {\\n    // ...\\n});\\n</code></pre>\\n<p>This CommonJS package provides an <code>asap</code> module that exports a function that\\nexecutes a task function <em>as soon as possible</em>.</p>\\n<p>ASAP strives to schedule events to occur before yielding for IO, reflow,\\nor redrawing.\\nEach event receives an independent stack, with only platform code in parent\\nframes and the events run in the order they are scheduled.</p>\\n<p>ASAP provides a fast event queue that will execute tasks until it is\\nempty before yielding to the JavaScript engine's underlying event-loop.\\nWhen a task gets added to a previously empty event queue, ASAP schedules a flush\\nevent, preferring for that event to occur before the JavaScript engine has an\\nopportunity to perform IO tasks or rendering, thus making the first task and\\nsubsequent tasks semantically indistinguishable.\\nASAP uses a variety of techniques to preserve this invariant on different\\nversions of browsers and Node.js.</p>\\n<p>By design, ASAP prevents input events from being handled until the task\\nqueue is empty.\\nIf the process is busy enough, this may cause incoming connection requests to be\\ndropped, and may cause existing connections to inform the sender to reduce the\\ntransmission rate or stall.\\nASAP allows this on the theory that, if there is enough work to do, there is no\\nsense in looking for trouble.\\nAs a consequence, ASAP can interfere with smooth animation.\\nIf your task should be tied to the rendering loop, consider using\\n<code>requestAnimationFrame</code> instead.\\nA long sequence of tasks can also effect the long running script dialog.\\nIf this is a problem, you may be able to use ASAP’s cousin <code>setImmediate</code> to\\nbreak long processes into shorter intervals and periodically allow the browser\\nto breathe.\\n<code>setImmediate</code> will yield for IO, reflow, and repaint events.\\nIt also returns a handler and can be canceled.\\nFor a <code>setImmediate</code> shim, consider <a href=\\\"https://github.com/YuzuJS/setImmediate\\\">YuzuJS setImmediate</a>.</p>\\n<p>Take care.\\nASAP can sustain infinite recursive calls without warning.\\nIt will not halt from a stack overflow, and it will not consume unbounded\\nmemory.\\nThis is behaviorally equivalent to an infinite loop.\\nJust as with infinite loops, you can monitor a Node.js process for this behavior\\nwith a heart-beat signal.\\nAs with infinite loops, a very small amount of caution goes a long way to\\navoiding problems.</p>\\n<pre><code class=\\\"language-javascript\\\">function loop() {\\n    asap(loop);\\n}\\nloop();\\n</code></pre>\\n<p>In browsers, if a task throws an exception, it will not interrupt the flushing\\nof high-priority tasks.\\nThe exception will be postponed to a later, low-priority event to avoid\\nslow-downs.\\nIn Node.js, if a task throws an exception, ASAP will resume flushing only if—and\\nonly after—the error is handled by <code>domain.on(\\\"error\\\")</code> or\\n<code>process.on(\\\"uncaughtException\\\")</code>.</p>\\n<h2>Raw ASAP</h2>\\n<p>Checking for exceptions comes at a cost.\\nThe package also provides an <code>asap/raw</code> module that exports the underlying\\nimplementation which is faster but stalls if a task throws an exception.\\nThis internal version of the ASAP function does not check for errors.\\nIf a task does throw an error, it will stall the event queue unless you manually\\ncall <code>rawAsap.requestFlush()</code> before throwing the error, or any time after.</p>\\n<p>In Node.js, <code>asap/raw</code> also runs all tasks outside any domain.\\nIf you need a task to be bound to your domain, you will have to do it manually.</p>\\n<pre><code class=\\\"language-js\\\">if (process.domain) {\\n    task = process.domain.bind(task);\\n}\\nrawAsap(task);\\n</code></pre>\\n<h2>Tasks</h2>\\n<p>A task may be any object that implements <code>call()</code>.\\nA function will suffice, but closures tend not to be reusable and can cause\\ngarbage collector churn.\\nBoth <code>asap</code> and <code>rawAsap</code> accept task objects to give you the option of\\nrecycling task objects or using higher callable object abstractions.\\nSee the <code>asap</code> source for an illustration.</p>\\n<h2>Compatibility</h2>\\n<p>ASAP is tested on Node.js v0.10 and in a broad spectrum of web browsers.\\nThe following charts capture the browser test results for the most recent\\nrelease.\\nThe first chart shows test results for ASAP running in the main window context.\\nThe second chart shows test results for ASAP running in a web worker context.\\nTest results are inconclusive (grey) on browsers that do not support web\\nworkers.\\nThese data are captured automatically by <a href=\\\"https://github.com/kriskowal/asap/blob/master/CONTRIBUTING.md\\\">Continuous\\nIntegration</a>.</p>\\n<p><img src=\\\"http://kriskowal-asap.s3-website-us-west-2.amazonaws.com/train/integration-2/saucelabs-results-matrix.svg\\\" alt=\\\"Browser Compatibility\\\"></p>\\n<p><img src=\\\"http://kriskowal-asap.s3-website-us-west-2.amazonaws.com/train/integration-2/saucelabs-worker-results-matrix.svg\\\" alt=\\\"Compatibility in Web Workers\\\"></p>\\n<h2>Caveats</h2>\\n<p>When a task is added to an empty event queue, it is not always possible to\\nguarantee that the task queue will begin flushing immediately after the current\\nevent.\\nHowever, once the task queue begins flushing, it will not yield until the queue\\nis empty, even if the queue grows while executing tasks.</p>\\n<p>The following browsers allow the use of <a href=\\\"http://dom.spec.whatwg.org/#mutation-observers\\\">DOM mutation observers</a> to access\\nthe HTML <a href=\\\"http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#microtask-queue\\\">microtask queue</a>, and thus begin flushing ASAP's task queue\\nimmediately at the end of the current event loop turn, before any rendering or\\nIO:</p>\\n<ul>\\n<li>Android 4–4.3</li>\\n<li>Chrome 26–34</li>\\n<li>Firefox 14–29</li>\\n<li>Internet Explorer 11</li>\\n<li>iPad Safari 6–7.1</li>\\n<li>iPhone Safari 7–7.1</li>\\n<li>Safari 6–7</li>\\n</ul>\\n<p>In the absense of mutation observers, there are a few browsers, and situations\\nlike web workers in some of the above browsers,  where <a href=\\\"http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html#message-channels\\\">message channels</a>\\nwould be a useful way to avoid falling back to timers.\\nMessage channels give direct access to the HTML <a href=\\\"http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#concept-task\\\">task queue</a>, so the ASAP\\ntask queue would flush after any already queued rendering and IO tasks, but\\nwithout having the minimum delay imposed by timers.\\nHowever, among these browsers, Internet Explorer 10 and Safari do not reliably\\ndispatch messages, so they are not worth the trouble to implement.</p>\\n<ul>\\n<li>Internet Explorer 10</li>\\n<li>Safair 5.0-1</li>\\n<li>Opera 11-12</li>\\n</ul>\\n<p>In the absense of mutation observers, these browsers and the following browsers\\nall fall back to using <code>setTimeout</code> and <code>setInterval</code> to ensure that a <code>flush</code>\\noccurs.\\nThe implementation uses both and cancels whatever handler loses the race, since\\n<code>setTimeout</code> tends to occasionally skip tasks in unisolated circumstances.\\nTimers generally delay the flushing of ASAP's task queue for four milliseconds.</p>\\n<ul>\\n<li>Firefox 3–13</li>\\n<li>Internet Explorer 6–10</li>\\n<li>iPad Safari 4.3</li>\\n<li>Lynx 2.8.7</li>\\n</ul>\\n<h2>Heritage</h2>\\n<p>ASAP has been factored out of the <a href=\\\"https://github.com/kriskowal/q\\\">Q</a> asynchronous promise library.\\nIt originally had a naïve implementation in terms of <code>setTimeout</code>, but\\n<a href=\\\"http://www.nonblocking.io/2011/06/windownexttick.html\\\">Malte Ubl</a> provided an insight that <code>postMessage</code> might be\\nuseful for creating a high-priority, no-delay event dispatch hack.\\nSince then, Internet Explorer proposed and implemented <code>setImmediate</code>.\\nRobert Katić began contributing to Q by measuring the performance of\\nthe internal implementation of <code>asap</code>, paying particular attention to\\nerror recovery.\\nDomenic, Robert, and Kris Kowal collectively settled on the current strategy of\\nunrolling the high-priority event queue internally regardless of what strategy\\nwe used to dispatch the potentially lower-priority flush event.\\nDomenic went on to make ASAP cooperate with Node.js domains.</p>\\n<p>For further reading, Nicholas Zakas provided a thorough article on <a href=\\\"http://www.nczonline.net/blog/2013/07/09/the-case-for-setimmediate/\\\">The\\nCase for setImmediate</a>.</p>\\n<p>Ember’s RSVP promise implementation later <a href=\\\"https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\\\">adopted</a> the name ASAP but\\nfurther developed the implentation.\\nParticularly, The <code>MessagePort</code> implementation was abandoned due to interaction\\n<a href=\\\"https://github.com/cujojs/when/issues/197\\\">problems with Mobile Internet Explorer</a> in favor of an\\nimplementation backed on the newer and more reliable DOM <code>MutationObserver</code>\\ninterface.\\nThese changes were back-ported into this library.</p>\\n<p>In addition, ASAP factored into <code>asap</code> and <code>asap/raw</code>, such that <code>asap</code> remained\\nexception-safe, but <code>asap/raw</code> provided a tight kernel that could be used for\\ntasks that guaranteed that they would not throw exceptions.\\nThis core is useful for promise implementations that capture thrown errors in\\nrejected promises and do not need a second safety net.\\nAt the same time, the exception handling in <code>asap</code> was factored into separate\\nimplementations for Node.js and browsers, using the the <a href=\\\"https://gist.github.com/defunctzombie/4339901\\\">Browserify</a> <code>browser</code> property in <code>package.json</code> to instruct browser module loaders\\nand bundlers, including <a href=\\\"https://github.com/substack/node-browserify\\\">Browserify</a>, <a href=\\\"https://github.com/montagejs/mr\\\">Mr</a>, and <a href=\\\"https://github.com/montagejs/mop\\\">Mop</a>,  to use the\\nbrowser-only implementation.</p>\\n<h2>License</h2>\\n<p>Copyright 2009-2014 by Contributors\\nMIT License (enclosed)</p>\",\"docPath\":\"argo-ci/node_modules/asap/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-asap-209544bae537e80d4185.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>ASAP</h1>\\n<p><a href=\\\"https://travis-ci.org/kriskowal/asap\\\"><img src=\\\"https://travis-ci.org/kriskowal/asap.png?branch=master\\\" alt=\\\"Build Status\\\"></a></p>\\n<p>Promise and asynchronous observer libraries, as well as hand-rolled callback\\nprograms and libraries, often need a mechanism to postpone the execution of a\\ncallback until the next available event.\\n(See <a href=\\\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\\\">Designing API’s for Asynchrony</a>.)\\nThe <code>asap</code> function executes a task <strong>as soon as possible</strong> but not before it\\nreturns, waiting only for the completion of the current event and previously\\nscheduled tasks.</p>\\n<pre><code class=\\\"language-javascript\\\">asap(function () {\\n    // ...\\n});\\n</code></pre>\\n<p>This CommonJS package provides an <code>asap</code> module that exports a function that\\nexecutes a task function <em>as soon as possible</em>.</p>\\n<p>ASAP strives to schedule events to occur before yielding for IO, reflow,\\nor redrawing.\\nEach event receives an independent stack, with only platform code in parent\\nframes and the events run in the order they are scheduled.</p>\\n<p>ASAP provides a fast event queue that will execute tasks until it is\\nempty before yielding to the JavaScript engine's underlying event-loop.\\nWhen a task gets added to a previously empty event queue, ASAP schedules a flush\\nevent, preferring for that event to occur before the JavaScript engine has an\\nopportunity to perform IO tasks or rendering, thus making the first task and\\nsubsequent tasks semantically indistinguishable.\\nASAP uses a variety of techniques to preserve this invariant on different\\nversions of browsers and Node.js.</p>\\n<p>By design, ASAP prevents input events from being handled until the task\\nqueue is empty.\\nIf the process is busy enough, this may cause incoming connection requests to be\\ndropped, and may cause existing connections to inform the sender to reduce the\\ntransmission rate or stall.\\nASAP allows this on the theory that, if there is enough work to do, there is no\\nsense in looking for trouble.\\nAs a consequence, ASAP can interfere with smooth animation.\\nIf your task should be tied to the rendering loop, consider using\\n<code>requestAnimationFrame</code> instead.\\nA long sequence of tasks can also effect the long running script dialog.\\nIf this is a problem, you may be able to use ASAP’s cousin <code>setImmediate</code> to\\nbreak long processes into shorter intervals and periodically allow the browser\\nto breathe.\\n<code>setImmediate</code> will yield for IO, reflow, and repaint events.\\nIt also returns a handler and can be canceled.\\nFor a <code>setImmediate</code> shim, consider <a href=\\\"https://github.com/YuzuJS/setImmediate\\\">YuzuJS setImmediate</a>.</p>\\n<p>Take care.\\nASAP can sustain infinite recursive calls without warning.\\nIt will not halt from a stack overflow, and it will not consume unbounded\\nmemory.\\nThis is behaviorally equivalent to an infinite loop.\\nJust as with infinite loops, you can monitor a Node.js process for this behavior\\nwith a heart-beat signal.\\nAs with infinite loops, a very small amount of caution goes a long way to\\navoiding problems.</p>\\n<pre><code class=\\\"language-javascript\\\">function loop() {\\n    asap(loop);\\n}\\nloop();\\n</code></pre>\\n<p>In browsers, if a task throws an exception, it will not interrupt the flushing\\nof high-priority tasks.\\nThe exception will be postponed to a later, low-priority event to avoid\\nslow-downs.\\nIn Node.js, if a task throws an exception, ASAP will resume flushing only if—and\\nonly after—the error is handled by <code>domain.on(\\\"error\\\")</code> or\\n<code>process.on(\\\"uncaughtException\\\")</code>.</p>\\n<h2>Raw ASAP</h2>\\n<p>Checking for exceptions comes at a cost.\\nThe package also provides an <code>asap/raw</code> module that exports the underlying\\nimplementation which is faster but stalls if a task throws an exception.\\nThis internal version of the ASAP function does not check for errors.\\nIf a task does throw an error, it will stall the event queue unless you manually\\ncall <code>rawAsap.requestFlush()</code> before throwing the error, or any time after.</p>\\n<p>In Node.js, <code>asap/raw</code> also runs all tasks outside any domain.\\nIf you need a task to be bound to your domain, you will have to do it manually.</p>\\n<pre><code class=\\\"language-js\\\">if (process.domain) {\\n    task = process.domain.bind(task);\\n}\\nrawAsap(task);\\n</code></pre>\\n<h2>Tasks</h2>\\n<p>A task may be any object that implements <code>call()</code>.\\nA function will suffice, but closures tend not to be reusable and can cause\\ngarbage collector churn.\\nBoth <code>asap</code> and <code>rawAsap</code> accept task objects to give you the option of\\nrecycling task objects or using higher callable object abstractions.\\nSee the <code>asap</code> source for an illustration.</p>\\n<h2>Compatibility</h2>\\n<p>ASAP is tested on Node.js v0.10 and in a broad spectrum of web browsers.\\nThe following charts capture the browser test results for the most recent\\nrelease.\\nThe first chart shows test results for ASAP running in the main window context.\\nThe second chart shows test results for ASAP running in a web worker context.\\nTest results are inconclusive (grey) on browsers that do not support web\\nworkers.\\nThese data are captured automatically by <a href=\\\"https://github.com/kriskowal/asap/blob/master/CONTRIBUTING.md\\\">Continuous\\nIntegration</a>.</p>\\n<p><img src=\\\"http://kriskowal-asap.s3-website-us-west-2.amazonaws.com/train/integration-2/saucelabs-results-matrix.svg\\\" alt=\\\"Browser Compatibility\\\"></p>\\n<p><img src=\\\"http://kriskowal-asap.s3-website-us-west-2.amazonaws.com/train/integration-2/saucelabs-worker-results-matrix.svg\\\" alt=\\\"Compatibility in Web Workers\\\"></p>\\n<h2>Caveats</h2>\\n<p>When a task is added to an empty event queue, it is not always possible to\\nguarantee that the task queue will begin flushing immediately after the current\\nevent.\\nHowever, once the task queue begins flushing, it will not yield until the queue\\nis empty, even if the queue grows while executing tasks.</p>\\n<p>The following browsers allow the use of <a href=\\\"http://dom.spec.whatwg.org/#mutation-observers\\\">DOM mutation observers</a> to access\\nthe HTML <a href=\\\"http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#microtask-queue\\\">microtask queue</a>, and thus begin flushing ASAP's task queue\\nimmediately at the end of the current event loop turn, before any rendering or\\nIO:</p>\\n<ul>\\n<li>Android 4–4.3</li>\\n<li>Chrome 26–34</li>\\n<li>Firefox 14–29</li>\\n<li>Internet Explorer 11</li>\\n<li>iPad Safari 6–7.1</li>\\n<li>iPhone Safari 7–7.1</li>\\n<li>Safari 6–7</li>\\n</ul>\\n<p>In the absense of mutation observers, there are a few browsers, and situations\\nlike web workers in some of the above browsers,  where <a href=\\\"http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html#message-channels\\\">message channels</a>\\nwould be a useful way to avoid falling back to timers.\\nMessage channels give direct access to the HTML <a href=\\\"http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#concept-task\\\">task queue</a>, so the ASAP\\ntask queue would flush after any already queued rendering and IO tasks, but\\nwithout having the minimum delay imposed by timers.\\nHowever, among these browsers, Internet Explorer 10 and Safari do not reliably\\ndispatch messages, so they are not worth the trouble to implement.</p>\\n<ul>\\n<li>Internet Explorer 10</li>\\n<li>Safair 5.0-1</li>\\n<li>Opera 11-12</li>\\n</ul>\\n<p>In the absense of mutation observers, these browsers and the following browsers\\nall fall back to using <code>setTimeout</code> and <code>setInterval</code> to ensure that a <code>flush</code>\\noccurs.\\nThe implementation uses both and cancels whatever handler loses the race, since\\n<code>setTimeout</code> tends to occasionally skip tasks in unisolated circumstances.\\nTimers generally delay the flushing of ASAP's task queue for four milliseconds.</p>\\n<ul>\\n<li>Firefox 3–13</li>\\n<li>Internet Explorer 6–10</li>\\n<li>iPad Safari 4.3</li>\\n<li>Lynx 2.8.7</li>\\n</ul>\\n<h2>Heritage</h2>\\n<p>ASAP has been factored out of the <a href=\\\"https://github.com/kriskowal/q\\\">Q</a> asynchronous promise library.\\nIt originally had a naïve implementation in terms of <code>setTimeout</code>, but\\n<a href=\\\"http://www.nonblocking.io/2011/06/windownexttick.html\\\">Malte Ubl</a> provided an insight that <code>postMessage</code> might be\\nuseful for creating a high-priority, no-delay event dispatch hack.\\nSince then, Internet Explorer proposed and implemented <code>setImmediate</code>.\\nRobert Katić began contributing to Q by measuring the performance of\\nthe internal implementation of <code>asap</code>, paying particular attention to\\nerror recovery.\\nDomenic, Robert, and Kris Kowal collectively settled on the current strategy of\\nunrolling the high-priority event queue internally regardless of what strategy\\nwe used to dispatch the potentially lower-priority flush event.\\nDomenic went on to make ASAP cooperate with Node.js domains.</p>\\n<p>For further reading, Nicholas Zakas provided a thorough article on <a href=\\\"http://www.nczonline.net/blog/2013/07/09/the-case-for-setimmediate/\\\">The\\nCase for setImmediate</a>.</p>\\n<p>Ember’s RSVP promise implementation later <a href=\\\"https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\\\">adopted</a> the name ASAP but\\nfurther developed the implentation.\\nParticularly, The <code>MessagePort</code> implementation was abandoned due to interaction\\n<a href=\\\"https://github.com/cujojs/when/issues/197\\\">problems with Mobile Internet Explorer</a> in favor of an\\nimplementation backed on the newer and more reliable DOM <code>MutationObserver</code>\\ninterface.\\nThese changes were back-ported into this library.</p>\\n<p>In addition, ASAP factored into <code>asap</code> and <code>asap/raw</code>, such that <code>asap</code> remained\\nexception-safe, but <code>asap/raw</code> provided a tight kernel that could be used for\\ntasks that guaranteed that they would not throw exceptions.\\nThis core is useful for promise implementations that capture thrown errors in\\nrejected promises and do not need a second safety net.\\nAt the same time, the exception handling in <code>asap</code> was factored into separate\\nimplementations for Node.js and browsers, using the the <a href=\\\"https://gist.github.com/defunctzombie/4339901\\\">Browserify</a> <code>browser</code> property in <code>package.json</code> to instruct browser module loaders\\nand bundlers, including <a href=\\\"https://github.com/substack/node-browserify\\\">Browserify</a>, <a href=\\\"https://github.com/montagejs/mr\\\">Mr</a>, and <a href=\\\"https://github.com/montagejs/mop\\\">Mop</a>,  to use the\\nbrowser-only implementation.</p>\\n<h2>License</h2>\\n<p>Copyright 2009-2014 by Contributors\\nMIT License (enclosed)</p>\",\"docPath\":\"argo-ci/node_modules/asap/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-asap.json\n// module id = 2044\n// module chunks = 11218041415418"],"sourceRoot":""}