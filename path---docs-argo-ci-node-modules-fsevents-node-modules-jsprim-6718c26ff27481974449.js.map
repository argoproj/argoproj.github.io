{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-fsevents-node-modules-jsprim-6718c26ff27481974449.js","webpack:///./.cache/json/docs-argo-ci-node-modules-fsevents-node-modules-jsprim.json"],"names":["webpackJsonp","2509","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,g4YAAogYC,QAAA,2DAAAC,KAAA","file":"path---docs-argo-ci-node-modules-fsevents-node-modules-jsprim-6718c26ff27481974449.js","sourcesContent":["webpackJsonp([151116336792259],{\n\n/***/ 2509:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>jsprim: utilities for primitive JavaScript types</h1>\\n<p>This module provides miscellaneous facilities for working with strings,\\nnumbers, dates, and objects and arrays of these basic types.</p>\\n<h3>deepCopy(obj)</h3>\\n<p>Creates a deep copy of a primitive type, object, or array of primitive types.</p>\\n<h3>deepEqual(obj1, obj2)</h3>\\n<p>Returns whether two objects are equal.</p>\\n<h3>isEmpty(obj)</h3>\\n<p>Returns true if the given object has no properties and false otherwise.  This\\nis O(1) (unlike <code>Object.keys(obj).length === 0</code>, which is O(N)).</p>\\n<h3>hasKey(obj, key)</h3>\\n<p>Returns true if the given object has an enumerable, non-inherited property\\ncalled <code>key</code>.  <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\\\">For information on enumerability and ownership of properties, see\\nthe MDN\\ndocumentation.</a></p>\\n<h3>forEachKey(obj, callback)</h3>\\n<p>Like Array.forEach, but iterates enumerable, owned properties of an object\\nrather than elements of an array.  Equivalent to:</p>\\n<pre><code>for (var key in obj) {\\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\\n                callback(key, obj[key]);\\n        }\\n}\\n</code></pre>\\n<h3>flattenObject(obj, depth)</h3>\\n<p>Flattens an object up to a given level of nesting, returning an array of arrays\\nof length \\\"depth + 1\\\", where the first \\\"depth\\\" elements correspond to flattened\\ncolumns and the last element contains the remaining object .  For example:</p>\\n<pre><code>flattenObject({\\n    'I': {\\n        'A': {\\n            'i': {\\n                'datum1': [ 1, 2 ],\\n                'datum2': [ 3, 4 ]\\n            },\\n            'ii': {\\n                'datum1': [ 3, 4 ]\\n            }\\n        },\\n        'B': {\\n            'i': {\\n                'datum1': [ 5, 6 ]\\n            },\\n            'ii': {\\n                'datum1': [ 7, 8 ],\\n                'datum2': [ 3, 4 ],\\n            },\\n            'iii': {\\n            }\\n        }\\n    },\\n    'II': {\\n        'A': {\\n            'i': {\\n                'datum1': [ 1, 2 ],\\n                'datum2': [ 3, 4 ]\\n            }\\n        }\\n    }\\n}, 3)\\n</code></pre>\\n<p>becomes:</p>\\n<pre><code>[\\n    [ 'I',  'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ],\\n    [ 'I',  'A', 'ii',  { 'datum1': [ 3, 4 ] } ],\\n    [ 'I',  'B', 'i',   { 'datum1': [ 5, 6 ] } ],\\n    [ 'I',  'B', 'ii',  { 'datum1': [ 7, 8 ], 'datum2': [ 3, 4 ] } ],\\n    [ 'I',  'B', 'iii', {} ],\\n    [ 'II', 'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ]\\n]\\n</code></pre>\\n<p>This function is strict: \\\"depth\\\" must be a non-negative integer and \\\"obj\\\" must\\nbe a non-null object with at least \\\"depth\\\" levels of nesting under all keys.</p>\\n<h3>flattenIter(obj, depth, func)</h3>\\n<p>This is similar to <code>flattenObject</code> except that instead of returning an array,\\nthis function invokes <code>func(entry)</code> for each <code>entry</code> in the array that\\n<code>flattenObject</code> would return.  <code>flattenIter(obj, depth, func)</code> is logically\\nequivalent to <code>flattenObject(obj, depth).forEach(func)</code>.  Importantly, this\\nversion never constructs the full array.  Its memory usage is O(depth) rather\\nthan O(n) (where <code>n</code> is the number of flattened elements).</p>\\n<p>There's another difference between <code>flattenObject</code> and <code>flattenIter</code> that's\\nrelated to the special case where <code>depth === 0</code>.  In this case, <code>flattenObject</code>\\nomits the array wrapping <code>obj</code> (which is regrettable).</p>\\n<h3>pluck(obj, key)</h3>\\n<p>Fetch nested property \\\"key\\\" from object \\\"obj\\\", traversing objects as needed.\\nFor example, <code>pluck(obj, \\\"foo.bar.baz\\\")</code> is roughly equivalent to\\n<code>obj.foo.bar.baz</code>, except that:</p>\\n<ol>\\n<li>If traversal fails, the resulting value is undefined, and no error is\\nthrown.  For example, <code>pluck({}, \\\"foo.bar\\\")</code> is just undefined.</li>\\n<li>If \\\"obj\\\" has property \\\"key\\\" directly (without traversing), the\\ncorresponding property is returned.  For example,\\n<code>pluck({ 'foo.bar': 1 }, 'foo.bar')</code> is 1, not undefined.  This is also\\ntrue recursively, so <code>pluck({ 'a': { 'foo.bar': 1 } }, 'a.foo.bar')</code> is\\nalso 1, not undefined.</li>\\n</ol>\\n<h3>randElt(array)</h3>\\n<p>Returns an element from \\\"array\\\" selected uniformly at random.  If \\\"array\\\" is\\nempty, throws an Error.</p>\\n<h3>startsWith(str, prefix)</h3>\\n<p>Returns true if the given string starts with the given prefix and false\\notherwise.</p>\\n<h3>endsWith(str, suffix)</h3>\\n<p>Returns true if the given string ends with the given suffix and false\\notherwise.</p>\\n<h3>parseInteger(str, options)</h3>\\n<p>Parses the contents of <code>str</code> (a string) as an integer. On success, the integer\\nvalue is returned (as a number). On failure, an error is <strong>returned</strong> describing\\nwhy parsing failed.</p>\\n<p>By default, leading and trailing whitespace characters are not allowed, nor are\\ntrailing characters that are not part of the numeric representation. This\\nbehaviour can be toggled by using the options below. The empty string (<code>''</code>) is\\nnot considered valid input. If the return value cannot be precisely represented\\nas a number (i.e., is smaller than <code>Number.MIN_SAFE_INTEGER</code> or larger than\\n<code>Number.MAX_SAFE_INTEGER</code>), an error is returned. Additionally, the string\\n<code>'-0'</code> will be parsed as the integer <code>0</code>, instead of as the IEEE floating point\\nvalue <code>-0</code>.</p>\\n<p>This function accepts both upper and lowercase characters for digits, similar to\\n<code>parseInt()</code>, <code>Number()</code>, and <a href=\\\"https://illumos.org/man/3C/strtol\\\">strtol(3C)</a>.</p>\\n<p>The following may be specified in <code>options</code>:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Option</th>\\n<th>Type</th>\\n<th>Default</th>\\n<th>Meaning</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>base</td>\\n<td>number</td>\\n<td>10</td>\\n<td>numeric base (radix) to use, in the range 2 to 36</td>\\n</tr>\\n<tr>\\n<td>allowSign</td>\\n<td>boolean</td>\\n<td>true</td>\\n<td>whether to interpret any leading \\n<code>+</code>\\n (positive) and \\n<code>-</code>\\n (negative) characters</td>\\n</tr>\\n<tr>\\n<td>allowImprecise</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to accept values that may have lost precision (past \\n<code>MAX_SAFE_INTEGER</code>\\n or below \\n<code>MIN_SAFE_INTEGER</code>\\n)</td>\\n</tr>\\n<tr>\\n<td>allowPrefix</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to interpret the prefixes \\n<code>0b</code>\\n (base 2), \\n<code>0o</code>\\n (base 8), \\n<code>0t</code>\\n (base 10), or \\n<code>0x</code>\\n (base 16)</td>\\n</tr>\\n<tr>\\n<td>allowTrailing</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to ignore trailing characters</td>\\n</tr>\\n<tr>\\n<td>trimWhitespace</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to trim any leading or trailing whitespace/line terminators</td>\\n</tr>\\n<tr>\\n<td>leadingZeroIsOctal</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether a leading zero indicates octal</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Note that if <code>base</code> is unspecified, and <code>allowPrefix</code> or <code>leadingZeroIsOctal</code>\\nare, then the leading characters can change the default base from 10. If <code>base</code>\\nis explicitly specified and <code>allowPrefix</code> is true, then the prefix will only be\\naccepted if it matches the specified base. <code>base</code> and <code>leadingZeroIsOctal</code>\\ncannot be used together.</p>\\n<p><strong>Context:</strong> It's tricky to parse integers with JavaScript's built-in facilities\\nfor several reasons:</p>\\n<ul>\\n<li><code>parseInt()</code> and <code>Number()</code> by default allow the base to be specified in the\\ninput string by a prefix (e.g., <code>0x</code> for hex).</li>\\n<li><code>parseInt()</code> allows trailing nonnumeric characters.</li>\\n<li><code>Number(str)</code> returns 0 when <code>str</code> is the empty string (<code>''</code>).</li>\\n<li>Both functions return incorrect values when the input string represents a\\nvalid integer outside the range of integers that can be represented precisely.\\nSpecifically, <code>parseInt('9007199254740993')</code> returns 9007199254740992.</li>\\n<li>Both functions always accept <code>-</code> and <code>+</code> signs before the digit.</li>\\n<li>Some older JavaScript engines always interpret a leading 0 as indicating\\noctal, which can be surprising when parsing input from users who expect a\\nleading zero to be insignificant.</li>\\n</ul>\\n<p>While each of these may be desirable in some contexts, there are also times when\\nnone of them are wanted. <code>parseInteger()</code> grants greater control over what\\ninput's permissible.</p>\\n<h3>iso8601(date)</h3>\\n<p>Converts a Date object to an ISO8601 date string of the form\\n\\\"YYYY-MM-DDTHH:MM:SS.sssZ\\\".  This format is not customizable.</p>\\n<h3>parseDateTime(str)</h3>\\n<p>Parses a date expressed as a string, as either a number of milliseconds since\\nthe epoch or any string format that Date accepts, giving preference to the\\nformer where these two sets overlap (e.g., strings containing small numbers).</p>\\n<h3>hrtimeDiff(timeA, timeB)</h3>\\n<p>Given two hrtime readings (as from Node's <code>process.hrtime()</code>), where timeA is\\nlater than timeB, compute the difference and return that as an hrtime.  It is\\nillegal to invoke this for a pair of times where timeB is newer than timeA.</p>\\n<h3>hrtimeAdd(timeA, timeB)</h3>\\n<p>Add two hrtime intervals (as from Node's <code>process.hrtime()</code>), returning a new\\nhrtime interval array.  This function does not modify either input argument.</p>\\n<h3>hrtimeAccum(timeA, timeB)</h3>\\n<p>Add two hrtime intervals (as from Node's <code>process.hrtime()</code>), storing the\\nresult in <code>timeA</code>.  This function overwrites (and returns) the first argument\\npassed in.</p>\\n<h3>hrtimeNanosec(timeA), hrtimeMicrosec(timeA), hrtimeMillisec(timeA)</h3>\\n<p>This suite of functions converts a hrtime interval (as from Node's\\n<code>process.hrtime()</code>) into a scalar number of nanoseconds, microseconds or\\nmilliseconds.  Results are truncated, as with <code>Math.floor()</code>.</p>\\n<h3>validateJsonObject(schema, object)</h3>\\n<p>Uses JSON validation (via JSV) to validate the given object against the given\\nschema.  On success, returns null.  On failure, <em>returns</em> (does not throw) a\\nuseful Error object.</p>\\n<h3>extraProperties(object, allowed)</h3>\\n<p>Check an object for unexpected properties.  Accepts the object to check, and an\\narray of allowed property name strings.  If extra properties are detected, an\\narray of extra property names is returned.  If no properties other than those\\nin the allowed list are present on the object, the returned array will be of\\nzero length.</p>\\n<h3>mergeObjects(provided, overrides, defaults)</h3>\\n<p>Merge properties from objects \\\"provided\\\", \\\"overrides\\\", and \\\"defaults\\\".  The\\nintended use case is for functions that accept named arguments in an \\\"args\\\"\\nobject, but want to provide some default values and override other values.  In\\nthat case, \\\"provided\\\" is what the caller specified, \\\"overrides\\\" are what the\\nfunction wants to override, and \\\"defaults\\\" contains default values.</p>\\n<p>The function starts with the values in \\\"defaults\\\", overrides them with the\\nvalues in \\\"provided\\\", and then overrides those with the values in \\\"overrides\\\".\\nFor convenience, any of these objects may be falsey, in which case they will be\\nignored.  The input objects are never modified, but properties in the returned\\nobject are not deep-copied.</p>\\n<p>For example:</p>\\n<pre><code>mergeObjects(undefined, { 'objectMode': true }, { 'highWaterMark': 0 })\\n</code></pre>\\n<p>returns:</p>\\n<pre><code>{ 'objectMode': true, 'highWaterMark': 0 }\\n</code></pre>\\n<p>For another example:</p>\\n<pre><code>mergeObjects(\\n    { 'highWaterMark': 16, 'objectMode': 7 }, /* from caller */\\n    { 'objectMode': true },                   /* overrides */\\n    { 'highWaterMark': 0 });                  /* default */\\n</code></pre>\\n<p>returns:</p>\\n<pre><code>{ 'objectMode': true, 'highWaterMark': 16 }\\n</code></pre>\\n<h1>Contributing</h1>\\n<p>Code should be \\\"make check\\\" clean.  This target assumes that\\n<a href=\\\"http://github.com/davepacheco/javascriptlint\\\">jsl</a> and\\n<a href=\\\"http://github.com/davepacheco/jsstyle\\\">jsstyle</a> are on your path.</p>\\n<p>New tests should generally accompany new functions and bug fixes.  The tests\\nshould pass cleanly (run tests/basic.js).</p>\",\"docPath\":\"argo-ci/node_modules/fsevents/node_modules/jsprim/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-fsevents-node-modules-jsprim-6718c26ff27481974449.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>jsprim: utilities for primitive JavaScript types</h1>\\n<p>This module provides miscellaneous facilities for working with strings,\\nnumbers, dates, and objects and arrays of these basic types.</p>\\n<h3>deepCopy(obj)</h3>\\n<p>Creates a deep copy of a primitive type, object, or array of primitive types.</p>\\n<h3>deepEqual(obj1, obj2)</h3>\\n<p>Returns whether two objects are equal.</p>\\n<h3>isEmpty(obj)</h3>\\n<p>Returns true if the given object has no properties and false otherwise.  This\\nis O(1) (unlike <code>Object.keys(obj).length === 0</code>, which is O(N)).</p>\\n<h3>hasKey(obj, key)</h3>\\n<p>Returns true if the given object has an enumerable, non-inherited property\\ncalled <code>key</code>.  <a href=\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\\\">For information on enumerability and ownership of properties, see\\nthe MDN\\ndocumentation.</a></p>\\n<h3>forEachKey(obj, callback)</h3>\\n<p>Like Array.forEach, but iterates enumerable, owned properties of an object\\nrather than elements of an array.  Equivalent to:</p>\\n<pre><code>for (var key in obj) {\\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\\n                callback(key, obj[key]);\\n        }\\n}\\n</code></pre>\\n<h3>flattenObject(obj, depth)</h3>\\n<p>Flattens an object up to a given level of nesting, returning an array of arrays\\nof length \\\"depth + 1\\\", where the first \\\"depth\\\" elements correspond to flattened\\ncolumns and the last element contains the remaining object .  For example:</p>\\n<pre><code>flattenObject({\\n    'I': {\\n        'A': {\\n            'i': {\\n                'datum1': [ 1, 2 ],\\n                'datum2': [ 3, 4 ]\\n            },\\n            'ii': {\\n                'datum1': [ 3, 4 ]\\n            }\\n        },\\n        'B': {\\n            'i': {\\n                'datum1': [ 5, 6 ]\\n            },\\n            'ii': {\\n                'datum1': [ 7, 8 ],\\n                'datum2': [ 3, 4 ],\\n            },\\n            'iii': {\\n            }\\n        }\\n    },\\n    'II': {\\n        'A': {\\n            'i': {\\n                'datum1': [ 1, 2 ],\\n                'datum2': [ 3, 4 ]\\n            }\\n        }\\n    }\\n}, 3)\\n</code></pre>\\n<p>becomes:</p>\\n<pre><code>[\\n    [ 'I',  'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ],\\n    [ 'I',  'A', 'ii',  { 'datum1': [ 3, 4 ] } ],\\n    [ 'I',  'B', 'i',   { 'datum1': [ 5, 6 ] } ],\\n    [ 'I',  'B', 'ii',  { 'datum1': [ 7, 8 ], 'datum2': [ 3, 4 ] } ],\\n    [ 'I',  'B', 'iii', {} ],\\n    [ 'II', 'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ]\\n]\\n</code></pre>\\n<p>This function is strict: \\\"depth\\\" must be a non-negative integer and \\\"obj\\\" must\\nbe a non-null object with at least \\\"depth\\\" levels of nesting under all keys.</p>\\n<h3>flattenIter(obj, depth, func)</h3>\\n<p>This is similar to <code>flattenObject</code> except that instead of returning an array,\\nthis function invokes <code>func(entry)</code> for each <code>entry</code> in the array that\\n<code>flattenObject</code> would return.  <code>flattenIter(obj, depth, func)</code> is logically\\nequivalent to <code>flattenObject(obj, depth).forEach(func)</code>.  Importantly, this\\nversion never constructs the full array.  Its memory usage is O(depth) rather\\nthan O(n) (where <code>n</code> is the number of flattened elements).</p>\\n<p>There's another difference between <code>flattenObject</code> and <code>flattenIter</code> that's\\nrelated to the special case where <code>depth === 0</code>.  In this case, <code>flattenObject</code>\\nomits the array wrapping <code>obj</code> (which is regrettable).</p>\\n<h3>pluck(obj, key)</h3>\\n<p>Fetch nested property \\\"key\\\" from object \\\"obj\\\", traversing objects as needed.\\nFor example, <code>pluck(obj, \\\"foo.bar.baz\\\")</code> is roughly equivalent to\\n<code>obj.foo.bar.baz</code>, except that:</p>\\n<ol>\\n<li>If traversal fails, the resulting value is undefined, and no error is\\nthrown.  For example, <code>pluck({}, \\\"foo.bar\\\")</code> is just undefined.</li>\\n<li>If \\\"obj\\\" has property \\\"key\\\" directly (without traversing), the\\ncorresponding property is returned.  For example,\\n<code>pluck({ 'foo.bar': 1 }, 'foo.bar')</code> is 1, not undefined.  This is also\\ntrue recursively, so <code>pluck({ 'a': { 'foo.bar': 1 } }, 'a.foo.bar')</code> is\\nalso 1, not undefined.</li>\\n</ol>\\n<h3>randElt(array)</h3>\\n<p>Returns an element from \\\"array\\\" selected uniformly at random.  If \\\"array\\\" is\\nempty, throws an Error.</p>\\n<h3>startsWith(str, prefix)</h3>\\n<p>Returns true if the given string starts with the given prefix and false\\notherwise.</p>\\n<h3>endsWith(str, suffix)</h3>\\n<p>Returns true if the given string ends with the given suffix and false\\notherwise.</p>\\n<h3>parseInteger(str, options)</h3>\\n<p>Parses the contents of <code>str</code> (a string) as an integer. On success, the integer\\nvalue is returned (as a number). On failure, an error is <strong>returned</strong> describing\\nwhy parsing failed.</p>\\n<p>By default, leading and trailing whitespace characters are not allowed, nor are\\ntrailing characters that are not part of the numeric representation. This\\nbehaviour can be toggled by using the options below. The empty string (<code>''</code>) is\\nnot considered valid input. If the return value cannot be precisely represented\\nas a number (i.e., is smaller than <code>Number.MIN_SAFE_INTEGER</code> or larger than\\n<code>Number.MAX_SAFE_INTEGER</code>), an error is returned. Additionally, the string\\n<code>'-0'</code> will be parsed as the integer <code>0</code>, instead of as the IEEE floating point\\nvalue <code>-0</code>.</p>\\n<p>This function accepts both upper and lowercase characters for digits, similar to\\n<code>parseInt()</code>, <code>Number()</code>, and <a href=\\\"https://illumos.org/man/3C/strtol\\\">strtol(3C)</a>.</p>\\n<p>The following may be specified in <code>options</code>:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Option</th>\\n<th>Type</th>\\n<th>Default</th>\\n<th>Meaning</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>base</td>\\n<td>number</td>\\n<td>10</td>\\n<td>numeric base (radix) to use, in the range 2 to 36</td>\\n</tr>\\n<tr>\\n<td>allowSign</td>\\n<td>boolean</td>\\n<td>true</td>\\n<td>whether to interpret any leading \\n<code>+</code>\\n (positive) and \\n<code>-</code>\\n (negative) characters</td>\\n</tr>\\n<tr>\\n<td>allowImprecise</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to accept values that may have lost precision (past \\n<code>MAX_SAFE_INTEGER</code>\\n or below \\n<code>MIN_SAFE_INTEGER</code>\\n)</td>\\n</tr>\\n<tr>\\n<td>allowPrefix</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to interpret the prefixes \\n<code>0b</code>\\n (base 2), \\n<code>0o</code>\\n (base 8), \\n<code>0t</code>\\n (base 10), or \\n<code>0x</code>\\n (base 16)</td>\\n</tr>\\n<tr>\\n<td>allowTrailing</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to ignore trailing characters</td>\\n</tr>\\n<tr>\\n<td>trimWhitespace</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether to trim any leading or trailing whitespace/line terminators</td>\\n</tr>\\n<tr>\\n<td>leadingZeroIsOctal</td>\\n<td>boolean</td>\\n<td>false</td>\\n<td>whether a leading zero indicates octal</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Note that if <code>base</code> is unspecified, and <code>allowPrefix</code> or <code>leadingZeroIsOctal</code>\\nare, then the leading characters can change the default base from 10. If <code>base</code>\\nis explicitly specified and <code>allowPrefix</code> is true, then the prefix will only be\\naccepted if it matches the specified base. <code>base</code> and <code>leadingZeroIsOctal</code>\\ncannot be used together.</p>\\n<p><strong>Context:</strong> It's tricky to parse integers with JavaScript's built-in facilities\\nfor several reasons:</p>\\n<ul>\\n<li><code>parseInt()</code> and <code>Number()</code> by default allow the base to be specified in the\\ninput string by a prefix (e.g., <code>0x</code> for hex).</li>\\n<li><code>parseInt()</code> allows trailing nonnumeric characters.</li>\\n<li><code>Number(str)</code> returns 0 when <code>str</code> is the empty string (<code>''</code>).</li>\\n<li>Both functions return incorrect values when the input string represents a\\nvalid integer outside the range of integers that can be represented precisely.\\nSpecifically, <code>parseInt('9007199254740993')</code> returns 9007199254740992.</li>\\n<li>Both functions always accept <code>-</code> and <code>+</code> signs before the digit.</li>\\n<li>Some older JavaScript engines always interpret a leading 0 as indicating\\noctal, which can be surprising when parsing input from users who expect a\\nleading zero to be insignificant.</li>\\n</ul>\\n<p>While each of these may be desirable in some contexts, there are also times when\\nnone of them are wanted. <code>parseInteger()</code> grants greater control over what\\ninput's permissible.</p>\\n<h3>iso8601(date)</h3>\\n<p>Converts a Date object to an ISO8601 date string of the form\\n\\\"YYYY-MM-DDTHH:MM:SS.sssZ\\\".  This format is not customizable.</p>\\n<h3>parseDateTime(str)</h3>\\n<p>Parses a date expressed as a string, as either a number of milliseconds since\\nthe epoch or any string format that Date accepts, giving preference to the\\nformer where these two sets overlap (e.g., strings containing small numbers).</p>\\n<h3>hrtimeDiff(timeA, timeB)</h3>\\n<p>Given two hrtime readings (as from Node's <code>process.hrtime()</code>), where timeA is\\nlater than timeB, compute the difference and return that as an hrtime.  It is\\nillegal to invoke this for a pair of times where timeB is newer than timeA.</p>\\n<h3>hrtimeAdd(timeA, timeB)</h3>\\n<p>Add two hrtime intervals (as from Node's <code>process.hrtime()</code>), returning a new\\nhrtime interval array.  This function does not modify either input argument.</p>\\n<h3>hrtimeAccum(timeA, timeB)</h3>\\n<p>Add two hrtime intervals (as from Node's <code>process.hrtime()</code>), storing the\\nresult in <code>timeA</code>.  This function overwrites (and returns) the first argument\\npassed in.</p>\\n<h3>hrtimeNanosec(timeA), hrtimeMicrosec(timeA), hrtimeMillisec(timeA)</h3>\\n<p>This suite of functions converts a hrtime interval (as from Node's\\n<code>process.hrtime()</code>) into a scalar number of nanoseconds, microseconds or\\nmilliseconds.  Results are truncated, as with <code>Math.floor()</code>.</p>\\n<h3>validateJsonObject(schema, object)</h3>\\n<p>Uses JSON validation (via JSV) to validate the given object against the given\\nschema.  On success, returns null.  On failure, <em>returns</em> (does not throw) a\\nuseful Error object.</p>\\n<h3>extraProperties(object, allowed)</h3>\\n<p>Check an object for unexpected properties.  Accepts the object to check, and an\\narray of allowed property name strings.  If extra properties are detected, an\\narray of extra property names is returned.  If no properties other than those\\nin the allowed list are present on the object, the returned array will be of\\nzero length.</p>\\n<h3>mergeObjects(provided, overrides, defaults)</h3>\\n<p>Merge properties from objects \\\"provided\\\", \\\"overrides\\\", and \\\"defaults\\\".  The\\nintended use case is for functions that accept named arguments in an \\\"args\\\"\\nobject, but want to provide some default values and override other values.  In\\nthat case, \\\"provided\\\" is what the caller specified, \\\"overrides\\\" are what the\\nfunction wants to override, and \\\"defaults\\\" contains default values.</p>\\n<p>The function starts with the values in \\\"defaults\\\", overrides them with the\\nvalues in \\\"provided\\\", and then overrides those with the values in \\\"overrides\\\".\\nFor convenience, any of these objects may be falsey, in which case they will be\\nignored.  The input objects are never modified, but properties in the returned\\nobject are not deep-copied.</p>\\n<p>For example:</p>\\n<pre><code>mergeObjects(undefined, { 'objectMode': true }, { 'highWaterMark': 0 })\\n</code></pre>\\n<p>returns:</p>\\n<pre><code>{ 'objectMode': true, 'highWaterMark': 0 }\\n</code></pre>\\n<p>For another example:</p>\\n<pre><code>mergeObjects(\\n    { 'highWaterMark': 16, 'objectMode': 7 }, /* from caller */\\n    { 'objectMode': true },                   /* overrides */\\n    { 'highWaterMark': 0 });                  /* default */\\n</code></pre>\\n<p>returns:</p>\\n<pre><code>{ 'objectMode': true, 'highWaterMark': 16 }\\n</code></pre>\\n<h1>Contributing</h1>\\n<p>Code should be \\\"make check\\\" clean.  This target assumes that\\n<a href=\\\"http://github.com/davepacheco/javascriptlint\\\">jsl</a> and\\n<a href=\\\"http://github.com/davepacheco/jsstyle\\\">jsstyle</a> are on your path.</p>\\n<p>New tests should generally accompany new functions and bug fixes.  The tests\\nshould pass cleanly (run tests/basic.js).</p>\",\"docPath\":\"argo-ci/node_modules/fsevents/node_modules/jsprim/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-fsevents-node-modules-jsprim.json\n// module id = 2509\n// module chunks = 151116336792259"],"sourceRoot":""}