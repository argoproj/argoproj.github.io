{"version":3,"sources":["webpack:///path---docs-argo-cd-docs-rbac-html-0b0c2f7b83139d6d0870.js","webpack:///./.cache/json/docs-argo-cd-docs-rbac-html.json"],"names":["webpackJsonp","508","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,i2PAA8sPC,QAAA,oBAAAC,KAAA","file":"path---docs-argo-cd-docs-rbac-html-0b0c2f7b83139d6d0870.js","sourcesContent":["webpackJsonp([117079637263318],{\n\n/***/ 508:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>RBAC</h1>\\n<h2>Overview</h2>\\n<p>The RBAC feature enables restriction of access to ArgoCD resources. ArgoCD does not have its own\\nuser management system and has only one built-in user <code>admin</code>. The <code>admin</code> user is a superuser and\\nit has unrestricted access to the system. RBAC requires <a href=\\\"./sso.html\\\">SSO configuration</a>. Once SSO is\\nconfigured, additional RBAC roles can be defined, and SSO groups can man be mapped to roles.</p>\\n<h2>Configure RBAC</h2>\\n<p>RBAC configuration allows defining roles and groups. ArgoCD has two pre-defined roles:</p>\\n<ul>\\n<li><code>role:readonly</code> - read-only access to all resources</li>\\n<li><code>role:admin</code> - unrestricted access to all resources\\nThese role definitions can be seen in <a href=\\\"../util/rbac/builtin-policy.csv\\\">builtin-policy.csv</a></li>\\n</ul>\\n<p>Additional roles and groups can be configured in <code>argocd-rbac-cm</code> ConfigMap. The example below custom role <code>org-admin</code>. The role is assigned to any user which belongs to\\n<code>your-github-org:your-team</code> group. All other users get <code>role:readonly</code> and cannot modify ArgoCD settings.</p>\\n<p><em>ConfigMap <code>argocd-rbac-cm</code> example:</em></p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\ndata:\\n  policy.default: role:readonly\\n  policy.csv: |\\n    p, role:org-admin, applications, *, */*, allow\\n    p, role:org-admin, applications/*, *, */*, allow\\n\\n    p, role:org-admin, clusters, get, *, allow\\n    p, role:org-admin, repositories, get, *, allow\\n    p, role:org-admin, repositories/apps, get, *, allow\\n\\n    p, role:org-admin, repositories, create, *, allow\\n    p, role:org-admin, repositories, update, *, allow\\n    p, role:org-admin, repositories, delete, *, allow\\n\\n    g, your-github-org:your-team, role:org-admin\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-rbac-cm\\n</code></pre>\\n<h2>Configure Projects</h2>\\n<p>Argo projects allow grouping applications which is useful if ArgoCD is used by multiple teams. Additionally, projects restrict source repositories and destination\\nKubernetes clusters which can be used by applications belonging to the project.</p>\\n<h3>1. Create new project</h3>\\n<p>Following command creates project <code>myproject</code> which can deploy applications to namespace <code>default</code> of cluster <code>https://kubernetes.default.svc</code>. The valid application source is defined in the <code>https://github.com/argoproj/argocd-example-apps.git</code> repository.</p>\\n<pre><code>argocd proj create myproject -d https://kubernetes.default.svc,default -s https://github.com/argoproj/argocd-example-apps.git\\n</code></pre>\\n<p>Project sources and destinations can be managed using commands</p>\\n<pre><code>argocd project add-destination\\nargocd project remove-destination\\nargocd project add-source\\nargocd project remove-source\\n</code></pre>\\n<h3>2. Assign application to a project</h3>\\n<p>Each application belongs to a project. By default, all application belongs to the default project which provides access to any source repo/cluster. The application project can be\\nchanges using <code>app set</code> command:</p>\\n<pre><code>argocd app set guestbook-default --project myproject\\n</code></pre>\\n<h3>3. Update RBAC rules</h3>\\n<p>Following example configure admin access for two teams. Each team has access only two application of one project (<code>team1</code> can access <code>default</code> project and <code>team2</code> can access\\n<code>myproject</code> project).</p>\\n<p><em>ConfigMap <code>argocd-rbac-cm</code> example:</em></p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\ndata:\\n  policy.default: \\\"\\\"\\n  policy.csv: |\\n    p, role:team1-admin, applications, *, default/*, allow\\n    p, role:team1-admin, applications/*, *, default/*, allow\\n\\n    p, role:team1-admin, applications, *, myproject/*, allow\\n    p, role:team1-admin, applications/*, *, myproject/*, allow\\n\\n    p, role:org-admin, clusters, get, *, allow\\n    p, role:org-admin, repositories, get, *, allow\\n    p, role:org-admin, repositories/apps, get, *, allow\\n\\n    p, role:org-admin, repositories, create, *, allow\\n    p, role:org-admin, repositories, update, *, allow\\n    p, role:org-admin, repositories, delete, *, allow\\n\\n    g, role:team1-admin, org-admin\\n    g, role:team2-admin, org-admin\\n    g, your-github-org:your-team1, role:team1-admin\\n    g, your-github-org:your-team2, role:team2-admin\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-rbac-cm\\n</code></pre>\\n<h2>Project Roles</h2>\\n<p>Projects include a feature called roles that allow users to define access to project's applications.  A project can have multiple roles, and those roles can have different access granted to them.  These permissions are called policies, and they are stored within the role as a list of casbin strings.  A role's policy can only grant access to that role and are limited to applications within the role's project.  However, the policies have an option for granting wildcard access to any application within a project.</p>\\n<p>In order to create roles in a project and add policies to a role, a user will need permission to update a project.  The following commands can be used to manage a role.</p>\\n<pre><code>argoproj proj role list\\nargoproj proj role get\\nargoproj proj role create\\nargoproj proj role delete\\nargoproj proj role add-policy\\nargoproj proj role remove-policy\\n</code></pre>\\n<p>Project roles can not be used unless a user creates a entity that is associated with that project role.  ArgoCD supports creating JWT tokens with a role associated with it.  Since the JWT token is associated with a role's policies, any changes to the role's policies will immediately take effect for that JWT token.</p>\\n<p>A user will need permission to update a project in order to create a JWT token for a role, and they can use the following commands to manage the JWT tokens. </p>\\n<pre><code>argoproj proj role create-token\\nargoproj proj role delete-token\\n</code></pre>\\n<p>Since the JWT tokens aren't stored in ArgoCD, they can only be retrieved when they are created.  A user can leverage them in the cli by either passing them in using the <code>--auth-token</code> flag or setting the ARGOCD<em>AUTH</em>TOKEN environment variable. The JWT tokens can be used until they expire or are revoked.  The JWT tokens can created with or without an expiration, but the default on the cli is creates them without an expirations date.  Even if a token has not expired, it can not be used if the token has been revoke.</p>\\n<p>Below is an example of leveraging a JWT token to access the guestbook application.  It makes the assumption that the user already has a project named myproject and an application called guestbook-default.</p>\\n<pre><code>PROJ=myproject\\nAPP=guestbook-default\\nROLE=get-role\\nargocd proj role create $PROJ $ROLE\\nargocd proj role create-token $PROJ $ROLE -e 10m\\nJWT=&#x3C;value from command above>\\nargocd proj role list $PROJ\\nargocd proj role get $PROJ $ROLE\\n\\n#This command will fail because the JWT Token associated with the project role does not have a policy to allow access to the application\\nargocd app get $APP --auth-token $JWT\\n# Adding a policy to grant access to the application for the new role\\nargocd proj role add-policy $PROJ $ROLE --action get --permission allow --object $APP\\nargocd app get $PROJ-$ROLE --auth-token $JWT\\n\\n# Removing the policy we added and adding one with a wildcard.  \\nargocd proj role remove-policy $PROJ $TOKEN -a get -o $PROJ-$TOKEN\\nargocd proj role remove-policy $PROJ $TOKEN -a get -o '*'\\n# The wildcard allows us to access the application due to the wildcard.\\nargocd app get $PROJ-$TOKEN --auth-token $JWT\\nargocd proj role get $PROJ\\n\\n\\nargocd proj role get $PROJ $ROLE\\n# Revoking the JWT token\\nargocd proj role delete-token $PROJ $ROLE &#x3C;id field from the last command>\\n# This will fail since the JWT Token was deleted for the project role.\\nargocd app get $APP --auth-token $JWT\\n</code></pre>\",\"docPath\":\"argo-cd/docs/rbac\",\"proj\":\"argo-cd\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-cd-docs-rbac-html-0b0c2f7b83139d6d0870.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>RBAC</h1>\\n<h2>Overview</h2>\\n<p>The RBAC feature enables restriction of access to ArgoCD resources. ArgoCD does not have its own\\nuser management system and has only one built-in user <code>admin</code>. The <code>admin</code> user is a superuser and\\nit has unrestricted access to the system. RBAC requires <a href=\\\"./sso.html\\\">SSO configuration</a>. Once SSO is\\nconfigured, additional RBAC roles can be defined, and SSO groups can man be mapped to roles.</p>\\n<h2>Configure RBAC</h2>\\n<p>RBAC configuration allows defining roles and groups. ArgoCD has two pre-defined roles:</p>\\n<ul>\\n<li><code>role:readonly</code> - read-only access to all resources</li>\\n<li><code>role:admin</code> - unrestricted access to all resources\\nThese role definitions can be seen in <a href=\\\"../util/rbac/builtin-policy.csv\\\">builtin-policy.csv</a></li>\\n</ul>\\n<p>Additional roles and groups can be configured in <code>argocd-rbac-cm</code> ConfigMap. The example below custom role <code>org-admin</code>. The role is assigned to any user which belongs to\\n<code>your-github-org:your-team</code> group. All other users get <code>role:readonly</code> and cannot modify ArgoCD settings.</p>\\n<p><em>ConfigMap <code>argocd-rbac-cm</code> example:</em></p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\ndata:\\n  policy.default: role:readonly\\n  policy.csv: |\\n    p, role:org-admin, applications, *, */*, allow\\n    p, role:org-admin, applications/*, *, */*, allow\\n\\n    p, role:org-admin, clusters, get, *, allow\\n    p, role:org-admin, repositories, get, *, allow\\n    p, role:org-admin, repositories/apps, get, *, allow\\n\\n    p, role:org-admin, repositories, create, *, allow\\n    p, role:org-admin, repositories, update, *, allow\\n    p, role:org-admin, repositories, delete, *, allow\\n\\n    g, your-github-org:your-team, role:org-admin\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-rbac-cm\\n</code></pre>\\n<h2>Configure Projects</h2>\\n<p>Argo projects allow grouping applications which is useful if ArgoCD is used by multiple teams. Additionally, projects restrict source repositories and destination\\nKubernetes clusters which can be used by applications belonging to the project.</p>\\n<h3>1. Create new project</h3>\\n<p>Following command creates project <code>myproject</code> which can deploy applications to namespace <code>default</code> of cluster <code>https://kubernetes.default.svc</code>. The valid application source is defined in the <code>https://github.com/argoproj/argocd-example-apps.git</code> repository.</p>\\n<pre><code>argocd proj create myproject -d https://kubernetes.default.svc,default -s https://github.com/argoproj/argocd-example-apps.git\\n</code></pre>\\n<p>Project sources and destinations can be managed using commands</p>\\n<pre><code>argocd project add-destination\\nargocd project remove-destination\\nargocd project add-source\\nargocd project remove-source\\n</code></pre>\\n<h3>2. Assign application to a project</h3>\\n<p>Each application belongs to a project. By default, all application belongs to the default project which provides access to any source repo/cluster. The application project can be\\nchanges using <code>app set</code> command:</p>\\n<pre><code>argocd app set guestbook-default --project myproject\\n</code></pre>\\n<h3>3. Update RBAC rules</h3>\\n<p>Following example configure admin access for two teams. Each team has access only two application of one project (<code>team1</code> can access <code>default</code> project and <code>team2</code> can access\\n<code>myproject</code> project).</p>\\n<p><em>ConfigMap <code>argocd-rbac-cm</code> example:</em></p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: v1\\ndata:\\n  policy.default: \\\"\\\"\\n  policy.csv: |\\n    p, role:team1-admin, applications, *, default/*, allow\\n    p, role:team1-admin, applications/*, *, default/*, allow\\n\\n    p, role:team1-admin, applications, *, myproject/*, allow\\n    p, role:team1-admin, applications/*, *, myproject/*, allow\\n\\n    p, role:org-admin, clusters, get, *, allow\\n    p, role:org-admin, repositories, get, *, allow\\n    p, role:org-admin, repositories/apps, get, *, allow\\n\\n    p, role:org-admin, repositories, create, *, allow\\n    p, role:org-admin, repositories, update, *, allow\\n    p, role:org-admin, repositories, delete, *, allow\\n\\n    g, role:team1-admin, org-admin\\n    g, role:team2-admin, org-admin\\n    g, your-github-org:your-team1, role:team1-admin\\n    g, your-github-org:your-team2, role:team2-admin\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-rbac-cm\\n</code></pre>\\n<h2>Project Roles</h2>\\n<p>Projects include a feature called roles that allow users to define access to project's applications.  A project can have multiple roles, and those roles can have different access granted to them.  These permissions are called policies, and they are stored within the role as a list of casbin strings.  A role's policy can only grant access to that role and are limited to applications within the role's project.  However, the policies have an option for granting wildcard access to any application within a project.</p>\\n<p>In order to create roles in a project and add policies to a role, a user will need permission to update a project.  The following commands can be used to manage a role.</p>\\n<pre><code>argoproj proj role list\\nargoproj proj role get\\nargoproj proj role create\\nargoproj proj role delete\\nargoproj proj role add-policy\\nargoproj proj role remove-policy\\n</code></pre>\\n<p>Project roles can not be used unless a user creates a entity that is associated with that project role.  ArgoCD supports creating JWT tokens with a role associated with it.  Since the JWT token is associated with a role's policies, any changes to the role's policies will immediately take effect for that JWT token.</p>\\n<p>A user will need permission to update a project in order to create a JWT token for a role, and they can use the following commands to manage the JWT tokens. </p>\\n<pre><code>argoproj proj role create-token\\nargoproj proj role delete-token\\n</code></pre>\\n<p>Since the JWT tokens aren't stored in ArgoCD, they can only be retrieved when they are created.  A user can leverage them in the cli by either passing them in using the <code>--auth-token</code> flag or setting the ARGOCD<em>AUTH</em>TOKEN environment variable. The JWT tokens can be used until they expire or are revoked.  The JWT tokens can created with or without an expiration, but the default on the cli is creates them without an expirations date.  Even if a token has not expired, it can not be used if the token has been revoke.</p>\\n<p>Below is an example of leveraging a JWT token to access the guestbook application.  It makes the assumption that the user already has a project named myproject and an application called guestbook-default.</p>\\n<pre><code>PROJ=myproject\\nAPP=guestbook-default\\nROLE=get-role\\nargocd proj role create $PROJ $ROLE\\nargocd proj role create-token $PROJ $ROLE -e 10m\\nJWT=&#x3C;value from command above>\\nargocd proj role list $PROJ\\nargocd proj role get $PROJ $ROLE\\n\\n#This command will fail because the JWT Token associated with the project role does not have a policy to allow access to the application\\nargocd app get $APP --auth-token $JWT\\n# Adding a policy to grant access to the application for the new role\\nargocd proj role add-policy $PROJ $ROLE --action get --permission allow --object $APP\\nargocd app get $PROJ-$ROLE --auth-token $JWT\\n\\n# Removing the policy we added and adding one with a wildcard.  \\nargocd proj role remove-policy $PROJ $TOKEN -a get -o $PROJ-$TOKEN\\nargocd proj role remove-policy $PROJ $TOKEN -a get -o '*'\\n# The wildcard allows us to access the application due to the wildcard.\\nargocd app get $PROJ-$TOKEN --auth-token $JWT\\nargocd proj role get $PROJ\\n\\n\\nargocd proj role get $PROJ $ROLE\\n# Revoking the JWT token\\nargocd proj role delete-token $PROJ $ROLE &#x3C;id field from the last command>\\n# This will fail since the JWT Token was deleted for the project role.\\nargocd app get $APP --auth-token $JWT\\n</code></pre>\",\"docPath\":\"argo-cd/docs/rbac\",\"proj\":\"argo-cd\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-cd-docs-rbac-html.json\n// module id = 508\n// module chunks = 117079637263318"],"sourceRoot":""}