{"version":3,"sources":["webpack:///path---docs-argo-metrics-html-b6cb3777048e6fac25aa.js","webpack:///./.cache/json/docs-argo-metrics-html.json"],"names":["webpackJsonp","489","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,6teAA2/eC,QAAA,eAAAC,KAAA","file":"path---docs-argo-metrics-html-b6cb3777048e6fac25aa.js","sourcesContent":["webpackJsonp([83372245247618],{\n\n/***/ 489:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1 id=\\\"prometheus-metrics\\\"><a href=\\\"#prometheus-metrics\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Prometheus Metrics</h1>\\n<p><img src=\\\"/argo/assets/alpha.svg\\\" alt=\\\"alpha\\\"></p>\\n<blockquote>\\n<p>v2.7 and after</p>\\n</blockquote>\\n<h2 id=\\\"introduction\\\"><a href=\\\"#introduction\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Introduction</h2>\\n<p>Custom prometheus metrics can be defined to be emitted on a <code>Workflow</code>- and <code>Template</code>-level basis. These can be useful\\nfor many cases; some examples:</p>\\n<ul>\\n<li>Keeping track of the duration of a <code>Workflow</code> or <code>Template</code> over time, and setting an alert if it goes beyond a threshold</li>\\n<li>Keeping track of the number of times a <code>Workflow</code> or <code>Template</code> fails over time</li>\\n<li>Reporting an important internal metric, such as a model training score or an internal error rate</li>\\n</ul>\\n<p>Emitting custom metrics with Argo is easy, but it's important to understand what makes a good Prometheus metric and the\\nbest way to define metrics in Argo to avoid problems such as <a href=\\\"https://stackoverflow.com/questions/46373442/how-dangerous-are-high-cardinality-labels-in-prometheus\\\">cardinality explosion</a>.</p>\\n<h2 id=\\\"metrics-and-metrics-in-argo\\\"><a href=\\\"#metrics-and-metrics-in-argo\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Metrics and metrics in Argo</h2>\\n<p>Emitting metrics is the responsibility of the emitter owner. Since the user defines Workflows in Argo, the user is responsible\\nfor emitting metrics correctly.</p>\\n<h3 id=\\\"what-is-and-isnt-a-prometheus-metric\\\"><a href=\\\"#what-is-and-isnt-a-prometheus-metric\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>What is and isn't a Prometheus metric</h3>\\n<p>Prometheus metrics should be thought of as ephemeral data points of running processes; i.e., they are the answer to\\nthe question \\\"What is the state of my system <em>right now</em>?\\\". Metrics should report things such as:</p>\\n<ul>\\n<li>a counter of the number of times a workflow or steps has failed, or</li>\\n<li>a gauge of workflow duration, or</li>\\n<li>an average of an internal metric such as a model training score or error rate.</li>\\n</ul>\\n<p>Metrics are then routinely scraped and stored and -- when they are correctly designed -- they can represent time series.\\nAggregating the examples above over time could answer useful questions such as:</p>\\n<ul>\\n<li>How has the error rate of this workflow or step changed over time?</li>\\n<li>How has the duration of this workflow changed over time? Is the current workflow running for too long?</li>\\n<li>Is our model improving over time?</li>\\n</ul>\\n<p>Prometheus metrics should <strong>not</strong> be thought of as a store of data. Since metrics should only report the state of the system\\nat the current time, they should not be used to report historical data such as:</p>\\n<ul>\\n<li>the status of an individual instance of a workflow, or</li>\\n<li>how long a particular instance of a step took to run.</li>\\n</ul>\\n<p>Metrics are also ephemeral, meaning there is no guarantee that they will be persisted for any amount of time. If you need\\na way to view and analyze historical data, consider the <a href=\\\"workflow-archive.html\\\">workflow archive</a> or reporting to logs.</p>\\n<h3 id=\\\"metric-types\\\"><a href=\\\"#metric-types\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Metric types</h3>\\n<p>Please see the <a href=\\\"https://prometheus.io/docs/concepts/metric_types/\\\">Prometheus docs on metric types</a>.</p>\\n<h3 id=\\\"how-metrics-work-in-argo\\\"><a href=\\\"#how-metrics-work-in-argo\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>How metrics work in Argo</h3>\\n<p>In order to analyze the behavior of a workflow over time, we need to be able to link different instances\\n(i.e. individual executions) of a workflow together into a \\\"series\\\" for the purposes of emitting metrics. We do so by linking them together\\nwith the same metric descriptor.</p>\\n<p>In prometheus, a metric descriptor is defined as a metric's name and its key-value labels. For example, for a metric\\ntracking the duration of model execution over time, a metric descriptor could be:</p>\\n<p><code>argo_workflows_model_exec_time{model_name=\\\"model_a\\\",phase=\\\"validation\\\"}</code></p>\\n<p>This metric then represents the amount of time that \\\"Model A\\\" took to train in the phase \\\"Validation\\\". It is important\\nto understand that the metric name <em>and</em> its labels form the descriptor: <code>argo_workflows_model_exec_time{model_name=\\\"model_b\\\",phase=\\\"validation\\\"}</code>\\nis a different metric (and will track a different \\\"series\\\" altogether).</p>\\n<p>Now, whenever we run our first workflow that validates \\\"Model A\\\" a metric with the amount of time it took it to do so will\\nbe created and emitted. For each subsequent time that this happens, no new metrics will be emitted and the <em>same</em> metric\\nwill be updated with the new value. Since, in effect, we are interested on the execution time of \\\"validation\\\" of \\\"Model A\\\"\\nover time, we are no longer interested in the previous metric and can assume it has already been scraped.</p>\\n<p>In summary, whenever you want to track a particular metric over time, you should use the same metric name <em>and</em> metric\\nlabels wherever it is emitted. This is how these metrics are \\\"linked\\\" as belonging to the same series.</p>\\n<h2 id=\\\"defining-metrics\\\"><a href=\\\"#defining-metrics\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Defining metrics</h2>\\n<p>Metrics are defined in-place on the Workflow/Step/Task where they are emitted from. Metrics are always processed <em>after</em>\\nthe Workflow/Step/Task completes, with the exception of <a href=\\\"#realtime-metrics\\\">realtime metrics</a>.</p>\\n<p>Metric definitions <strong>must</strong> include a <code>name</code> and a <code>help</code> doc string. They can also include any number of <code>labels</code> (when\\ndefining labels avoid cardinality explosion).</p>\\n<p>All metrics can also be conditionally emitted by defining a <code>when</code> clause. This <code>when</code> clause works the same as elsewhere\\nin a workflow.</p>\\n<p>A metric must also have a type, it can be one of <code>gauge</code>, <code>histogram</code>, and <code>counter</code> (<a href=\\\"#metric-spec\\\">see below</a>). Within\\nthe metric type a <code>value</code> must be specified. This value can be either a literal value of be an <a href=\\\"variables.html\\\">Argo variable</a>.</p>\\n<p>When defining a <code>histogram</code>, <code>buckets</code> must also be provided (see below).</p>\\n<p><a href=\\\"variables.html\\\">Argo variables</a> can be included anywhere in the metric spec, such as in <code>labels</code>, <code>name</code>, <code>help</code>, <code>when</code>, etc.</p>\\n<h3 id=\\\"metric-spec\\\"><a href=\\\"#metric-spec\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Metric Spec</h3>\\n<p> In Argo you can define a metric on the <code>Workflow</code> level or on the <code>Template</code> level. Here is an example of a <code>Workflow</code>\\nlevel Gauge metric that will report the Workflow duration time:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Workflow\\nmetadata:\\n generateName: model-training-\\nspec:\\n entrypoint: steps\\n metrics:\\n   prometheus:\\n     - name: exec_duration_gauge         # Metric name (will be prepended with \\\"argo_workflows_\\\")\\n       labels:                           # Labels are optional. Avoid cardinality explosion.\\n         - key: name\\n           value: model_a\\n       help: \\\"Duration gauge by name\\\"    # A help doc describing your metric. This is required.\\n       gauge:                            # The metric type. Available are \\\"gauge\\\", \\\"histogram\\\", and \\\"counter\\\".\\n         value: \\\"{{workflow.duration}}\\\"  # The value of your metric. It could be an Argo variable (see variables doc) or a literal value\\n\\n... \\n</code></pre>\\n<p>An example of a <code>Template</code>-level Counter metric that will increase a counter every time the step fails:</p>\\n<pre><code class=\\\"language-yaml\\\">...\\n  templates:\\n    - name: flakey\\n      metrics:\\n        prometheus:\\n          - name: result_counter\\n            help: \\\"Count of step execution by result status\\\"\\n            labels:\\n              - key: name\\n                value: flakey\\n            when: \\\"{{status}} == Failed\\\"       # Emit the metric conditionally. Works the same as normal \\\"when\\\"\\n            counter:\\n              value: \\\"1\\\"                            # This increments the counter by 1\\n      container:\\n        image: python:alpine3.6\\n        command: [\\\"python\\\", -c]\\n        # fail with a 66% probability\\n        args: [\\\"import random; import sys; exit_code = random.choice([0, 1, 1]); sys.exit(exit_code)\\\"]\\n...\\n</code></pre>\\n<p>A similar example of such a Counter metric that will increase for every step status</p>\\n<pre><code class=\\\"language-yaml\\\">...\\n  templates:\\n    - name: flakey\\n      metrics:\\n        prometheus:\\n          - name: result_counter\\n            help: \\\"Count of step execution by result status\\\"\\n            labels:\\n              - key: name\\n                value: flakey\\n              - key: status\\n                value: \\\"{{status}}\\\"    # Argo variable in `labels`\\n            counter:\\n              value: \\\"1\\\"\\n      container:\\n        image: python:alpine3.6\\n        command: [\\\"python\\\", -c]\\n        # fail with a 66% probability\\n        args: [\\\"import random; import sys; exit_code = random.choice([0, 1, 1]); sys.exit(exit_code)\\\"]\\n</code></pre>\\n<p>Finally, an example of a <code>Template</code>-level Histogram metric that tracks an internal value:</p>\\n<pre><code class=\\\"language-yaml\\\">...\\n  templates:\\n    - name: random-int\\n      metrics:\\n        prometheus:\\n          - name: random_int_step_histogram\\n            help: \\\"Value of the int emitted by random-int at step level\\\"\\n            when: \\\"{{status}} == Succeeded\\\"    # Only emit metric when step succeeds\\n            histogram:\\n              buckets:                              # Bins must be defined for histogram metrics\\n                - 2.01                              # and are part of the metric descriptor.\\n                - 4.01                              # All metrics in this series MUST have the\\n                - 6.01                              # same buckets.\\n                - 8.01\\n                - 10.01\\n              value: \\\"{{outputs.parameters.rand-int-value}}\\\"         # References itself for its output (see variables doc)\\n      outputs:\\n        parameters:\\n          - name: rand-int-value\\n            globalName: rand-int-value\\n            valueFrom:\\n              path: /tmp/rand_int.txt\\n      container:\\n        image: alpine:latest\\n        command: [sh, -c]\\n        args: [\\\"RAND_INT=$((1 + RANDOM % 10)); echo $RAND_INT; echo $RAND_INT > /tmp/rand_int.txt\\\"]\\n...\\n</code></pre>\\n<h3 id=\\\"realtime-metrics\\\"><a href=\\\"#realtime-metrics\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Realtime metrics</h3>\\n<p>Argo supports a limited number of real-time metrics. These metrics are emitted in realtime, beginning when the step execution starts\\nand ending when it completes. Realtime metrics are only available on Gauge type metrics and with a <a href=\\\"variables.md#realtime-metrics\\\">limited number of variables</a>.</p>\\n<p>To define a realtime metric simply add <code>realtime: true</code> to a gauge metric with a valid realtime variable. For example:</p>\\n<pre><code class=\\\"language-yaml\\\">  gauge:\\n    realtime: true\\n    value: \\\"{{duration}}\\\"\\n</code></pre>\",\"docPath\":\"argo/metrics\",\"proj\":\"argo\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-metrics-html-b6cb3777048e6fac25aa.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1 id=\\\"prometheus-metrics\\\"><a href=\\\"#prometheus-metrics\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Prometheus Metrics</h1>\\n<p><img src=\\\"/argo/assets/alpha.svg\\\" alt=\\\"alpha\\\"></p>\\n<blockquote>\\n<p>v2.7 and after</p>\\n</blockquote>\\n<h2 id=\\\"introduction\\\"><a href=\\\"#introduction\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Introduction</h2>\\n<p>Custom prometheus metrics can be defined to be emitted on a <code>Workflow</code>- and <code>Template</code>-level basis. These can be useful\\nfor many cases; some examples:</p>\\n<ul>\\n<li>Keeping track of the duration of a <code>Workflow</code> or <code>Template</code> over time, and setting an alert if it goes beyond a threshold</li>\\n<li>Keeping track of the number of times a <code>Workflow</code> or <code>Template</code> fails over time</li>\\n<li>Reporting an important internal metric, such as a model training score or an internal error rate</li>\\n</ul>\\n<p>Emitting custom metrics with Argo is easy, but it's important to understand what makes a good Prometheus metric and the\\nbest way to define metrics in Argo to avoid problems such as <a href=\\\"https://stackoverflow.com/questions/46373442/how-dangerous-are-high-cardinality-labels-in-prometheus\\\">cardinality explosion</a>.</p>\\n<h2 id=\\\"metrics-and-metrics-in-argo\\\"><a href=\\\"#metrics-and-metrics-in-argo\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Metrics and metrics in Argo</h2>\\n<p>Emitting metrics is the responsibility of the emitter owner. Since the user defines Workflows in Argo, the user is responsible\\nfor emitting metrics correctly.</p>\\n<h3 id=\\\"what-is-and-isnt-a-prometheus-metric\\\"><a href=\\\"#what-is-and-isnt-a-prometheus-metric\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>What is and isn't a Prometheus metric</h3>\\n<p>Prometheus metrics should be thought of as ephemeral data points of running processes; i.e., they are the answer to\\nthe question \\\"What is the state of my system <em>right now</em>?\\\". Metrics should report things such as:</p>\\n<ul>\\n<li>a counter of the number of times a workflow or steps has failed, or</li>\\n<li>a gauge of workflow duration, or</li>\\n<li>an average of an internal metric such as a model training score or error rate.</li>\\n</ul>\\n<p>Metrics are then routinely scraped and stored and -- when they are correctly designed -- they can represent time series.\\nAggregating the examples above over time could answer useful questions such as:</p>\\n<ul>\\n<li>How has the error rate of this workflow or step changed over time?</li>\\n<li>How has the duration of this workflow changed over time? Is the current workflow running for too long?</li>\\n<li>Is our model improving over time?</li>\\n</ul>\\n<p>Prometheus metrics should <strong>not</strong> be thought of as a store of data. Since metrics should only report the state of the system\\nat the current time, they should not be used to report historical data such as:</p>\\n<ul>\\n<li>the status of an individual instance of a workflow, or</li>\\n<li>how long a particular instance of a step took to run.</li>\\n</ul>\\n<p>Metrics are also ephemeral, meaning there is no guarantee that they will be persisted for any amount of time. If you need\\na way to view and analyze historical data, consider the <a href=\\\"workflow-archive.html\\\">workflow archive</a> or reporting to logs.</p>\\n<h3 id=\\\"metric-types\\\"><a href=\\\"#metric-types\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Metric types</h3>\\n<p>Please see the <a href=\\\"https://prometheus.io/docs/concepts/metric_types/\\\">Prometheus docs on metric types</a>.</p>\\n<h3 id=\\\"how-metrics-work-in-argo\\\"><a href=\\\"#how-metrics-work-in-argo\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>How metrics work in Argo</h3>\\n<p>In order to analyze the behavior of a workflow over time, we need to be able to link different instances\\n(i.e. individual executions) of a workflow together into a \\\"series\\\" for the purposes of emitting metrics. We do so by linking them together\\nwith the same metric descriptor.</p>\\n<p>In prometheus, a metric descriptor is defined as a metric's name and its key-value labels. For example, for a metric\\ntracking the duration of model execution over time, a metric descriptor could be:</p>\\n<p><code>argo_workflows_model_exec_time{model_name=\\\"model_a\\\",phase=\\\"validation\\\"}</code></p>\\n<p>This metric then represents the amount of time that \\\"Model A\\\" took to train in the phase \\\"Validation\\\". It is important\\nto understand that the metric name <em>and</em> its labels form the descriptor: <code>argo_workflows_model_exec_time{model_name=\\\"model_b\\\",phase=\\\"validation\\\"}</code>\\nis a different metric (and will track a different \\\"series\\\" altogether).</p>\\n<p>Now, whenever we run our first workflow that validates \\\"Model A\\\" a metric with the amount of time it took it to do so will\\nbe created and emitted. For each subsequent time that this happens, no new metrics will be emitted and the <em>same</em> metric\\nwill be updated with the new value. Since, in effect, we are interested on the execution time of \\\"validation\\\" of \\\"Model A\\\"\\nover time, we are no longer interested in the previous metric and can assume it has already been scraped.</p>\\n<p>In summary, whenever you want to track a particular metric over time, you should use the same metric name <em>and</em> metric\\nlabels wherever it is emitted. This is how these metrics are \\\"linked\\\" as belonging to the same series.</p>\\n<h2 id=\\\"defining-metrics\\\"><a href=\\\"#defining-metrics\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Defining metrics</h2>\\n<p>Metrics are defined in-place on the Workflow/Step/Task where they are emitted from. Metrics are always processed <em>after</em>\\nthe Workflow/Step/Task completes, with the exception of <a href=\\\"#realtime-metrics\\\">realtime metrics</a>.</p>\\n<p>Metric definitions <strong>must</strong> include a <code>name</code> and a <code>help</code> doc string. They can also include any number of <code>labels</code> (when\\ndefining labels avoid cardinality explosion).</p>\\n<p>All metrics can also be conditionally emitted by defining a <code>when</code> clause. This <code>when</code> clause works the same as elsewhere\\nin a workflow.</p>\\n<p>A metric must also have a type, it can be one of <code>gauge</code>, <code>histogram</code>, and <code>counter</code> (<a href=\\\"#metric-spec\\\">see below</a>). Within\\nthe metric type a <code>value</code> must be specified. This value can be either a literal value of be an <a href=\\\"variables.html\\\">Argo variable</a>.</p>\\n<p>When defining a <code>histogram</code>, <code>buckets</code> must also be provided (see below).</p>\\n<p><a href=\\\"variables.html\\\">Argo variables</a> can be included anywhere in the metric spec, such as in <code>labels</code>, <code>name</code>, <code>help</code>, <code>when</code>, etc.</p>\\n<h3 id=\\\"metric-spec\\\"><a href=\\\"#metric-spec\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Metric Spec</h3>\\n<p> In Argo you can define a metric on the <code>Workflow</code> level or on the <code>Template</code> level. Here is an example of a <code>Workflow</code>\\nlevel Gauge metric that will report the Workflow duration time:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Workflow\\nmetadata:\\n generateName: model-training-\\nspec:\\n entrypoint: steps\\n metrics:\\n   prometheus:\\n     - name: exec_duration_gauge         # Metric name (will be prepended with \\\"argo_workflows_\\\")\\n       labels:                           # Labels are optional. Avoid cardinality explosion.\\n         - key: name\\n           value: model_a\\n       help: \\\"Duration gauge by name\\\"    # A help doc describing your metric. This is required.\\n       gauge:                            # The metric type. Available are \\\"gauge\\\", \\\"histogram\\\", and \\\"counter\\\".\\n         value: \\\"{{workflow.duration}}\\\"  # The value of your metric. It could be an Argo variable (see variables doc) or a literal value\\n\\n... \\n</code></pre>\\n<p>An example of a <code>Template</code>-level Counter metric that will increase a counter every time the step fails:</p>\\n<pre><code class=\\\"language-yaml\\\">...\\n  templates:\\n    - name: flakey\\n      metrics:\\n        prometheus:\\n          - name: result_counter\\n            help: \\\"Count of step execution by result status\\\"\\n            labels:\\n              - key: name\\n                value: flakey\\n            when: \\\"{{status}} == Failed\\\"       # Emit the metric conditionally. Works the same as normal \\\"when\\\"\\n            counter:\\n              value: \\\"1\\\"                            # This increments the counter by 1\\n      container:\\n        image: python:alpine3.6\\n        command: [\\\"python\\\", -c]\\n        # fail with a 66% probability\\n        args: [\\\"import random; import sys; exit_code = random.choice([0, 1, 1]); sys.exit(exit_code)\\\"]\\n...\\n</code></pre>\\n<p>A similar example of such a Counter metric that will increase for every step status</p>\\n<pre><code class=\\\"language-yaml\\\">...\\n  templates:\\n    - name: flakey\\n      metrics:\\n        prometheus:\\n          - name: result_counter\\n            help: \\\"Count of step execution by result status\\\"\\n            labels:\\n              - key: name\\n                value: flakey\\n              - key: status\\n                value: \\\"{{status}}\\\"    # Argo variable in `labels`\\n            counter:\\n              value: \\\"1\\\"\\n      container:\\n        image: python:alpine3.6\\n        command: [\\\"python\\\", -c]\\n        # fail with a 66% probability\\n        args: [\\\"import random; import sys; exit_code = random.choice([0, 1, 1]); sys.exit(exit_code)\\\"]\\n</code></pre>\\n<p>Finally, an example of a <code>Template</code>-level Histogram metric that tracks an internal value:</p>\\n<pre><code class=\\\"language-yaml\\\">...\\n  templates:\\n    - name: random-int\\n      metrics:\\n        prometheus:\\n          - name: random_int_step_histogram\\n            help: \\\"Value of the int emitted by random-int at step level\\\"\\n            when: \\\"{{status}} == Succeeded\\\"    # Only emit metric when step succeeds\\n            histogram:\\n              buckets:                              # Bins must be defined for histogram metrics\\n                - 2.01                              # and are part of the metric descriptor.\\n                - 4.01                              # All metrics in this series MUST have the\\n                - 6.01                              # same buckets.\\n                - 8.01\\n                - 10.01\\n              value: \\\"{{outputs.parameters.rand-int-value}}\\\"         # References itself for its output (see variables doc)\\n      outputs:\\n        parameters:\\n          - name: rand-int-value\\n            globalName: rand-int-value\\n            valueFrom:\\n              path: /tmp/rand_int.txt\\n      container:\\n        image: alpine:latest\\n        command: [sh, -c]\\n        args: [\\\"RAND_INT=$((1 + RANDOM % 10)); echo $RAND_INT; echo $RAND_INT > /tmp/rand_int.txt\\\"]\\n...\\n</code></pre>\\n<h3 id=\\\"realtime-metrics\\\"><a href=\\\"#realtime-metrics\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Realtime metrics</h3>\\n<p>Argo supports a limited number of real-time metrics. These metrics are emitted in realtime, beginning when the step execution starts\\nand ending when it completes. Realtime metrics are only available on Gauge type metrics and with a <a href=\\\"variables.md#realtime-metrics\\\">limited number of variables</a>.</p>\\n<p>To define a realtime metric simply add <code>realtime: true</code> to a gauge metric with a valid realtime variable. For example:</p>\\n<pre><code class=\\\"language-yaml\\\">  gauge:\\n    realtime: true\\n    value: \\\"{{duration}}\\\"\\n</code></pre>\",\"docPath\":\"argo/metrics\",\"proj\":\"argo\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-metrics-html.json\n// module id = 489\n// module chunks = 83372245247618"],"sourceRoot":""}