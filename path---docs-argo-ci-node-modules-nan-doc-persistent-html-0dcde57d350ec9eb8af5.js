webpackJsonp([0x8c698a39e518],{2914:function(e,n){e.exports={pathContext:{docHtml:'<h2>Persistent references</h2>\n<p>An object reference that is independent of any <code>HandleScope</code> is a <em>persistent</em> reference. Where a <code>Local</code> handle only lives as long as the <code>HandleScope</code> in which it was allocated, a <code>Persistent</code> handle remains valid until it is explicitly disposed.</p>\n<p>Due to the evolution of the V8 API, it is necessary for NAN to provide a wrapper implementation of the <code>Persistent</code> classes to supply compatibility across the V8 versions supported.</p>\n<ul>\n<li><a href="#api_nan_persistent_base"><b><code>Nan::PersistentBase &#x26; v8::PersistentBase</code></b></a></li>\n<li><a href="#api_nan_non_copyable_persistent_traits"><b><code>Nan::NonCopyablePersistentTraits &#x26; v8::NonCopyablePersistentTraits</code></b></a></li>\n<li><a href="#api_nan_copyable_persistent_traits"><b><code>Nan::CopyablePersistentTraits &#x26; v8::CopyablePersistentTraits</code></b></a></li>\n<li><a href="#api_nan_persistent"><b><code>Nan::Persistent</code></b></a></li>\n<li><a href="#api_nan_global"><b><code>Nan::Global</code></b></a></li>\n<li><a href="#api_nan_weak_callback_info"><b><code>Nan::WeakCallbackInfo</code></b></a></li>\n<li><a href="#api_nan_weak_callback_type"><b><code>Nan::WeakCallbackType</code></b></a></li>\n</ul>\n<p>Also see the V8 Embedders Guide section on <a href="https://developers.google.com/v8/embed#handles">Handles and Garbage Collection</a>.</p>\n<p><a name="api_nan_persistent_base"></a></p>\n<h3>Nan::PersistentBase &#x26; v8::PersistentBase</h3>\n<p>A persistent handle contains a reference to a storage cell in V8 which holds an object value and which is updated by the garbage collector whenever the object is moved. A new storage cell can be created using the constructor or <code>Nan::PersistentBase::Reset()</code>. Existing handles can be disposed using an argument-less <code>Nan::PersistentBase::Reset()</code>.</p>\n<p>Definition:</p>\n<p><em>(note: this is implemented as <code>Nan::PersistentBase</code> for older versions of V8 and the native <code>v8::PersistentBase</code> is used for newer versions of V8)</em></p>\n<pre><code class="language-c++">template&#x3C;typename T> class PersistentBase {\n public:\n  /**\n   * If non-empty, destroy the underlying storage cell\n   */\n  void Reset();\n\n  /**\n   * If non-empty, destroy the underlying storage cell and create a new one with\n   * the contents of another if it is also non-empty\n   */\n  template&#x3C;typename S> void Reset(const v8::Local&#x3C;S> &#x26;other);\n\n  /**\n   * If non-empty, destroy the underlying storage cell and create a new one with\n   * the contents of another if it is also non-empty\n   */\n  template&#x3C;typename S> void Reset(const PersistentBase&#x3C;S> &#x26;other);\n\n  /**\n   * If non-empty, destroy the underlying storage cell\n   * IsEmpty() will return true after this call.\n   */\n  bool IsEmpty();\n\n  void Empty();\n\n  template&#x3C;typename S> bool operator==(const PersistentBase&#x3C;S> &#x26;that);\n\n  template&#x3C;typename S> bool operator==(const v8::Local&#x3C;S> &#x26;that);\n\n  template&#x3C;typename S> bool operator!=(const PersistentBase&#x3C;S> &#x26;that);\n\n  template&#x3C;typename S> bool operator!=(const v8::Local&#x3C;S> &#x26;that);\n\n   /**\n   *  Install a finalization callback on this object.\n   *  NOTE: There is no guarantee as to *when* or even *if* the callback is\n   *  invoked. The invocation is performed solely on a best effort basis.\n   *  As always, GC-based finalization should *not* be relied upon for any\n   *  critical form of resource management! At the moment you can either\n   *  specify a parameter for the callback or the location of two internal\n   *  fields in the dying object.\n   */\n  template&#x3C;typename P>\n  void SetWeak(P *parameter,\n               typename WeakCallbackInfo&#x3C;P>::Callback callback,\n               WeakCallbackType type);\n\n  void ClearWeak();\n\n  /**\n   * Marks the reference to this object independent. Garbage collector is free\n   * to ignore any object groups containing this object. Weak callback for an\n   * independent handle should not assume that it will be preceded by a global\n   * GC prologue callback or followed by a global GC epilogue callback.\n   */\n  void MarkIndependent() const;\n\n  bool IsIndependent() const;\n\n  /** Checks if the handle holds the only reference to an object. */\n  bool IsNearDeath() const;\n\n  /** Returns true if the handle\'s reference is weak.  */\n  bool IsWeak() const\n};\n</code></pre>\n<p>See the V8 documentation for <a href="https://v8docs.nodesource.com/io.js-3.3/d4/dca/classv8_1_1_persistent_base.html"><code>PersistentBase</code></a> for further information.</p>\n<p><strong>Tip:</strong> To get a <code>v8::Local</code> reference to the original object back from a <code>PersistentBase</code> or <code>Persistent</code> object:</p>\n<pre><code class="language-c++">v8::Local&#x3C;v8::Object> object = Nan::New(persistent);\n</code></pre>\n<p><a name="api_nan_non_copyable_persistent_traits"></a></p>\n<h3>Nan::NonCopyablePersistentTraits &#x26; v8::NonCopyablePersistentTraits</h3>\n<p>Default traits for <code>Nan::Persistent</code>. This class does not allow use of the a copy constructor or assignment operator. At present <code>kResetInDestructor</code> is not set, but that will change in a future version.</p>\n<p>Definition:</p>\n<p><em>(note: this is implemented as <code>Nan::NonCopyablePersistentTraits</code> for older versions of V8 and the native <code>v8::NonCopyablePersistentTraits</code> is used for newer versions of V8)</em></p>\n<pre><code class="language-c++">template&#x3C;typename T> class NonCopyablePersistentTraits {\n public:\n  typedef Persistent&#x3C;T, NonCopyablePersistentTraits&#x3C;T> > NonCopyablePersistent;\n\n  static const bool kResetInDestructor = false;\n\n  template&#x3C;typename S, typename M>\n  static void Copy(const Persistent&#x3C;S, M> &#x26;source,\n                   NonCopyablePersistent *dest);\n\n  template&#x3C;typename O> static void Uncompilable();\n};\n</code></pre>\n<p>See the V8 documentation for <a href="https://v8docs.nodesource.com/io.js-3.3/de/d73/classv8_1_1_non_copyable_persistent_traits.html"><code>NonCopyablePersistentTraits</code></a> for further information.</p>\n<p><a name="api_nan_copyable_persistent_traits"></a></p>\n<h3>Nan::CopyablePersistentTraits &#x26; v8::CopyablePersistentTraits</h3>\n<p>A helper class of traits to allow copying and assignment of <code>Persistent</code>. This will clone the contents of storage cell, but not any of the flags, etc..</p>\n<p>Definition:</p>\n<p><em>(note: this is implemented as <code>Nan::CopyablePersistentTraits</code> for older versions of V8 and the native <code>v8::NonCopyablePersistentTraits</code> is used for newer versions of V8)</em></p>\n<pre><code class="language-c++">template&#x3C;typename T>\nclass CopyablePersistentTraits {\n public:\n  typedef Persistent&#x3C;T, CopyablePersistentTraits&#x3C;T> > CopyablePersistent;\n\n  static const bool kResetInDestructor = true;\n\n  template&#x3C;typename S, typename M>\n  static void Copy(const Persistent&#x3C;S, M> &#x26;source,\n                   CopyablePersistent *dest);\n};\n</code></pre>\n<p>See the V8 documentation for <a href="https://v8docs.nodesource.com/io.js-3.3/da/d5c/structv8_1_1_copyable_persistent_traits.html"><code>CopyablePersistentTraits</code></a> for further information.</p>\n<p><a name="api_nan_persistent"></a></p>\n<h3>Nan::Persistent</h3>\n<p>A type of <code>PersistentBase</code> which allows copy and assignment. Copy, assignment and destructor behavior is controlled by the traits class <code>M</code>.</p>\n<p>Definition:</p>\n<pre><code class="language-c++">template&#x3C;typename T, typename M = NonCopyablePersistentTraits&#x3C;T> >\nclass Persistent;\n\ntemplate&#x3C;typename T, typename M> class Persistent : public PersistentBase&#x3C;T> {\n public:\n /**\n  * A Persistent with no storage cell.\n  */\n  Persistent();\n\n  /**\n   * Construct a Persistent from a v8::Local. When the v8::Local is non-empty, a\n   * new storage cell is created pointing to the same object, and no flags are\n   * set.\n   */\n  template&#x3C;typename S> Persistent(v8::Local&#x3C;S> that);\n\n  /**\n   * Construct a Persistent from a Persistent. When the Persistent is non-empty,\n   * a new storage cell is created pointing to the same object, and no flags are\n   * set.\n   */\n  Persistent(const Persistent &#x26;that);\n\n  /**\n   * The copy constructors and assignment operator create a Persistent exactly\n   * as the Persistent constructor, but the Copy function from the traits class\n   * is called, allowing the setting of flags based on the copied Persistent.\n   */\n  Persistent &#x26;operator=(const Persistent &#x26;that);\n\n  template &#x3C;typename S, typename M2>\n  Persistent &#x26;operator=(const Persistent&#x3C;S, M2> &#x26;that);\n\n  /**\n   * The destructor will dispose the Persistent based on the kResetInDestructor\n   * flags in the traits class.  Since not calling dispose can result in a\n   * memory leak, it is recommended to always set this flag.\n   */\n  ~Persistent();\n};\n</code></pre>\n<p>See the V8 documentation for <a href="https://v8docs.nodesource.com/io.js-3.3/d2/d78/classv8_1_1_persistent.html"><code>Persistent</code></a> for further information.</p>\n<p><a name="api_nan_global"></a></p>\n<h3>Nan::Global</h3>\n<p>A type of <code>PersistentBase</code> which has move semantics.</p>\n<pre><code class="language-c++">template&#x3C;typename T> class Global : public PersistentBase&#x3C;T> {\n public:\n  /**\n   * A Global with no storage cell.\n   */\n  Global();\n\n  /**\n   * Construct a Global from a v8::Local. When the v8::Local is non-empty, a new\n   * storage cell is created pointing to the same object, and no flags are set.\n   */\n  template&#x3C;typename S> Global(v8::Local&#x3C;S> that);\n  /**\n   * Construct a Global from a PersistentBase. When the Persistent is non-empty,\n   * a new storage cell is created pointing to the same object, and no flags are\n   * set.\n   */\n  template&#x3C;typename S> Global(const PersistentBase&#x3C;S> &#x26;that);\n\n  /**\n   * Pass allows returning globals from functions, etc.\n   */\n  Global Pass();\n};\n</code></pre>\n<p>See the V8 documentation for <a href="https://v8docs.nodesource.com/io.js-3.3/d5/d40/classv8_1_1_global.html"><code>Global</code></a> for further information.</p>\n<p><a name="api_nan_weak_callback_info"></a></p>\n<h3>Nan::WeakCallbackInfo</h3>\n<p><code>Nan::WeakCallbackInfo</code> is used as an argument when setting a persistent reference as weak. You may need to free any external resources attached to the object. It is a mirror of <code>v8:WeakCallbackInfo</code> as found in newer versions of V8.</p>\n<p>Definition:</p>\n<pre><code class="language-c++">template&#x3C;typename T> class WeakCallbackInfo {\n public:\n  typedef void (*Callback)(const WeakCallbackInfo&#x3C;T>&#x26; data);\n\n  v8::Isolate *GetIsolate() const;\n\n  /**\n   * Get the parameter that was associated with the weak handle.\n   */\n  T *GetParameter() const;\n\n  /**\n   * Get pointer from internal field, index can be 0 or 1.\n   */\n  void *GetInternalField(int index) const;\n};\n</code></pre>\n<p>Example usage:</p>\n<pre><code class="language-c++">void weakCallback(const WeakCallbackInfo&#x3C;int> &#x26;data) {\n  int *parameter = data.GetParameter();\n  delete parameter;\n}\n\nPersistent&#x3C;v8::Object> obj;\nint *data = new int(0);\nobj.SetWeak(data, callback, WeakCallbackType::kParameter);\n</code></pre>\n<p>See the V8 documentation for <a href="https://v8docs.nodesource.com/io.js-3.3/d8/d06/classv8_1_1_weak_callback_info.html"><code>WeakCallbackInfo</code></a> for further information.</p>\n<p><a name="api_nan_weak_callback_type"></a></p>\n<h3>Nan::WeakCallbackType</h3>\n<p>Represents the type of a weak callback.\nA weak callback of type <code>kParameter</code> makes the supplied parameter to <code>Nan::PersistentBase::SetWeak</code> available through <code>WeakCallbackInfo::GetParameter</code>.\nA weak callback of type <code>kInternalFields</code> uses up to two internal fields at indices 0 and 1 on the <code>Nan::PersistentBase&#x3C;v8::Object></code> being made weak.\nNote that only <code>v8::Object</code>s and derivatives can have internal fields.</p>\n<p>Definition:</p>\n<pre><code class="language-c++">enum class WeakCallbackType { kParameter, kInternalFields };\n</code></pre>',docPath:"argo-ci/node_modules/nan/doc/persistent",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-nan-doc-persistent-html-0dcde57d350ec9eb8af5.js.map