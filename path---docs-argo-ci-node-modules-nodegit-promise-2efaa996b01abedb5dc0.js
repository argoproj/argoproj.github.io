webpackJsonp([0x86db6347e8a7],{2963:function(e,s){e.exports={pathContext:{docHtml:'<p><a href="https://promisesaplus.com/"><img src="https://promisesaplus.com/assets/logo-small.png" align="right"></a></p>\n<h1>promise</h1>\n<p>This is a simple implementation of Promises.  It is a super set of ES6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.</p>\n<p>For detailed tutorials on its use, see www.promisejs.org</p>\n<p><strong>N.B.</strong> This promise exposes internals via underscore (<code>_</code>) prefixed properties.  If you use these, your code will break with each new release.</p>\n<p><a href="https://travis-ci.org/then/promise"><img src="https://img.shields.io/travis/then/promise.svg?style=flat" alt="travis"></a>\n<a href="https://gemnasium.com/then/promise"><img src="https://img.shields.io/gemnasium/then/promise.svg?style=flat" alt="dep"></a>\n<a href="https://npmjs.org/package/promise"><img src="https://img.shields.io/npm/v/promise.svg?style=flat" alt="npm"></a>\n<a href="https://npmjs.org/package/promise"><img src="https://img.shields.io/npm/dm/promise.svg?style=flat" alt="downloads"></a></p>\n<h2>Installation</h2>\n<p><strong>Server:</strong></p>\n<pre><code>$ npm install promise\n</code></pre>\n<p><strong>Client:</strong></p>\n<p>You can use browserify on the client, or use the pre-compiled script that acts as a polyfill.</p>\n<pre><code class="language-html">&#x3C;script src="https://www.promisejs.org/polyfills/promise-6.1.0.js">&#x3C;/script>\n</code></pre>\n<p>Note that the <a href="https://github.com/es-shims/es5-shim">es5-shim</a> must be loaded before this library to support browsers pre IE9.</p>\n<pre><code class="language-html">&#x3C;script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-shim.min.js">&#x3C;/script>\n</code></pre>\n<h2>Usage</h2>\n<p>The example below shows how you can load the promise library (in a way that works on both client and server using node or browserify).  It then demonstrates creating a promise from scratch.  You simply call <code>new Promise(fn)</code>.  There is a complete specification for what is returned by this method in <a href="http://promises-aplus.github.com/promises-spec/">Promises/A+</a>.</p>\n<pre><code class="language-javascript">var Promise = require(\'promise\');\n\nvar promise = new Promise(function (resolve, reject) {\n  get(\'http://www.google.com\', function (err, res) {\n    if (err) reject(err);\n    else resolve(res);\n  });\n});\n</code></pre>\n<p>If you need <a href="https://iojs.org/api/domain.html">domains</a> support, you should instead use:</p>\n<pre><code class="language-js">var Promise = require(\'promise/domains\');\n</code></pre>\n<p>If you are in an environment that implements <code>setImmediate</code> and don\'t want the optimisations provided by asap, you can use:</p>\n<pre><code class="language-js">var Promise = require(\'promise/setimmediate\');\n</code></pre>\n<p>If you only want part of the features, e.g. just a pure ES6 polyfill:</p>\n<pre><code class="language-js">var Promise = require(\'promise/lib/es6-extensions\');\n// or require(\'promise/domains/es6-extensions\');\n// or require(\'promise/setimmediate/es6-extensions\');\n</code></pre>\n<h2>API</h2>\n<p>Before all examples, you will need:</p>\n<pre><code class="language-js">var Promise = require(\'promise\');\n</code></pre>\n<h3>new Promise(resolver)</h3>\n<p>This creates and returns a new promise.  <code>resolver</code> must be a function.  The <code>resolver</code> function is passed two arguments:</p>\n<ol>\n<li><code>resolve</code> should be called with a single argument.  If it is called with a non-promise value then the promise is fulfilled with that value.  If it is called with a promise (A) then the returned promise takes on the state of that new promise (A).</li>\n<li><code>reject</code> should be called with a single argument.  The returned promise will be rejected with that argument.</li>\n</ol>\n<h3>Static Functions</h3>\n<p>  These methods are invoked by calling <code>Promise.methodName</code>.</p>\n<h4>Promise.resolve(value)</h4>\n<p>(deprecated aliases: <code>Promise.from(value)</code>, <code>Promise.cast(value)</code>)</p>\n<p>Converts values and foreign promises into Promises/A+ promises.  If you pass it a value then it returns a Promise for that value.  If you pass it something that is close to a promise (such as a jQuery attempt at a promise) it returns a Promise that takes on the state of <code>value</code> (rejected or fulfilled).</p>\n<h4>Promise.reject(value)</h4>\n<p>Returns a rejected promise with the given value.</p>\n<h4>Promise.all(array)</h4>\n<p>Returns a promise for an array.  If it is called with a single argument that <code>Array.isArray</code> then this returns a promise for a copy of that array with any promises replaced by their fulfilled values.  e.g.</p>\n<pre><code class="language-js">Promise.all([Promise.resolve(\'a\'), \'b\', Promise.resolve(\'c\')])\n  .then(function (res) {\n    assert(res[0] === \'a\')\n    assert(res[1] === \'b\')\n    assert(res[2] === \'c\')\n  })\n</code></pre>\n<h4>Promise.denodeify(fn)</h4>\n<p><em>Non Standard</em></p>\n<p>Takes a function which accepts a node style callback and returns a new function that returns a promise instead.</p>\n<p>e.g.</p>\n<pre><code class="language-javascript">var fs = require(\'fs\')\n\nvar read = Promise.denodeify(fs.readFile)\nvar write = Promise.denodeify(fs.writeFile)\n\nvar p = read(\'foo.json\', \'utf8\')\n  .then(function (str) {\n    return write(\'foo.json\', JSON.stringify(JSON.parse(str), null, \'  \'), \'utf8\')\n  })\n</code></pre>\n<h4>Promise.nodeify(fn)</h4>\n<p><em>Non Standard</em></p>\n<p>The twin to <code>denodeify</code> is useful when you want to export an API that can be used by people who haven\'t learnt about the brilliance of promises yet.</p>\n<pre><code class="language-javascript">module.exports = Promise.nodeify(awesomeAPI)\nfunction awesomeAPI(a, b) {\n  return download(a, b)\n}\n</code></pre>\n<p>If the last argument passed to <code>module.exports</code> is a function, then it will be treated like a node.js callback and not parsed on to the child function, otherwise the API will just return a promise.</p>\n<h3>Prototype Methods</h3>\n<p>These methods are invoked on a promise instance by calling <code>myPromise.methodName</code></p>\n<h3>Promise#then(onFulfilled, onRejected)</h3>\n<p>This method follows the <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ spec</a>.  It explains things very clearly so I recommend you read it.</p>\n<p>Either <code>onFulfilled</code> or <code>onRejected</code> will be called and they will not be called more than once.  They will be passed a single argument and will always be called asynchronously (in the next turn of the event loop).</p>\n<p>If the promise is fulfilled then <code>onFulfilled</code> is called.  If the promise is rejected then <code>onRejected</code> is called.</p>\n<p>The call to <code>.then</code> also returns a promise.  If the handler that is called returns a promise, the promise returned by <code>.then</code> takes on the state of that returned promise.  If the handler that is called returns a value that is not a promise, the promise returned by <code>.then</code> will be fulfilled with that value. If the handler that is called throws an exception then the promise returned by <code>.then</code> is rejected with that exception.</p>\n<h4>Promise#catch(onRejected)</h4>\n<p>Sugar for <code>Promise#then(null, onRejected)</code>, to mirror <code>catch</code> in synchronous code.</p>\n<h4>Promise#done(onFulfilled, onRejected)</h4>\n<p><em>Non Standard</em></p>\n<p>The same semantics as <code>.then</code> except that it does not return a promise and any exceptions are re-thrown so that they can be logged (crashing the application in non-browser environments)</p>\n<h4>Promise#nodeify(callback)</h4>\n<p><em>Non Standard</em></p>\n<p>If <code>callback</code> is <code>null</code> or <code>undefined</code> it just returns <code>this</code>.  If <code>callback</code> is a function it is called with rejection reason as the first argument and result as the second argument (as per the node.js convention).</p>\n<p>This lets you write API functions that look like:</p>\n<pre><code class="language-javascript">function awesomeAPI(foo, bar, callback) {\n  return internalAPI(foo, bar)\n    .then(parseResult)\n    .then(null, retryErrors)\n    .nodeify(callback)\n}\n</code></pre>\n<p>People who use typical node.js style callbacks will be able to just pass a callback and get the expected behavior.  The enlightened people can not pass a callback and will get awesome promises.</p>\n<h2>License</h2>\n<p>  MIT</p>',docPath:"argo-ci/node_modules/nodegit-promise/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-nodegit-promise-2efaa996b01abedb5dc0.js.map