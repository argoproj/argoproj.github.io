{"version":3,"sources":["webpack:///path---docs-argo-cd-docs-security-html-9b4e1abf87be1b644602.js","webpack:///./.cache/json/docs-argo-cd-docs-security-html.json"],"names":["webpackJsonp","558","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,qiTAA43JC,QAAA,wBAAAC,KAAA","file":"path---docs-argo-cd-docs-security-html-9b4e1abf87be1b644602.js","sourcesContent":["webpackJsonp([51517102593698],{\n\n/***/ 558:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>Security</h1>\\n<p>Argo CD has undergone rigourous internal security reviews and penetration testing to satisfy <a href=\\\"https://www.pcisecuritystandards.org\\\">PCI\\ncompliance</a> requirements. The following are some security\\ntopics and implementation details of Argo CD.</p>\\n<h2>Authentication</h2>\\n<p>Authentication to Argo CD API server is performed exclusively using <a href=\\\"https://jwt.io\\\">JSON Web Tokens</a>\\n(JWTs). Username/password bearer tokens are not used for authentication. The JWT is obtained/managed\\nin one of the following ways:</p>\\n<ol>\\n<li>\\n<p>For the local <code>admin</code> user, a username/password is exchanged for a JWT using the <code>/api/v1/session</code>\\nendpoint. This token is signed &#x26; issued by the Argo CD API server itself, and has no expiration.\\nWhen the admin password is updated, all existing admin JWT tokens are immediately revoked.\\nThe password is stored as a bcrypt hash in the <a href=\\\"../manifests/base/argocd-secret.yaml\\\"><code>argocd-secret</code></a> Secret.</p>\\n</li>\\n<li>\\n<p>For Single Sign-On users, the user completes an OAuth2 login flow to the configured OIDC identity\\nprovider (either delegated through the bundled Dex provider, or directly to a self-managed OIDC\\nprovider). This JWT is signed &#x26; issued by the IDP, and expiration and revokation is handled by\\nthe provider. Dex tokens expire after 24 hours.</p>\\n</li>\\n<li>\\n<p>Automation tokens are generated for a project using the <code>/api/v1/projects/{project}/roles/{role}/token</code>\\nendpoint, and are signed &#x26; issued by Argo CD. These tokens are limited in scope and privilege,\\nand can only be used to manage application resources in the project which it belongs to. Project\\nJWTs have a configurable expiration and can be immediately revoked by deleting the JWT reference\\nID from the project role.</p>\\n</li>\\n</ol>\\n<h2>Authorization</h2>\\n<p>Authorization is performed by iterating the list of group membership in a user's JWT groups claims,\\nand comparing each group against the roles/rules in the <a href=\\\"rbac.html\\\">RBAC</a> policy. Any matched rule\\npermits access to the API request.</p>\\n<h2>TLS</h2>\\n<p>All network communication is performed over TLS including service-to-service communication between\\nthe three components (argocd-server, argocd-repo-server, argocd-application-controller). The Argo CD\\nAPI server can enforce the use of TLS 1.2 using the flag: <code>--tlsminversion 1.2</code>.</p>\\n<h2>Sensitive Information</h2>\\n<h3>Secrets</h3>\\n<p>Argo CD never returns sensitive data from its API, and redacts all sensitive data in API payloads\\nand logs. This includes:</p>\\n<ul>\\n<li>cluster credentials</li>\\n<li>git credentials</li>\\n<li>OAuth2 client secrets</li>\\n<li>Kubernetes Secret values</li>\\n</ul>\\n<h3>External Cluster Credentials</h3>\\n<p>To manage external clusters, Argo CD stores the credentials of the external cluster as a Kubernetes\\nSecret in the argocd namespace. This secret contains the K8s API bearer token associated with the\\n<code>argocd-manager</code> ServiceAccount created during <code>argocd cluster add</code>, along with connection options\\nto that API server (TLS configuration/certs, aws-iam-authenticator RoleARN, etc...).\\nThe information is used to reconstruct a REST config and kubeconfig to the cluster used by Argo CD\\nservices.</p>\\n<p>To rotate the bearer token used by Argo CD, the token can be deleted (e.g. using kubectl) which\\ncauses kuberentes to generate a new secret with a new bearer token. The new token can be re-inputted\\nto Argo CD by re-running <code>argocd cluster add</code>. Run the following commands against the <em><em>managed</em></em>\\ncluster:</p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig for the externally managed cluster\\nkubectl delete secret argocd-manager-token-XXXXXX -n kube-system\\nargocd cluster add CONTEXTNAME\\n</code></pre>\\n<p>To revoke Argo CD's access to a managed cluster, delete the RBAC artifacts against the <em><em>managed</em></em>\\ncluster, and remove the cluster entry from Argo CD:</p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig for the externally managed cluster\\nkubectl delete sa argocd-manager -n kube-system \\nkubectl delete clusterrole argocd-manager-role\\nkubectl delete clusterrolebinding argocd-manager-role-binding\\nargocd cluster rm https://your-kubernetes-cluster-addr\\n</code></pre>\\n<blockquote>\\n<p>NOTE: for AWS EKS clusters, <a href=\\\"https://github.com/kubernetes-sigs/aws-iam-authenticator\\\">aws-iam-authenticator</a>\\nis used to authenticate to the external cluster, which uses IAM roles in lieu of locally stored\\ntokens, so token rotation is not needed, and revokation is handled through IAM.</p>\\n</blockquote>\\n<h2>Cluster RBAC</h2>\\n<p>By default, Argo CD uses a <a href=\\\"../manifests/cluster-install/application-controller/argocd-application-controller-clusterrole.yaml\\\">clusteradmin level role</a>\\nin order to:</p>\\n<ol>\\n<li>watch &#x26; operate on cluster state</li>\\n<li>deploy resources to the cluster</li>\\n</ol>\\n<p>Although Argo CD requires cluster-wide <strong><em>read</em></strong> privileges to resources in the managed cluster to\\nfunction properly, it does not necessarily need full <strong><em>write</em></strong> privileges to the cluster. The\\nClusterRole used by argocd-server and argocd-application-controller can be modified such\\nthat write privileges are limited to only the namespaces and resources that you wish Argo CD to\\nmanage.</p>\\n<p>To fine-tune privileges of externally managed clusters, edit the ClusterRole of the <code>argocd-manager-role</code></p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig for the externally managed cluster\\nkubectl edit clusterrole argocd-manager-role\\n</code></pre>\\n<p>To fine-tune privileges which Argo CD has against its own cluster (i.e. <a href=\\\"https://kubernetes.default.svc\\\">https://kubernetes.default.svc</a>),\\nedit the following cluster roles where Argo CD is running in:</p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig to the cluster Argo CD is running in\\nkubectl edit clusterrole argocd-server\\nkubectl edit clusterrole argocd-application-controller\\n</code></pre>\\n<p>Note:</p>\\n<ul>\\n<li>If you to deny ArgoCD access to a kind of resource then add it as an <a href=\\\"declarative-setup.md#resource-exclusion\\\">excluded resource</a>. </li>\\n</ul>\\n<h2>Auditing</h2>\\n<p>As a GitOps deployment tool, the git commit history provides a natural audit log of what changes\\nwere made to application configuration, when they were made, and by whom. However, this audit log\\nonly applies to what happened in git and does not necessarily correlate one-to-one with events\\nthat happen in a cluster. For example, User A could have made multiple commits to application\\nmanifests, but User B could have just only synced those changes to the cluster sometime later.</p>\\n<p>To complement the git revision history, Argo CD emits Kubernetes Events of application activity,\\nindicating the responsible actor when applicable. For example:</p>\\n<pre><code class=\\\"language-bash\\\">$ kubectl get events\\nLAST SEEN   FIRST SEEN   COUNT   NAME                         KIND          SUBOBJECT   TYPE      REASON               SOURCE                          MESSAGE\\n1m          1m           1       guestbook.157f7c5edd33aeac   Application               Normal    ResourceCreated      argocd-server                   admin created application\\n1m          1m           1       guestbook.157f7c5f0f747acf   Application               Normal    ResourceUpdated      argocd-application-controller   Updated sync status:  -> OutOfSync\\n1m          1m           1       guestbook.157f7c5f0fbebbff   Application               Normal    ResourceUpdated      argocd-application-controller   Updated health status:  -> Missing\\n1m          1m           1       guestbook.157f7c6069e14f4d   Application               Normal    OperationStarted     argocd-server                   admin initiated sync to HEAD (8a1cb4a02d3538e54907c827352f66f20c3d7b0d)\\n1m          1m           1       guestbook.157f7c60a55a81a8   Application               Normal    OperationCompleted   argocd-application-controller   Sync operation to 8a1cb4a02d3538e54907c827352f66f20c3d7b0d succeeded\\n1m          1m           1       guestbook.157f7c60af1ccae2   Application               Normal    ResourceUpdated      argocd-application-controller   Updated sync status: OutOfSync -> Synced\\n1m          1m           1       guestbook.157f7c60af5bc4f0   Application               Normal    ResourceUpdated      argocd-application-controller   Updated health status: Missing -> Progressing\\n1m          1m           1       guestbook.157f7c651990e848   Application               Normal    ResourceUpdated      argocd-application-controller   Updated health status: Progressing -> Healthy\\n</code></pre>\\n<p>These events can be then be persisted for longer periods of time using other tools as\\n<a href=\\\"https://github.com/GoogleCloudPlatform/k8s-stackdriver/tree/master/event-exporter\\\">Event Exporter</a> or\\n<a href=\\\"https://github.com/heptiolabs/eventrouter\\\">Event Router</a>.</p>\\n<h2>WebHook Payloads</h2>\\n<p>Payloads from webhook events are considered untrusted. Argo CD only examines the payload to infer\\nthe involved applications of the webhook event (e.g. which repo was modified), then refreshes\\nthe related application for reconciliation. This refresh is the same refresh which occurs regularly\\nat three minute intervals, just fast-tracked by the webhook event.</p>\\n<h2>Reporting Vulnerabilities</h2>\\n<p>Please report security vulnerabilities by e-mailing:</p>\\n<ul>\\n<li>Jesse_Suen@intuit.com</li>\\n<li>Alexander_Matyushentsev@intuit.com</li>\\n<li>Edward_Lee@intuit.com</li>\\n</ul>\",\"docPath\":\"argo-cd/docs/security\",\"proj\":\"argo-cd\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-cd-docs-security-html-9b4e1abf87be1b644602.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>Security</h1>\\n<p>Argo CD has undergone rigourous internal security reviews and penetration testing to satisfy <a href=\\\"https://www.pcisecuritystandards.org\\\">PCI\\ncompliance</a> requirements. The following are some security\\ntopics and implementation details of Argo CD.</p>\\n<h2>Authentication</h2>\\n<p>Authentication to Argo CD API server is performed exclusively using <a href=\\\"https://jwt.io\\\">JSON Web Tokens</a>\\n(JWTs). Username/password bearer tokens are not used for authentication. The JWT is obtained/managed\\nin one of the following ways:</p>\\n<ol>\\n<li>\\n<p>For the local <code>admin</code> user, a username/password is exchanged for a JWT using the <code>/api/v1/session</code>\\nendpoint. This token is signed &#x26; issued by the Argo CD API server itself, and has no expiration.\\nWhen the admin password is updated, all existing admin JWT tokens are immediately revoked.\\nThe password is stored as a bcrypt hash in the <a href=\\\"../manifests/base/argocd-secret.yaml\\\"><code>argocd-secret</code></a> Secret.</p>\\n</li>\\n<li>\\n<p>For Single Sign-On users, the user completes an OAuth2 login flow to the configured OIDC identity\\nprovider (either delegated through the bundled Dex provider, or directly to a self-managed OIDC\\nprovider). This JWT is signed &#x26; issued by the IDP, and expiration and revokation is handled by\\nthe provider. Dex tokens expire after 24 hours.</p>\\n</li>\\n<li>\\n<p>Automation tokens are generated for a project using the <code>/api/v1/projects/{project}/roles/{role}/token</code>\\nendpoint, and are signed &#x26; issued by Argo CD. These tokens are limited in scope and privilege,\\nand can only be used to manage application resources in the project which it belongs to. Project\\nJWTs have a configurable expiration and can be immediately revoked by deleting the JWT reference\\nID from the project role.</p>\\n</li>\\n</ol>\\n<h2>Authorization</h2>\\n<p>Authorization is performed by iterating the list of group membership in a user's JWT groups claims,\\nand comparing each group against the roles/rules in the <a href=\\\"rbac.html\\\">RBAC</a> policy. Any matched rule\\npermits access to the API request.</p>\\n<h2>TLS</h2>\\n<p>All network communication is performed over TLS including service-to-service communication between\\nthe three components (argocd-server, argocd-repo-server, argocd-application-controller). The Argo CD\\nAPI server can enforce the use of TLS 1.2 using the flag: <code>--tlsminversion 1.2</code>.</p>\\n<h2>Sensitive Information</h2>\\n<h3>Secrets</h3>\\n<p>Argo CD never returns sensitive data from its API, and redacts all sensitive data in API payloads\\nand logs. This includes:</p>\\n<ul>\\n<li>cluster credentials</li>\\n<li>git credentials</li>\\n<li>OAuth2 client secrets</li>\\n<li>Kubernetes Secret values</li>\\n</ul>\\n<h3>External Cluster Credentials</h3>\\n<p>To manage external clusters, Argo CD stores the credentials of the external cluster as a Kubernetes\\nSecret in the argocd namespace. This secret contains the K8s API bearer token associated with the\\n<code>argocd-manager</code> ServiceAccount created during <code>argocd cluster add</code>, along with connection options\\nto that API server (TLS configuration/certs, aws-iam-authenticator RoleARN, etc...).\\nThe information is used to reconstruct a REST config and kubeconfig to the cluster used by Argo CD\\nservices.</p>\\n<p>To rotate the bearer token used by Argo CD, the token can be deleted (e.g. using kubectl) which\\ncauses kuberentes to generate a new secret with a new bearer token. The new token can be re-inputted\\nto Argo CD by re-running <code>argocd cluster add</code>. Run the following commands against the <em><em>managed</em></em>\\ncluster:</p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig for the externally managed cluster\\nkubectl delete secret argocd-manager-token-XXXXXX -n kube-system\\nargocd cluster add CONTEXTNAME\\n</code></pre>\\n<p>To revoke Argo CD's access to a managed cluster, delete the RBAC artifacts against the <em><em>managed</em></em>\\ncluster, and remove the cluster entry from Argo CD:</p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig for the externally managed cluster\\nkubectl delete sa argocd-manager -n kube-system \\nkubectl delete clusterrole argocd-manager-role\\nkubectl delete clusterrolebinding argocd-manager-role-binding\\nargocd cluster rm https://your-kubernetes-cluster-addr\\n</code></pre>\\n<blockquote>\\n<p>NOTE: for AWS EKS clusters, <a href=\\\"https://github.com/kubernetes-sigs/aws-iam-authenticator\\\">aws-iam-authenticator</a>\\nis used to authenticate to the external cluster, which uses IAM roles in lieu of locally stored\\ntokens, so token rotation is not needed, and revokation is handled through IAM.</p>\\n</blockquote>\\n<h2>Cluster RBAC</h2>\\n<p>By default, Argo CD uses a <a href=\\\"../manifests/cluster-install/application-controller/argocd-application-controller-clusterrole.yaml\\\">clusteradmin level role</a>\\nin order to:</p>\\n<ol>\\n<li>watch &#x26; operate on cluster state</li>\\n<li>deploy resources to the cluster</li>\\n</ol>\\n<p>Although Argo CD requires cluster-wide <strong><em>read</em></strong> privileges to resources in the managed cluster to\\nfunction properly, it does not necessarily need full <strong><em>write</em></strong> privileges to the cluster. The\\nClusterRole used by argocd-server and argocd-application-controller can be modified such\\nthat write privileges are limited to only the namespaces and resources that you wish Argo CD to\\nmanage.</p>\\n<p>To fine-tune privileges of externally managed clusters, edit the ClusterRole of the <code>argocd-manager-role</code></p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig for the externally managed cluster\\nkubectl edit clusterrole argocd-manager-role\\n</code></pre>\\n<p>To fine-tune privileges which Argo CD has against its own cluster (i.e. <a href=\\\"https://kubernetes.default.svc\\\">https://kubernetes.default.svc</a>),\\nedit the following cluster roles where Argo CD is running in:</p>\\n<pre><code class=\\\"language-bash\\\"># run using a kubeconfig to the cluster Argo CD is running in\\nkubectl edit clusterrole argocd-server\\nkubectl edit clusterrole argocd-application-controller\\n</code></pre>\\n<p>Note:</p>\\n<ul>\\n<li>If you to deny ArgoCD access to a kind of resource then add it as an <a href=\\\"declarative-setup.md#resource-exclusion\\\">excluded resource</a>. </li>\\n</ul>\\n<h2>Auditing</h2>\\n<p>As a GitOps deployment tool, the git commit history provides a natural audit log of what changes\\nwere made to application configuration, when they were made, and by whom. However, this audit log\\nonly applies to what happened in git and does not necessarily correlate one-to-one with events\\nthat happen in a cluster. For example, User A could have made multiple commits to application\\nmanifests, but User B could have just only synced those changes to the cluster sometime later.</p>\\n<p>To complement the git revision history, Argo CD emits Kubernetes Events of application activity,\\nindicating the responsible actor when applicable. For example:</p>\\n<pre><code class=\\\"language-bash\\\">$ kubectl get events\\nLAST SEEN   FIRST SEEN   COUNT   NAME                         KIND          SUBOBJECT   TYPE      REASON               SOURCE                          MESSAGE\\n1m          1m           1       guestbook.157f7c5edd33aeac   Application               Normal    ResourceCreated      argocd-server                   admin created application\\n1m          1m           1       guestbook.157f7c5f0f747acf   Application               Normal    ResourceUpdated      argocd-application-controller   Updated sync status:  -> OutOfSync\\n1m          1m           1       guestbook.157f7c5f0fbebbff   Application               Normal    ResourceUpdated      argocd-application-controller   Updated health status:  -> Missing\\n1m          1m           1       guestbook.157f7c6069e14f4d   Application               Normal    OperationStarted     argocd-server                   admin initiated sync to HEAD (8a1cb4a02d3538e54907c827352f66f20c3d7b0d)\\n1m          1m           1       guestbook.157f7c60a55a81a8   Application               Normal    OperationCompleted   argocd-application-controller   Sync operation to 8a1cb4a02d3538e54907c827352f66f20c3d7b0d succeeded\\n1m          1m           1       guestbook.157f7c60af1ccae2   Application               Normal    ResourceUpdated      argocd-application-controller   Updated sync status: OutOfSync -> Synced\\n1m          1m           1       guestbook.157f7c60af5bc4f0   Application               Normal    ResourceUpdated      argocd-application-controller   Updated health status: Missing -> Progressing\\n1m          1m           1       guestbook.157f7c651990e848   Application               Normal    ResourceUpdated      argocd-application-controller   Updated health status: Progressing -> Healthy\\n</code></pre>\\n<p>These events can be then be persisted for longer periods of time using other tools as\\n<a href=\\\"https://github.com/GoogleCloudPlatform/k8s-stackdriver/tree/master/event-exporter\\\">Event Exporter</a> or\\n<a href=\\\"https://github.com/heptiolabs/eventrouter\\\">Event Router</a>.</p>\\n<h2>WebHook Payloads</h2>\\n<p>Payloads from webhook events are considered untrusted. Argo CD only examines the payload to infer\\nthe involved applications of the webhook event (e.g. which repo was modified), then refreshes\\nthe related application for reconciliation. This refresh is the same refresh which occurs regularly\\nat three minute intervals, just fast-tracked by the webhook event.</p>\\n<h2>Reporting Vulnerabilities</h2>\\n<p>Please report security vulnerabilities by e-mailing:</p>\\n<ul>\\n<li>Jesse_Suen@intuit.com</li>\\n<li>Alexander_Matyushentsev@intuit.com</li>\\n<li>Edward_Lee@intuit.com</li>\\n</ul>\",\"docPath\":\"argo-cd/docs/security\",\"proj\":\"argo-cd\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-cd-docs-security-html.json\n// module id = 558\n// module chunks = 51517102593698"],"sourceRoot":""}