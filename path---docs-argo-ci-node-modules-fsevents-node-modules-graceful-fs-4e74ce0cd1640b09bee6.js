webpackJsonp([0x77257a5a450e],{2462:function(e,n){e.exports={pathContext:{docHtml:"<h1>graceful-fs</h1>\n<p>graceful-fs functions as a drop-in replacement for the fs module,\nmaking various improvements.</p>\n<p>The improvements are meant to normalize behavior across different\nplatforms and environments, and to make filesystem access more\nresilient to errors.</p>\n<h2>Improvements over <a href=\"https://nodejs.org/api/fs.html\">fs module</a></h2>\n<ul>\n<li>Queues up <code>open</code> and <code>readdir</code> calls, and retries them once\nsomething closes if there is an EMFILE error from too many file\ndescriptors.</li>\n<li>fixes <code>lchmod</code> for Node versions prior to 0.6.2.</li>\n<li>implements <code>fs.lutimes</code> if possible. Otherwise it becomes a noop.</li>\n<li>ignores <code>EINVAL</code> and <code>EPERM</code> errors in <code>chown</code>, <code>fchown</code> or\n<code>lchown</code> if the user isn't root.</li>\n<li>makes <code>lchmod</code> and <code>lchown</code> become noops, if not available.</li>\n<li>retries reading a file if <code>read</code> results in EAGAIN error.</li>\n</ul>\n<p>On Windows, it retries renaming a file for up to one second if <code>EACCESS</code>\nor <code>EPERM</code> error occurs, likely because antivirus software has locked\nthe directory.</p>\n<h2>USAGE</h2>\n<pre><code class=\"language-javascript\">// use just like fs\nvar fs = require('graceful-fs')\n\n// now go and do stuff with it...\nfs.readFileSync('some-file-or-whatever')\n</code></pre>\n<h2>Global Patching</h2>\n<p>If you want to patch the global fs module (or any other fs-like\nmodule) you can do this:</p>\n<pre><code class=\"language-javascript\">// Make sure to read the caveat below.\nvar realFs = require('fs')\nvar gracefulFs = require('graceful-fs')\ngracefulFs.gracefulify(realFs)\n</code></pre>\n<p>This should only ever be done at the top-level application layer, in\norder to delay on EMFILE errors from any fs-using dependencies.  You\nshould <strong>not</strong> do this in a library, because it can cause unexpected\ndelays in other parts of the program.</p>\n<h2>Changes</h2>\n<p>This module is fairly stable at this point, and used by a lot of\nthings.  That being said, because it implements a subtle behavior\nchange in a core part of the node API, even modest changes can be\nextremely breaking, and the versioning is thus biased towards\nbumping the major when in doubt.</p>\n<p>The main change between major versions has been switching between\nproviding a fully-patched <code>fs</code> module vs monkey-patching the node core\nbuiltin, and the approach by which a non-monkey-patched <code>fs</code> was\ncreated.</p>\n<p>The goal is to trade <code>EMFILE</code> errors for slower fs operations.  So, if\nyou try to open a zillion files, rather than crashing, <code>open</code>\noperations will be queued up and wait for something else to <code>close</code>.</p>\n<p>There are advantages to each approach.  Monkey-patching the fs means\nthat no <code>EMFILE</code> errors can possibly occur anywhere in your\napplication, because everything is using the same core <code>fs</code> module,\nwhich is patched.  However, it can also obviously cause undesirable\nside-effects, especially if the module is loaded multiple times.</p>\n<p>Implementing a separate-but-identical patched <code>fs</code> module is more\nsurgical (and doesn't run the risk of patching multiple times), but\nalso imposes the challenge of keeping in sync with the core module.</p>\n<p>The current approach loads the <code>fs</code> module, and then creates a\nlookalike object that has all the same methods, except a few that are\npatched.  It is safe to use in all versions of Node from 0.8 through\n7.0.</p>\n<h3>v4</h3>\n<ul>\n<li>Do not monkey-patch the fs module.  This module may now be used as a\ndrop-in dep, and users can opt into monkey-patching the fs builtin\nif their app requires it.</li>\n</ul>\n<h3>v3</h3>\n<ul>\n<li>Monkey-patch fs, because the eval approach no longer works on recent\nnode.</li>\n<li>fixed possible type-error throw if rename fails on windows</li>\n<li>verify that we <em>never</em> get EMFILE errors</li>\n<li>Ignore ENOSYS from chmod/chown</li>\n<li>clarify that graceful-fs must be used as a drop-in</li>\n</ul>\n<h3>v2.1.0</h3>\n<ul>\n<li>Use eval rather than monkey-patching fs.</li>\n<li>readdir: Always sort the results</li>\n<li>win32: requeue a file if error has an OK status</li>\n</ul>\n<h3>v2.0</h3>\n<ul>\n<li>A return to monkey patching</li>\n<li>wrap process.cwd</li>\n</ul>\n<h3>v1.1</h3>\n<ul>\n<li>wrap readFile</li>\n<li>Wrap fs.writeFile.</li>\n<li>readdir protection</li>\n<li>Don't clobber the fs builtin</li>\n<li>Handle fs.read EAGAIN errors by trying again</li>\n<li>Expose the curOpen counter</li>\n<li>No-op lchown/lchmod if not implemented</li>\n<li>fs.rename patch only for win32</li>\n<li>Patch fs.rename to handle AV software on Windows</li>\n<li>Close #4 Chown should not fail on einval or eperm if non-root</li>\n<li>Fix isaacs/fstream#1 Only wrap fs one time</li>\n<li>Fix #3 Start at 1024 max files, then back off on EMFILE</li>\n<li>lutimes that doens't blow up on Linux</li>\n<li>A full on-rewrite using a queue instead of just swallowing the EMFILE error</li>\n<li>Wrap Read/Write streams as well</li>\n</ul>\n<h3>1.0</h3>\n<ul>\n<li>Update engines for node 0.6</li>\n<li>Be lstat-graceful on Windows</li>\n<li>first</li>\n</ul>",docPath:"argo-ci/node_modules/fsevents/node_modules/graceful-fs/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-fsevents-node-modules-graceful-fs-4e74ce0cd1640b09bee6.js.map