{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-import-lazy-765ed52a4ca6976ddcf0.js","webpack:///./.cache/json/docs-argo-ci-node-modules-import-lazy.json"],"names":["webpackJsonp","2709","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,0wEAAy/CC,QAAA,0CAAAC,KAAA","file":"path---docs-argo-ci-node-modules-import-lazy-765ed52a4ca6976ddcf0.js","sourcesContent":["webpackJsonp([12613121057008],{\n\n/***/ 2709:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>import-lazy <a href=\\\"https://travis-ci.org/sindresorhus/import-lazy\\\"><img src=\\\"https://travis-ci.org/sindresorhus/import-lazy.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></h1>\\n<blockquote>\\n<p>Import modules lazily</p>\\n</blockquote>\\n<h2>Install</h2>\\n<pre><code>$ npm install --save import-lazy\\n</code></pre>\\n<h2>Usage</h2>\\n<pre><code class=\\\"language-js\\\">// Pass in `require` or a custom import function\\nconst importLazy = require('import-lazy')(require);\\nconst _ = importLazy('lodash');\\n\\n// Where you would normally do\\n_.isNumber(2);\\n\\n// You now instead call it as a function\\n_().isNumber(2);\\n\\n// It's cached on consecutive calls\\n_().isString('unicorn');\\n\\n// Extract lazy variations of the props you need\\nconst members = importLazy('lodash')('isNumber', 'isString');\\n\\n// Useful when using destructuring assignment in ES2015\\nconst {isNumber, isString} = importLazy('lodash')('isNumber', 'isString');\\n\\n// Works out of the box for functions and regular properties\\nconst stuff = importLazy('./math-lib')('sum', 'PHI');\\nconsole.log(stuff.sum(1, 2)); // => 3\\nconsole.log(stuff.PHI); // => 1.618033\\n</code></pre>\\n<h3>Proxy support in Node.js 6 or later</h3>\\n<p>If you use Node.js 6 or later, you can take advantage of ES2015 proxies and don't need to call it as a function.</p>\\n<pre><code class=\\\"language-js\\\">const importLazy = require('import-lazy').proxy(require);\\nconst _ = importLazy('lodash');\\n\\n// No need to call it as a function but still lazily imported\\n_.isNumber(2);\\n</code></pre>\\n<h2>Related</h2>\\n<ul>\\n<li><a href=\\\"https://github.com/sindresorhus/resolve-from\\\">resolve-from</a> - Resolve the path of a module from a given path</li>\\n<li><a href=\\\"https://github.com/sindresorhus/import-from\\\">import-from</a> - Import a module from a given path</li>\\n<li><a href=\\\"https://github.com/sindresorhus/resolve-pkg\\\">resolve-pkg</a> - Resolve the path of a package regardless of it having an entry point</li>\\n<li><a href=\\\"https://github.com/sindresorhus/lazy-value\\\">lazy-value</a> - Create a lazily evaluated value</li>\\n<li><a href=\\\"https://github.com/sindresorhus/define-lazy-prop\\\">define-lazy-prop</a> - Define a lazily evaluated property on an object</li>\\n</ul>\\n<h2>License</h2>\\n<p>MIT © <a href=\\\"https://sindresorhus.com\\\">Sindre Sorhus</a></p>\",\"docPath\":\"argo-ci/node_modules/import-lazy/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-import-lazy-765ed52a4ca6976ddcf0.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>import-lazy <a href=\\\"https://travis-ci.org/sindresorhus/import-lazy\\\"><img src=\\\"https://travis-ci.org/sindresorhus/import-lazy.svg?branch=master\\\" alt=\\\"Build Status\\\"></a></h1>\\n<blockquote>\\n<p>Import modules lazily</p>\\n</blockquote>\\n<h2>Install</h2>\\n<pre><code>$ npm install --save import-lazy\\n</code></pre>\\n<h2>Usage</h2>\\n<pre><code class=\\\"language-js\\\">// Pass in `require` or a custom import function\\nconst importLazy = require('import-lazy')(require);\\nconst _ = importLazy('lodash');\\n\\n// Where you would normally do\\n_.isNumber(2);\\n\\n// You now instead call it as a function\\n_().isNumber(2);\\n\\n// It's cached on consecutive calls\\n_().isString('unicorn');\\n\\n// Extract lazy variations of the props you need\\nconst members = importLazy('lodash')('isNumber', 'isString');\\n\\n// Useful when using destructuring assignment in ES2015\\nconst {isNumber, isString} = importLazy('lodash')('isNumber', 'isString');\\n\\n// Works out of the box for functions and regular properties\\nconst stuff = importLazy('./math-lib')('sum', 'PHI');\\nconsole.log(stuff.sum(1, 2)); // => 3\\nconsole.log(stuff.PHI); // => 1.618033\\n</code></pre>\\n<h3>Proxy support in Node.js 6 or later</h3>\\n<p>If you use Node.js 6 or later, you can take advantage of ES2015 proxies and don't need to call it as a function.</p>\\n<pre><code class=\\\"language-js\\\">const importLazy = require('import-lazy').proxy(require);\\nconst _ = importLazy('lodash');\\n\\n// No need to call it as a function but still lazily imported\\n_.isNumber(2);\\n</code></pre>\\n<h2>Related</h2>\\n<ul>\\n<li><a href=\\\"https://github.com/sindresorhus/resolve-from\\\">resolve-from</a> - Resolve the path of a module from a given path</li>\\n<li><a href=\\\"https://github.com/sindresorhus/import-from\\\">import-from</a> - Import a module from a given path</li>\\n<li><a href=\\\"https://github.com/sindresorhus/resolve-pkg\\\">resolve-pkg</a> - Resolve the path of a package regardless of it having an entry point</li>\\n<li><a href=\\\"https://github.com/sindresorhus/lazy-value\\\">lazy-value</a> - Create a lazily evaluated value</li>\\n<li><a href=\\\"https://github.com/sindresorhus/define-lazy-prop\\\">define-lazy-prop</a> - Define a lazily evaluated property on an object</li>\\n</ul>\\n<h2>License</h2>\\n<p>MIT © <a href=\\\"https://sindresorhus.com\\\">Sindre Sorhus</a></p>\",\"docPath\":\"argo-ci/node_modules/import-lazy/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-import-lazy.json\n// module id = 2709\n// module chunks = 12613121057008"],"sourceRoot":""}