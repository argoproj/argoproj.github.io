{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-nan-doc-object-wrappers-html-0a3eca1e91f968ca562c.js","webpack:///./.cache/json/docs-argo-ci-node-modules-nan-doc-object-wrappers-html.json"],"names":["webpackJsonp","2913","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,s/RAAygSC,QAAA,+CAAAC,KAAA","file":"path---docs-argo-ci-node-modules-nan-doc-object-wrappers-html-0a3eca1e91f968ca562c.js","sourcesContent":["webpackJsonp([4229377899814],{\n\n/***/ 2913:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h2>Object Wrappers</h2>\\n<p>The <code>ObjectWrap</code> class can be used to make wrapped C++ objects and a factory of wrapped objects.</p>\\n<ul>\\n<li><a href=\\\"#api_nan_object_wrap\\\"><b><code>Nan::ObjectWrap</code></b></a></li>\\n</ul>\\n<p><a name=\\\"api_nan_object_wrap\\\"></a></p>\\n<h3>Nan::ObjectWrap()</h3>\\n<p>A reimplementation of <code>node::ObjectWrap</code> that adds some API not present in older versions of Node. Should be preferred over <code>node::ObjectWrap</code> in all cases for consistency.</p>\\n<p>Definition:</p>\\n<pre><code class=\\\"language-c++\\\">class ObjectWrap {\\n public:\\n  ObjectWrap();\\n\\n  virtual ~ObjectWrap();\\n\\n  template &#x3C;class T>\\n  static inline T* Unwrap(v8::Local&#x3C;v8::Object> handle);\\n\\n  inline v8::Local&#x3C;v8::Object> handle();\\n\\n  inline Nan::Persistent&#x3C;v8::Object>&#x26; persistent();\\n\\n protected:\\n  inline void Wrap(v8::Local&#x3C;v8::Object> handle);\\n\\n  inline void MakeWeak();\\n\\n  /* Ref() marks the object as being attached to an event loop.\\n   * Refed objects will not be garbage collected, even if\\n   * all references are lost.\\n   */\\n  virtual void Ref();\\n\\n  /* Unref() marks an object as detached from the event loop.  This is its\\n   * default state.  When an object with a \\\"weak\\\" reference changes from\\n   * attached to detached state it will be freed. Be careful not to access\\n   * the object after making this call as it might be gone!\\n   * (A \\\"weak reference\\\" means an object that only has a\\n   * persistant handle.)\\n   *\\n   * DO NOT CALL THIS FROM DESTRUCTOR\\n   */\\n  virtual void Unref();\\n\\n  int refs_;  // ro\\n};\\n</code></pre>\\n<p>See the Node documentation on <a href=\\\"https://nodejs.org/api/addons.html#addons_wrapping_c_objects\\\">Wrapping C++ Objects</a> for more details.</p>\\n<h3>This vs. Holder</h3>\\n<p>When calling <code>Unwrap</code>, it is important that the argument is indeed some JavaScript object which got wrapped by a <code>Wrap</code> call for this class or any derived class.\\nThe <code>Signature</code> installed by <a href=\\\"methods.md#api_nan_set_prototype_method\\\"><code>Nan::SetPrototypeMethod()</code></a> does ensure that <code>info.Holder()</code> is just such an instance.\\nIn Node 0.12 and later, <code>info.This()</code> will also be of such a type, since otherwise the invocation will get rejected.\\nHowever, in Node 0.10 and before it was possible to invoke a method on a JavaScript object which just had the extension type in its prototype chain.\\nIn such a situation, calling <code>Unwrap</code> on <code>info.This()</code> will likely lead to a failed assertion causing a crash, but could lead to even more serious corruption.</p>\\n<p>On the other hand, calling <code>Unwrap</code> in an <a href=\\\"methods.md#api_nan_set_accessor\\\">accessor</a> should not use <code>Holder()</code> if the accessor is defined on the prototype.\\nSo either define your accessors on the instance template,\\nor use <code>This()</code> after verifying that it is indeed a valid object.</p>\\n<h3>Examples</h3>\\n<h4>Basic</h4>\\n<pre><code class=\\\"language-c++\\\">class MyObject : public Nan::ObjectWrap {\\n public:\\n  static NAN_MODULE_INIT(Init) {\\n    v8::Local&#x3C;v8::FunctionTemplate> tpl = Nan::New&#x3C;v8::FunctionTemplate>(New);\\n    tpl->SetClassName(Nan::New(\\\"MyObject\\\").ToLocalChecked());\\n    tpl->InstanceTemplate()->SetInternalFieldCount(1);\\n\\n    Nan::SetPrototypeMethod(tpl, \\\"getHandle\\\", GetHandle);\\n    Nan::SetPrototypeMethod(tpl, \\\"getValue\\\", GetValue);\\n\\n    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());\\n    Nan::Set(target, Nan::New(\\\"MyObject\\\").ToLocalChecked(),\\n      Nan::GetFunction(tpl).ToLocalChecked());\\n  }\\n\\n private:\\n  explicit MyObject(double value = 0) : value_(value) {}\\n  ~MyObject() {}\\n\\n  static NAN_METHOD(New) {\\n    if (info.IsConstructCall()) {\\n      double value = info[0]->IsUndefined() ? 0 : Nan::To&#x3C;double>(info[0]).FromJust();\\n      MyObject *obj = new MyObject(value);\\n      obj->Wrap(info.This());\\n      info.GetReturnValue().Set(info.This());\\n    } else {\\n      const int argc = 1;\\n      v8::Local&#x3C;v8::Value> argv[argc] = {info[0]};\\n      v8::Local&#x3C;v8::Function> cons = Nan::New(constructor());\\n      info.GetReturnValue().Set(cons->NewInstance(argc, argv));\\n    }\\n  }\\n\\n  static NAN_METHOD(GetHandle) {\\n    MyObject* obj = Nan::ObjectWrap::Unwrap&#x3C;MyObject>(info.Holder());\\n    info.GetReturnValue().Set(obj->handle());\\n  }\\n\\n  static NAN_METHOD(GetValue) {\\n    MyObject* obj = Nan::ObjectWrap::Unwrap&#x3C;MyObject>(info.Holder());\\n    info.GetReturnValue().Set(obj->value_);\\n  }\\n\\n  static inline Nan::Persistent&#x3C;v8::Function> &#x26; constructor() {\\n    static Nan::Persistent&#x3C;v8::Function> my_constructor;\\n    return my_constructor;\\n  }\\n\\n  double value_;\\n};\\n\\nNODE_MODULE(objectwrapper, MyObject::Init)\\n</code></pre>\\n<p>To use in Javascript:</p>\\n<pre><code class=\\\"language-Javascript\\\">var objectwrapper = require('bindings')('objectwrapper');\\n\\nvar obj = new objectwrapper.MyObject(5);\\nconsole.log('Should be 5: ' + obj.getValue());\\n</code></pre>\\n<h4>Factory of wrapped objects</h4>\\n<pre><code class=\\\"language-c++\\\">class MyFactoryObject : public Nan::ObjectWrap {\\n public:\\n  static NAN_MODULE_INIT(Init) {\\n    v8::Local&#x3C;v8::FunctionTemplate> tpl = Nan::New&#x3C;v8::FunctionTemplate>(New);\\n    tpl->InstanceTemplate()->SetInternalFieldCount(1);\\n\\n    Nan::SetPrototypeMethod(tpl, \\\"getValue\\\", GetValue);\\n\\n    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());\\n  }\\n\\n  static NAN_METHOD(NewInstance) {\\n    v8::Local&#x3C;v8::Function> cons = Nan::New(constructor());\\n    double value = info[0]->IsNumber() ? Nan::To&#x3C;double>(info[0]).FromJust() : 0;\\n    const int argc = 1;\\n    v8::Local&#x3C;v8::Value> argv[1] = {Nan::New(value)};\\n    info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());\\n  }\\n\\n  // Needed for the next example:\\n  inline double value() const {\\n    return value_;\\n  }\\n\\n private:\\n  explicit MyFactoryObject(double value = 0) : value_(value) {}\\n  ~MyFactoryObject() {}\\n\\n  static NAN_METHOD(New) {\\n    if (info.IsConstructCall()) {\\n      double value = info[0]->IsNumber() ? Nan::To&#x3C;double>(info[0]).FromJust() : 0;\\n      MyFactoryObject * obj = new MyFactoryObject(value);\\n      obj->Wrap(info.This());\\n      info.GetReturnValue().Set(info.This());\\n    } else {\\n      const int argc = 1;\\n      v8::Local&#x3C;v8::Value> argv[argc] = {info[0]};\\n      v8::Local&#x3C;v8::Function> cons = Nan::New(constructor());\\n      info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());\\n    }\\n  }\\n\\n  static NAN_METHOD(GetValue) {\\n    MyFactoryObject* obj = ObjectWrap::Unwrap&#x3C;MyFactoryObject>(info.Holder());\\n    info.GetReturnValue().Set(obj->value_);\\n  }\\n\\n  static inline Nan::Persistent&#x3C;v8::Function> &#x26; constructor() {\\n    static Nan::Persistent&#x3C;v8::Function> my_constructor;\\n    return my_constructor;\\n  }\\n\\n  double value_;\\n};\\n\\nNAN_MODULE_INIT(Init) {\\n  MyFactoryObject::Init(target);\\n  Nan::Set(target,\\n    Nan::New&#x3C;v8::String>(\\\"newFactoryObjectInstance\\\").ToLocalChecked(),\\n    Nan::GetFunction(\\n      Nan::New&#x3C;v8::FunctionTemplate>(MyFactoryObject::NewInstance)).ToLocalChecked()\\n  );\\n}\\n\\nNODE_MODULE(wrappedobjectfactory, Init)\\n</code></pre>\\n<p>To use in Javascript:</p>\\n<pre><code class=\\\"language-Javascript\\\">var wrappedobjectfactory = require('bindings')('wrappedobjectfactory');\\n\\nvar obj = wrappedobjectfactory.newFactoryObjectInstance(10);\\nconsole.log('Should be 10: ' + obj.getValue());\\n</code></pre>\\n<h4>Passing wrapped objects around</h4>\\n<p>Use the <code>MyFactoryObject</code> class above along with the following:</p>\\n<pre><code class=\\\"language-c++\\\">static NAN_METHOD(Sum) {\\n  Nan::MaybeLocal&#x3C;v8::Object> maybe1 = Nan::To&#x3C;v8::Object>(info[0]);\\n  Nan::MaybeLocal&#x3C;v8::Object> maybe2 = Nan::To&#x3C;v8::Object>(info[1]);\\n\\n  // Quick check:\\n  if (maybe1.IsEmpty() || maybe2.IsEmpty()) {\\n    // return value is undefined by default\\n    return;\\n  }\\n\\n  MyFactoryObject* obj1 =\\n    Nan::ObjectWrap::Unwrap&#x3C;MyFactoryObject>(maybe1.ToLocalChecked());\\n  MyFactoryObject* obj2 =\\n    Nan::ObjectWrap::Unwrap&#x3C;MyFactoryObject>(maybe2.ToLocalChecked());\\n\\n  info.GetReturnValue().Set(Nan::New&#x3C;v8::Number>(obj1->value() + obj2->value()));\\n}\\n\\nNAN_MODULE_INIT(Init) {\\n  MyFactoryObject::Init(target);\\n  Nan::Set(target,\\n    Nan::New&#x3C;v8::String>(\\\"newFactoryObjectInstance\\\").ToLocalChecked(),\\n    Nan::GetFunction(\\n      Nan::New&#x3C;v8::FunctionTemplate>(MyFactoryObject::NewInstance)).ToLocalChecked()\\n  );\\n  Nan::Set(target,\\n    Nan::New&#x3C;v8::String>(\\\"sum\\\").ToLocalChecked(),\\n    Nan::GetFunction(Nan::New&#x3C;v8::FunctionTemplate>(Sum)).ToLocalChecked()\\n  );\\n}\\n\\nNODE_MODULE(myaddon, Init)\\n</code></pre>\\n<p>To use in Javascript:</p>\\n<pre><code class=\\\"language-Javascript\\\">var myaddon = require('bindings')('myaddon');\\n\\nvar obj1 = myaddon.newFactoryObjectInstance(5);\\nvar obj2 = myaddon.newFactoryObjectInstance(10);\\nconsole.log('sum of object values: ' + myaddon.sum(obj1, obj2));\\n</code></pre>\",\"docPath\":\"argo-ci/node_modules/nan/doc/object_wrappers\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-nan-doc-object-wrappers-html-0a3eca1e91f968ca562c.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h2>Object Wrappers</h2>\\n<p>The <code>ObjectWrap</code> class can be used to make wrapped C++ objects and a factory of wrapped objects.</p>\\n<ul>\\n<li><a href=\\\"#api_nan_object_wrap\\\"><b><code>Nan::ObjectWrap</code></b></a></li>\\n</ul>\\n<p><a name=\\\"api_nan_object_wrap\\\"></a></p>\\n<h3>Nan::ObjectWrap()</h3>\\n<p>A reimplementation of <code>node::ObjectWrap</code> that adds some API not present in older versions of Node. Should be preferred over <code>node::ObjectWrap</code> in all cases for consistency.</p>\\n<p>Definition:</p>\\n<pre><code class=\\\"language-c++\\\">class ObjectWrap {\\n public:\\n  ObjectWrap();\\n\\n  virtual ~ObjectWrap();\\n\\n  template &#x3C;class T>\\n  static inline T* Unwrap(v8::Local&#x3C;v8::Object> handle);\\n\\n  inline v8::Local&#x3C;v8::Object> handle();\\n\\n  inline Nan::Persistent&#x3C;v8::Object>&#x26; persistent();\\n\\n protected:\\n  inline void Wrap(v8::Local&#x3C;v8::Object> handle);\\n\\n  inline void MakeWeak();\\n\\n  /* Ref() marks the object as being attached to an event loop.\\n   * Refed objects will not be garbage collected, even if\\n   * all references are lost.\\n   */\\n  virtual void Ref();\\n\\n  /* Unref() marks an object as detached from the event loop.  This is its\\n   * default state.  When an object with a \\\"weak\\\" reference changes from\\n   * attached to detached state it will be freed. Be careful not to access\\n   * the object after making this call as it might be gone!\\n   * (A \\\"weak reference\\\" means an object that only has a\\n   * persistant handle.)\\n   *\\n   * DO NOT CALL THIS FROM DESTRUCTOR\\n   */\\n  virtual void Unref();\\n\\n  int refs_;  // ro\\n};\\n</code></pre>\\n<p>See the Node documentation on <a href=\\\"https://nodejs.org/api/addons.html#addons_wrapping_c_objects\\\">Wrapping C++ Objects</a> for more details.</p>\\n<h3>This vs. Holder</h3>\\n<p>When calling <code>Unwrap</code>, it is important that the argument is indeed some JavaScript object which got wrapped by a <code>Wrap</code> call for this class or any derived class.\\nThe <code>Signature</code> installed by <a href=\\\"methods.md#api_nan_set_prototype_method\\\"><code>Nan::SetPrototypeMethod()</code></a> does ensure that <code>info.Holder()</code> is just such an instance.\\nIn Node 0.12 and later, <code>info.This()</code> will also be of such a type, since otherwise the invocation will get rejected.\\nHowever, in Node 0.10 and before it was possible to invoke a method on a JavaScript object which just had the extension type in its prototype chain.\\nIn such a situation, calling <code>Unwrap</code> on <code>info.This()</code> will likely lead to a failed assertion causing a crash, but could lead to even more serious corruption.</p>\\n<p>On the other hand, calling <code>Unwrap</code> in an <a href=\\\"methods.md#api_nan_set_accessor\\\">accessor</a> should not use <code>Holder()</code> if the accessor is defined on the prototype.\\nSo either define your accessors on the instance template,\\nor use <code>This()</code> after verifying that it is indeed a valid object.</p>\\n<h3>Examples</h3>\\n<h4>Basic</h4>\\n<pre><code class=\\\"language-c++\\\">class MyObject : public Nan::ObjectWrap {\\n public:\\n  static NAN_MODULE_INIT(Init) {\\n    v8::Local&#x3C;v8::FunctionTemplate> tpl = Nan::New&#x3C;v8::FunctionTemplate>(New);\\n    tpl->SetClassName(Nan::New(\\\"MyObject\\\").ToLocalChecked());\\n    tpl->InstanceTemplate()->SetInternalFieldCount(1);\\n\\n    Nan::SetPrototypeMethod(tpl, \\\"getHandle\\\", GetHandle);\\n    Nan::SetPrototypeMethod(tpl, \\\"getValue\\\", GetValue);\\n\\n    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());\\n    Nan::Set(target, Nan::New(\\\"MyObject\\\").ToLocalChecked(),\\n      Nan::GetFunction(tpl).ToLocalChecked());\\n  }\\n\\n private:\\n  explicit MyObject(double value = 0) : value_(value) {}\\n  ~MyObject() {}\\n\\n  static NAN_METHOD(New) {\\n    if (info.IsConstructCall()) {\\n      double value = info[0]->IsUndefined() ? 0 : Nan::To&#x3C;double>(info[0]).FromJust();\\n      MyObject *obj = new MyObject(value);\\n      obj->Wrap(info.This());\\n      info.GetReturnValue().Set(info.This());\\n    } else {\\n      const int argc = 1;\\n      v8::Local&#x3C;v8::Value> argv[argc] = {info[0]};\\n      v8::Local&#x3C;v8::Function> cons = Nan::New(constructor());\\n      info.GetReturnValue().Set(cons->NewInstance(argc, argv));\\n    }\\n  }\\n\\n  static NAN_METHOD(GetHandle) {\\n    MyObject* obj = Nan::ObjectWrap::Unwrap&#x3C;MyObject>(info.Holder());\\n    info.GetReturnValue().Set(obj->handle());\\n  }\\n\\n  static NAN_METHOD(GetValue) {\\n    MyObject* obj = Nan::ObjectWrap::Unwrap&#x3C;MyObject>(info.Holder());\\n    info.GetReturnValue().Set(obj->value_);\\n  }\\n\\n  static inline Nan::Persistent&#x3C;v8::Function> &#x26; constructor() {\\n    static Nan::Persistent&#x3C;v8::Function> my_constructor;\\n    return my_constructor;\\n  }\\n\\n  double value_;\\n};\\n\\nNODE_MODULE(objectwrapper, MyObject::Init)\\n</code></pre>\\n<p>To use in Javascript:</p>\\n<pre><code class=\\\"language-Javascript\\\">var objectwrapper = require('bindings')('objectwrapper');\\n\\nvar obj = new objectwrapper.MyObject(5);\\nconsole.log('Should be 5: ' + obj.getValue());\\n</code></pre>\\n<h4>Factory of wrapped objects</h4>\\n<pre><code class=\\\"language-c++\\\">class MyFactoryObject : public Nan::ObjectWrap {\\n public:\\n  static NAN_MODULE_INIT(Init) {\\n    v8::Local&#x3C;v8::FunctionTemplate> tpl = Nan::New&#x3C;v8::FunctionTemplate>(New);\\n    tpl->InstanceTemplate()->SetInternalFieldCount(1);\\n\\n    Nan::SetPrototypeMethod(tpl, \\\"getValue\\\", GetValue);\\n\\n    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());\\n  }\\n\\n  static NAN_METHOD(NewInstance) {\\n    v8::Local&#x3C;v8::Function> cons = Nan::New(constructor());\\n    double value = info[0]->IsNumber() ? Nan::To&#x3C;double>(info[0]).FromJust() : 0;\\n    const int argc = 1;\\n    v8::Local&#x3C;v8::Value> argv[1] = {Nan::New(value)};\\n    info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());\\n  }\\n\\n  // Needed for the next example:\\n  inline double value() const {\\n    return value_;\\n  }\\n\\n private:\\n  explicit MyFactoryObject(double value = 0) : value_(value) {}\\n  ~MyFactoryObject() {}\\n\\n  static NAN_METHOD(New) {\\n    if (info.IsConstructCall()) {\\n      double value = info[0]->IsNumber() ? Nan::To&#x3C;double>(info[0]).FromJust() : 0;\\n      MyFactoryObject * obj = new MyFactoryObject(value);\\n      obj->Wrap(info.This());\\n      info.GetReturnValue().Set(info.This());\\n    } else {\\n      const int argc = 1;\\n      v8::Local&#x3C;v8::Value> argv[argc] = {info[0]};\\n      v8::Local&#x3C;v8::Function> cons = Nan::New(constructor());\\n      info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());\\n    }\\n  }\\n\\n  static NAN_METHOD(GetValue) {\\n    MyFactoryObject* obj = ObjectWrap::Unwrap&#x3C;MyFactoryObject>(info.Holder());\\n    info.GetReturnValue().Set(obj->value_);\\n  }\\n\\n  static inline Nan::Persistent&#x3C;v8::Function> &#x26; constructor() {\\n    static Nan::Persistent&#x3C;v8::Function> my_constructor;\\n    return my_constructor;\\n  }\\n\\n  double value_;\\n};\\n\\nNAN_MODULE_INIT(Init) {\\n  MyFactoryObject::Init(target);\\n  Nan::Set(target,\\n    Nan::New&#x3C;v8::String>(\\\"newFactoryObjectInstance\\\").ToLocalChecked(),\\n    Nan::GetFunction(\\n      Nan::New&#x3C;v8::FunctionTemplate>(MyFactoryObject::NewInstance)).ToLocalChecked()\\n  );\\n}\\n\\nNODE_MODULE(wrappedobjectfactory, Init)\\n</code></pre>\\n<p>To use in Javascript:</p>\\n<pre><code class=\\\"language-Javascript\\\">var wrappedobjectfactory = require('bindings')('wrappedobjectfactory');\\n\\nvar obj = wrappedobjectfactory.newFactoryObjectInstance(10);\\nconsole.log('Should be 10: ' + obj.getValue());\\n</code></pre>\\n<h4>Passing wrapped objects around</h4>\\n<p>Use the <code>MyFactoryObject</code> class above along with the following:</p>\\n<pre><code class=\\\"language-c++\\\">static NAN_METHOD(Sum) {\\n  Nan::MaybeLocal&#x3C;v8::Object> maybe1 = Nan::To&#x3C;v8::Object>(info[0]);\\n  Nan::MaybeLocal&#x3C;v8::Object> maybe2 = Nan::To&#x3C;v8::Object>(info[1]);\\n\\n  // Quick check:\\n  if (maybe1.IsEmpty() || maybe2.IsEmpty()) {\\n    // return value is undefined by default\\n    return;\\n  }\\n\\n  MyFactoryObject* obj1 =\\n    Nan::ObjectWrap::Unwrap&#x3C;MyFactoryObject>(maybe1.ToLocalChecked());\\n  MyFactoryObject* obj2 =\\n    Nan::ObjectWrap::Unwrap&#x3C;MyFactoryObject>(maybe2.ToLocalChecked());\\n\\n  info.GetReturnValue().Set(Nan::New&#x3C;v8::Number>(obj1->value() + obj2->value()));\\n}\\n\\nNAN_MODULE_INIT(Init) {\\n  MyFactoryObject::Init(target);\\n  Nan::Set(target,\\n    Nan::New&#x3C;v8::String>(\\\"newFactoryObjectInstance\\\").ToLocalChecked(),\\n    Nan::GetFunction(\\n      Nan::New&#x3C;v8::FunctionTemplate>(MyFactoryObject::NewInstance)).ToLocalChecked()\\n  );\\n  Nan::Set(target,\\n    Nan::New&#x3C;v8::String>(\\\"sum\\\").ToLocalChecked(),\\n    Nan::GetFunction(Nan::New&#x3C;v8::FunctionTemplate>(Sum)).ToLocalChecked()\\n  );\\n}\\n\\nNODE_MODULE(myaddon, Init)\\n</code></pre>\\n<p>To use in Javascript:</p>\\n<pre><code class=\\\"language-Javascript\\\">var myaddon = require('bindings')('myaddon');\\n\\nvar obj1 = myaddon.newFactoryObjectInstance(5);\\nvar obj2 = myaddon.newFactoryObjectInstance(10);\\nconsole.log('sum of object values: ' + myaddon.sum(obj1, obj2));\\n</code></pre>\",\"docPath\":\"argo-ci/node_modules/nan/doc/object_wrappers\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-nan-doc-object-wrappers-html.json\n// module id = 2913\n// module chunks = 4229377899814"],"sourceRoot":""}