{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-dashdash-readme-html-3f84bafa5d0530a2a15e.js","webpack:///./.cache/json/docs-argo-ci-node-modules-dashdash-readme-html.json"],"names":["webpackJsonp","2220","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA,6hpBAAomlBC,QAAA,uCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-dashdash-readme-html-3f84bafa5d0530a2a15e.js","sourcesContent":["webpackJsonp([131140530568233],{\n\n/***/ 2220:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<p>A light, featureful and explicit option parsing library for node.js.</p>\\n<p><a href=\\\"#why\\\">Why another one? See below</a>. tl;dr: The others I've tried are one of\\ntoo loosey goosey (not explicit), too big/too many deps, or ill specified.\\nYMMV.</p>\\n<p>Follow <a href=\\\"https://twitter.com/intent/user?screen_name=trentmick\\\" target=\\\"_blank\\\">@trentmick</a>\\nfor updates to node-dashdash.</p>\\n<h1>Install</h1>\\n<pre><code>npm install dashdash\\n</code></pre>\\n<h1>Usage</h1>\\n<pre><code class=\\\"language-javascript\\\">var dashdash = require('dashdash');\\n\\n// Specify the options. Minimally `name` (or `names`) and `type`\\n// must be given for each.\\nvar options = [\\n    {\\n        // `names` or a single `name`. First element is the `opts.KEY`.\\n        names: ['help', 'h'],\\n        // See \\\"Option specs\\\" below for types.\\n        type: 'bool',\\n        help: 'Print this help and exit.'\\n    }\\n];\\n\\n// Shortcut form. As called it infers `process.argv`. See below for\\n// the longer form to use methods like `.help()` on the Parser object.\\nvar opts = dashdash.parse({options: options});\\n\\nconsole.log(\\\"opts:\\\", opts);\\nconsole.log(\\\"args:\\\", opts._args);\\n</code></pre>\\n<h1>Longer Example</h1>\\n<p>A more realistic <a href=\\\"./examples/foo.js\\\">starter script \\\"foo.js\\\"</a> is as follows.\\nThis also shows using <code>parser.help()</code> for formatted option help.</p>\\n<pre><code class=\\\"language-javascript\\\">var dashdash = require('./lib/dashdash');\\n\\nvar options = [\\n    {\\n        name: 'version',\\n        type: 'bool',\\n        help: 'Print tool version and exit.'\\n    },\\n    {\\n        names: ['help', 'h'],\\n        type: 'bool',\\n        help: 'Print this help and exit.'\\n    },\\n    {\\n        names: ['verbose', 'v'],\\n        type: 'arrayOfBool',\\n        help: 'Verbose output. Use multiple times for more verbose.'\\n    },\\n    {\\n        names: ['file', 'f'],\\n        type: 'string',\\n        help: 'File to process',\\n        helpArg: 'FILE'\\n    }\\n];\\n\\nvar parser = dashdash.createParser({options: options});\\ntry {\\n    var opts = parser.parse(process.argv);\\n} catch (e) {\\n    console.error('foo: error: %s', e.message);\\n    process.exit(1);\\n}\\n\\nconsole.log(\\\"# opts:\\\", opts);\\nconsole.log(\\\"# args:\\\", opts._args);\\n\\n// Use `parser.help()` for formatted options help.\\nif (opts.help) {\\n    var help = parser.help({includeEnv: true}).trimRight();\\n    console.log('usage: node foo.js [OPTIONS]\\\\n'\\n                + 'options:\\\\n'\\n                + help);\\n    process.exit(0);\\n}\\n\\n// ...\\n</code></pre>\\n<p>Some example output from this script (foo.js):</p>\\n<pre><code>$ node foo.js -h\\n# opts: { help: true,\\n  _order: [ { name: 'help', value: true, from: 'argv' } ],\\n  _args: [] }\\n# args: []\\nusage: node foo.js [OPTIONS]\\noptions:\\n    --version             Print tool version and exit.\\n    -h, --help            Print this help and exit.\\n    -v, --verbose         Verbose output. Use multiple times for more verbose.\\n    -f FILE, --file=FILE  File to process\\n\\n$ node foo.js -v\\n# opts: { verbose: [ true ],\\n  _order: [ { name: 'verbose', value: true, from: 'argv' } ],\\n  _args: [] }\\n# args: []\\n\\n$ node foo.js --version arg1\\n# opts: { version: true,\\n  _order: [ { name: 'version', value: true, from: 'argv' } ],\\n  _args: [ 'arg1' ] }\\n# args: [ 'arg1' ]\\n\\n$ node foo.js -f bar.txt\\n# opts: { file: 'bar.txt',\\n  _order: [ { name: 'file', value: 'bar.txt', from: 'argv' } ],\\n  _args: [] }\\n# args: []\\n\\n$ node foo.js -vvv --file=blah\\n# opts: { verbose: [ true, true, true ],\\n  file: 'blah',\\n  _order:\\n   [ { name: 'verbose', value: true, from: 'argv' },\\n     { name: 'verbose', value: true, from: 'argv' },\\n     { name: 'verbose', value: true, from: 'argv' },\\n     { name: 'file', value: 'blah', from: 'argv' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>See the <a href=\\\"examples/\\\">\\\"examples\\\"</a> dir for a number of starter examples using\\nsome of dashdash's features.</p>\\n<h1>Environment variable integration</h1>\\n<p>If you want to allow environment variables to specify options to your tool,\\ndashdash makes this easy. We can change the 'verbose' option in the example\\nabove to include an 'env' field:</p>\\n<pre><code class=\\\"language-javascript\\\">    {\\n        names: ['verbose', 'v'],\\n        type: 'arrayOfBool',\\n        env: 'FOO_VERBOSE',         // &#x3C;--- add this line\\n        help: 'Verbose output. Use multiple times for more verbose.'\\n    },\\n</code></pre>\\n<p>then the <strong>\\\"FOO_VERBOSE\\\" environment variable</strong> can be used to set this\\noption:</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_VERBOSE=1 node foo.js\\n# opts: { verbose: [ true ],\\n  _order: [ { name: 'verbose', value: true, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>Boolean options will interpret the empty string as unset, '0' as false\\nand anything else as true.</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_VERBOSE= node examples/foo.js                 # not set\\n# opts: { _order: [], _args: [] }\\n# args: []\\n\\n$ FOO_VERBOSE=0 node examples/foo.js                # '0' is false\\n# opts: { verbose: [ false ],\\n  _order: [ { key: 'verbose', value: false, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n\\n$ FOO_VERBOSE=1 node examples/foo.js                # true\\n# opts: { verbose: [ true ],\\n  _order: [ { key: 'verbose', value: true, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n\\n$ FOO_VERBOSE=boogabooga node examples/foo.js       # true\\n# opts: { verbose: [ true ],\\n  _order: [ { key: 'verbose', value: true, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>Non-booleans can be used as well. Strings:</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_FILE=data.txt node examples/foo.js\\n# opts: { file: 'data.txt',\\n  _order: [ { key: 'file', value: 'data.txt', from: 'env' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>Numbers:</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_TIMEOUT=5000 node examples/foo.js\\n# opts: { timeout: 5000,\\n  _order: [ { key: 'timeout', value: 5000, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n\\n$ FOO_TIMEOUT=blarg node examples/foo.js\\nfoo: error: arg for \\\"FOO_TIMEOUT\\\" is not a positive integer: \\\"blarg\\\"\\n</code></pre>\\n<p>With the <code>includeEnv: true</code> config to <code>parser.help()</code> the environment\\nvariable can also be included in <strong>help output</strong>:</p>\\n<pre><code>usage: node foo.js [OPTIONS]\\noptions:\\n    --version             Print tool version and exit.\\n    -h, --help            Print this help and exit.\\n    -v, --verbose         Verbose output. Use multiple times for more verbose.\\n                          Environment: FOO_VERBOSE=1\\n    -f FILE, --file=FILE  File to process\\n</code></pre>\\n<h1>Bash completion</h1>\\n<p>Dashdash provides a simple way to create a Bash completion file that you\\ncan place in your \\\"bash<em>completion.d\\\" directory -- sometimes that is\\n\\\"/usr/local/etc/bash</em>completion.d/\\\"). Features:</p>\\n<ul>\\n<li>Support for short and long opts</li>\\n<li>Support for knowing which options take arguments</li>\\n<li>Support for subcommands (e.g. 'git log <TAB>' to show just options for the\\nlog subcommand). See\\n<a href=\\\"https://github.com/trentm/node-cmdln#bash-completion\\\">node-cmdln</a> for\\nhow to integrate that.</li>\\n<li>Does the right thing with \\\"--\\\" to stop options.</li>\\n<li>Custom optarg and arg types for custom completions.</li>\\n</ul>\\n<p>Dashdash will return bash completion file content given a parser instance:</p>\\n<pre><code>var parser = dashdash.createParser({options: options});\\nconsole.log( parser.bashCompletion({name: 'mycli'}) );\\n</code></pre>\\n<p>or directly from a <code>options</code> array of options specs:</p>\\n<pre><code>var code = dashdash.bashCompletionFromOptions({\\n    name: 'mycli',\\n    options: OPTIONS\\n});\\n</code></pre>\\n<p>Write that content to \\\"/usr/local/etc/bash_completion.d/mycli\\\" and you will\\nhave Bash completions for <code>mycli</code>. Alternatively you can write it to\\nany file (e.g. \\\"~/.bashrc\\\") and source it.</p>\\n<p>You could add a <code>--completion</code> hidden option to your tool that emits the\\ncompletion content and document for your users to call that to install\\nBash completions.</p>\\n<p>See <a href=\\\"examples/ddcompletion.js\\\">examples/ddcompletion.js</a> for a complete\\nexample, including how one can define bash functions for completion of custom\\noption types. Also see <a href=\\\"https://github.com/trentm/node-cmdln\\\">node-cmdln</a> for\\nhow it uses this for Bash completion for full multi-subcommand tools.</p>\\n<ul>\\n<li>TODO: document specExtra</li>\\n<li>TODO: document includeHidden</li>\\n<li>TODO: document custom types, <code>function complete\\\\_FOO</code> guide, completionType</li>\\n<li>TODO: document argtypes</li>\\n</ul>\\n<h1>Parser config</h1>\\n<p>Parser construction (i.e. <code>dashdash.createParser(CONFIG)</code>) takes the\\nfollowing fields:</p>\\n<ul>\\n<li>\\n<p><code>options</code> (Array of option specs). Required. See the\\n<a href=\\\"#option-specs\\\">Option specs</a> section below.</p>\\n</li>\\n<li>\\n<p><code>interspersed</code> (Boolean). Optional. Default is true. If true this allows\\ninterspersed arguments and options. I.e.:</p>\\n<pre><code>node ./tool.js -v arg1 arg2 -h   # '-h' is after interspersed args\\n</code></pre>\\n<p>Set it to false to have '-h' <strong>not</strong> get parsed as an option in the above\\nexample.</p>\\n</li>\\n<li>\\n<p><code>allowUnknown</code> (Boolean).  Optional.  Default is false.  If false, this causes\\nunknown arguments to throw an error.  I.e.:</p>\\n<pre><code>node ./tool.js -v arg1 --afe8asefksjefhas\\n</code></pre>\\n<p>Set it to true to treat the unknown option as a positional\\nargument.</p>\\n<p><strong>Caveat</strong>: When a shortopt group, such as <code>-xaz</code> contains a mix of\\nknown and unknown options, the <em>entire</em> group is passed through\\nunmolested as a positional argument.</p>\\n<p>Consider if you have a known short option <code>-a</code>, and parse the\\nfollowing command line:</p>\\n<pre><code>node ./tool.js -xaz\\n</code></pre>\\n<p>where <code>-x</code> and <code>-z</code> are unknown.  There are multiple ways to\\ninterpret this:</p>\\n<ol>\\n<li><code>-x</code> takes a value: <code>{x: 'az'}</code></li>\\n<li><code>-x</code> and <code>-z</code> are both booleans: <code>{x:true,a:true,z:true}</code></li>\\n</ol>\\n<p>Since dashdash does not know what <code>-x</code> and <code>-z</code> are, it can't know\\nif you'd prefer to receive <code>{a:true,_args:['-x','-z']}</code> or\\n<code>{x:'az'}</code>, or <code>{_args:['-xaz']}</code>. Leaving the positional arg unprocessed\\nis the easiest mistake for the user to recover from.</p>\\n</li>\\n</ul>\\n<h1>Option specs</h1>\\n<p>Example using all fields (required fields are noted):</p>\\n<pre><code class=\\\"language-javascript\\\">{\\n    names: ['file', 'f'],       // Required (one of `names` or `name`).\\n    type: 'string',             // Required.\\n    completionType: 'filename',\\n    env: 'MYTOOL_FILE',\\n    help: 'Config file to load before running \\\"mytool\\\"',\\n    helpArg: 'PATH',\\n    helpWrap: false,\\n    default: path.resolve(process.env.HOME, '.mytoolrc')\\n}\\n</code></pre>\\n<p>Each option spec in the <code>options</code> array must/can have the following fields:</p>\\n<ul>\\n<li>\\n<p><code>name</code> (String) or <code>names</code> (Array). Required. These give the option name\\nand aliases. The first name (if more than one given) is the key for the\\nparsed <code>opts</code> object.</p>\\n</li>\\n<li>\\n<p><code>type</code> (String). Required. One of:</p>\\n<ul>\\n<li>bool</li>\\n<li>string</li>\\n<li>number</li>\\n<li>integer</li>\\n<li>positiveInteger</li>\\n<li>date (epoch seconds, e.g. 1396031701, or ISO 8601 format\\n<code>YYYY-MM-DD[THH:MM:SS[.sss][Z]]</code>, e.g. \\\"2014-03-28T18:35:01.489Z\\\")</li>\\n<li>arrayOfBool</li>\\n<li>arrayOfString</li>\\n<li>arrayOfNumber</li>\\n<li>arrayOfInteger</li>\\n<li>arrayOfPositiveInteger</li>\\n<li>arrayOfDate</li>\\n</ul>\\n<p>FWIW, these names attempt to match with asserts on\\n<a href=\\\"https://github.com/mcavage/node-assert-plus\\\">assert-plus</a>.\\nYou can add your own custom option types with <code>dashdash.addOptionType</code>.\\nSee below.</p>\\n</li>\\n<li>\\n<p><code>completionType</code> (String). Optional. This is used for <a href=\\\"#bash-completion\\\">Bash\\ncompletion</a> for an option argument. If not specified,\\nthen the value of <code>type</code> is used. Any string may be specified, but only the\\nfollowing values have meaning:</p>\\n<ul>\\n<li><code>none</code>: Provide no completions.</li>\\n<li><code>file</code>: Bash's default completion (i.e. <code>complete -o default</code>), which\\nincludes filenames.</li>\\n<li><em>Any string FOO for which a <code>function complete_FOO</code> Bash function is\\ndefined.</em> This is for custom completions for a given tool. Typically\\nthese custom functions are provided in the <code>specExtra</code> argument to\\n<code>dashdash.bashCompletionFromOptions()</code>. See\\n<a href=\\\"examples/ddcompletion.js\\\">\\\"examples/ddcompletion.js\\\"</a> for an example.</li>\\n</ul>\\n</li>\\n<li>\\n<p><code>env</code> (String or Array of String). Optional. An environment variable name\\n(or names) that can be used as a fallback for this option. For example,\\ngiven a \\\"foo.js\\\" like this:</p>\\n<pre><code>var options = [{names: ['dry-run', 'n'], env: 'FOO_DRY_RUN'}];\\nvar opts = dashdash.parse({options: options});\\n</code></pre>\\n<p>Both <code>node foo.js --dry-run</code> and <code>FOO_DRY_RUN=1 node foo.js</code> would result\\nin <code>opts.dry_run = true</code>.</p>\\n<p>An environment variable is only used as a fallback, i.e. it is ignored if\\nthe associated option is given in <code>argv</code>.</p>\\n</li>\\n<li>\\n<p><code>help</code> (String). Optional. Used for <code>parser.help()</code> output.</p>\\n</li>\\n<li>\\n<p><code>helpArg</code> (String). Optional. Used in help output as the placeholder for\\nthe option argument, e.g. the \\\"PATH\\\" in:</p>\\n<pre><code>...\\n-f PATH, --file=PATH    File to process\\n...\\n</code></pre>\\n</li>\\n<li>\\n<p><code>helpWrap</code> (Boolean). Optional, default true. Set this to <code>false</code> to have\\nthat option's <code>help</code> <em>not</em> be text wrapped in <code>&#x3C;parser>.help()</code> output.</p>\\n</li>\\n<li>\\n<p><code>default</code>. Optional. A default value used for this option, if the\\noption isn't specified in argv.</p>\\n</li>\\n<li>\\n<p><code>hidden</code> (Boolean). Optional, default false. If true, help output will not\\ninclude this option. See also the <code>includeHidden</code> option to\\n<code>bashCompletionFromOptions()</code> for <a href=\\\"#bash-completion\\\">Bash completion</a>.</p>\\n</li>\\n</ul>\\n<h1>Option group headings</h1>\\n<p>You can add headings between option specs in the <code>options</code> array.  To do so,\\nsimply add an object with only a <code>group</code> property -- the string to print as\\nthe heading for the subsequent options in the array.  For example:</p>\\n<pre><code class=\\\"language-javascript\\\">var options = [\\n    {\\n        group: 'Armament Options'\\n    },\\n    {\\n        names: [ 'weapon', 'w' ],\\n        type: 'string'\\n    },\\n    {\\n        group: 'General Options'\\n    },\\n    {\\n        names: [ 'help', 'h' ],\\n        type: 'bool'\\n    }\\n];\\n...\\n</code></pre>\\n<p>Note: You can use an empty string, <code>{group: ''}</code>, to get a blank line in help\\noutput between groups of options.</p>\\n<h1>Help config</h1>\\n<p>The <code>parser.help(...)</code> function is configurable as follows:</p>\\n<pre><code>    Options:\\n      Armament Options:\\n    ^^  -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |\\n   /                                sword, spear, maul                  |\\n  /   General Options:                                                  |\\n /      -h, --help                  Print this help and exit.           |\\n/   ^^^^                            ^                                   |\\n\\\\       `-- indent                   `-- helpCol              maxCol ---'\\n `-- headingIndent\\n</code></pre>\\n<ul>\\n<li><code>indent</code> (Number or String). Default 4. Set to a number (for that many\\nspaces) or a string for the literal indent.</li>\\n<li><code>headingIndent</code> (Number or String). Default half length of <code>indent</code>. Set to\\na number (for that many spaces) or a string for the literal indent. This\\nindent applies to group heading lines, between normal option lines.</li>\\n<li><code>nameSort</code> (String). Default is 'length'. By default the names are\\nsorted to put the short opts first (i.e. '-h, --help' preferred\\nto '--help, -h'). Set to 'none' to not do this sorting.</li>\\n<li><code>maxCol</code> (Number). Default 80. Note that reflow is just done on whitespace\\nso a long token in the option help can overflow maxCol.</li>\\n<li><code>helpCol</code> (Number). If not set a reasonable value will be determined\\nbetween <code>minHelpCol</code> and <code>maxHelpCol</code>.</li>\\n<li><code>minHelpCol</code> (Number). Default 20.</li>\\n<li><code>maxHelpCol</code> (Number). Default 40.</li>\\n<li><code>helpWrap</code> (Boolean). Default true. Set to <code>false</code> to have option <code>help</code>\\nstrings <em>not</em> be textwrapped to the helpCol..maxCol range.</li>\\n<li><code>includeEnv</code> (Boolean). Default false. If the option has associated\\nenvironment variables (via the <code>env</code> option spec attribute), then\\nappend mentioned of those envvars to the help string.</li>\\n<li><code>includeDefault</code> (Boolean). Default false. If the option has a default value\\n(via the <code>default</code> option spec attribute, or a default on the option's type),\\nthen a \\\"Default: VALUE\\\" string will be appended to the help string.</li>\\n</ul>\\n<h1>Custom option types</h1>\\n<p>Dashdash includes a good starter set of option types that it will parse for\\nyou. However, you can add your own via:</p>\\n<pre><code>var dashdash = require('dashdash');\\ndashdash.addOptionType({\\n    name: '...',\\n    takesArg: true,\\n    helpArg: '...',\\n    parseArg: function (option, optstr, arg) {\\n        ...\\n    },\\n    array: false,  // optional\\n    arrayFlatten: false,  // optional\\n    default: ...,   // optional\\n    completionType: ...  // optional\\n});\\n</code></pre>\\n<p>For example, a simple option type that accepts 'yes', 'y', 'no' or 'n' as\\na boolean argument would look like:</p>\\n<pre><code>var dashdash = require('dashdash');\\n\\nfunction parseYesNo(option, optstr, arg) {\\n    var argLower = arg.toLowerCase()\\n    if (~['yes', 'y'].indexOf(argLower)) {\\n        return true;\\n    } else if (~['no', 'n'].indexOf(argLower)) {\\n        return false;\\n    } else {\\n        throw new Error(format(\\n            'arg for \\\"%s\\\" is not \\\"yes\\\" or \\\"no\\\": \\\"%s\\\"',\\n            optstr, arg));\\n    }\\n}\\n\\ndashdash.addOptionType({\\n    name: 'yesno'\\n    takesArg: true,\\n    helpArg: '&#x3C;yes|no>',\\n    parseArg: parseYesNo\\n});\\n\\nvar options = {\\n    {names: ['answer', 'a'], type: 'yesno'}\\n};\\nvar opts = dashdash.parse({options: options});\\n</code></pre>\\n<p>See \\\"examples/custom-option-*.js\\\" for other examples.\\nSee the <code>addOptionType</code> block comment in \\\"lib/dashdash.js\\\" for more details.\\nPlease let me know <a href=\\\"https://github.com/trentm/node-dashdash/issues/new\\\">with an\\nissue</a> if you write a\\ngenerally useful one.</p>\\n<h1>Why</h1>\\n<p>Why another node.js option parsing lib?</p>\\n<ul>\\n<li>\\n<p><code>nopt</code> really is just for \\\"tools like npm\\\". Implicit opts (e.g. '--no-foo'\\nworks for every '--foo'). Can't disable abbreviated opts. Can't do multiple\\nusages of same opt, e.g. '-vvv' (I think). Can't do grouped short opts.</p>\\n</li>\\n<li>\\n<p><code>optimist</code> has surprise interpretation of options (at least to me).\\nImplicit opts mean ambiguities and poor error handling for fat-fingering.\\n<code>process.exit</code> calls makes it hard to use as a libary.</p>\\n</li>\\n<li>\\n<p><code>optparse</code> Incomplete docs. Is this an attempted clone of Python's <code>optparse</code>.\\nNot clear. Some divergence. <code>parser.on(\\\"name\\\", ...)</code> API is weird.</p>\\n</li>\\n<li>\\n<p><code>argparse</code> Dep on underscore. No thanks just for option processing.\\n<code>find lib | wc -l</code> -> <code>26</code>. Overkill.\\nArgparse is a bit different anyway. Not sure I want that.</p>\\n</li>\\n<li>\\n<p><code>posix-getopt</code> No type validation. Though that isn't a killer. AFAIK can't\\nhave a long opt without a short alias. I.e. no <code>getopt_long</code> semantics.\\nAlso, no whizbang features like generated help output.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://github.com/visionmedia/commander.js\\\">\\\"commander.js\\\"</a>: I wrote\\n<a href=\\\"http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html\\\">a critique</a>\\na while back. It seems fine, but last I checked had\\n<a href=\\\"https://github.com/visionmedia/commander.js/pull/121\\\">an outstanding bug</a>\\nthat would prevent me from using it.</p>\\n</li>\\n</ul>\\n<h1>License</h1>\\n<p>MIT. See LICENSE.txt.</p>\",\"docPath\":\"argo-ci/node_modules/dashdash/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-dashdash-readme-html-3f84bafa5d0530a2a15e.js","module.exports = {\"pathContext\":{\"docHtml\":\"<p>A light, featureful and explicit option parsing library for node.js.</p>\\n<p><a href=\\\"#why\\\">Why another one? See below</a>. tl;dr: The others I've tried are one of\\ntoo loosey goosey (not explicit), too big/too many deps, or ill specified.\\nYMMV.</p>\\n<p>Follow <a href=\\\"https://twitter.com/intent/user?screen_name=trentmick\\\" target=\\\"_blank\\\">@trentmick</a>\\nfor updates to node-dashdash.</p>\\n<h1>Install</h1>\\n<pre><code>npm install dashdash\\n</code></pre>\\n<h1>Usage</h1>\\n<pre><code class=\\\"language-javascript\\\">var dashdash = require('dashdash');\\n\\n// Specify the options. Minimally `name` (or `names`) and `type`\\n// must be given for each.\\nvar options = [\\n    {\\n        // `names` or a single `name`. First element is the `opts.KEY`.\\n        names: ['help', 'h'],\\n        // See \\\"Option specs\\\" below for types.\\n        type: 'bool',\\n        help: 'Print this help and exit.'\\n    }\\n];\\n\\n// Shortcut form. As called it infers `process.argv`. See below for\\n// the longer form to use methods like `.help()` on the Parser object.\\nvar opts = dashdash.parse({options: options});\\n\\nconsole.log(\\\"opts:\\\", opts);\\nconsole.log(\\\"args:\\\", opts._args);\\n</code></pre>\\n<h1>Longer Example</h1>\\n<p>A more realistic <a href=\\\"./examples/foo.js\\\">starter script \\\"foo.js\\\"</a> is as follows.\\nThis also shows using <code>parser.help()</code> for formatted option help.</p>\\n<pre><code class=\\\"language-javascript\\\">var dashdash = require('./lib/dashdash');\\n\\nvar options = [\\n    {\\n        name: 'version',\\n        type: 'bool',\\n        help: 'Print tool version and exit.'\\n    },\\n    {\\n        names: ['help', 'h'],\\n        type: 'bool',\\n        help: 'Print this help and exit.'\\n    },\\n    {\\n        names: ['verbose', 'v'],\\n        type: 'arrayOfBool',\\n        help: 'Verbose output. Use multiple times for more verbose.'\\n    },\\n    {\\n        names: ['file', 'f'],\\n        type: 'string',\\n        help: 'File to process',\\n        helpArg: 'FILE'\\n    }\\n];\\n\\nvar parser = dashdash.createParser({options: options});\\ntry {\\n    var opts = parser.parse(process.argv);\\n} catch (e) {\\n    console.error('foo: error: %s', e.message);\\n    process.exit(1);\\n}\\n\\nconsole.log(\\\"# opts:\\\", opts);\\nconsole.log(\\\"# args:\\\", opts._args);\\n\\n// Use `parser.help()` for formatted options help.\\nif (opts.help) {\\n    var help = parser.help({includeEnv: true}).trimRight();\\n    console.log('usage: node foo.js [OPTIONS]\\\\n'\\n                + 'options:\\\\n'\\n                + help);\\n    process.exit(0);\\n}\\n\\n// ...\\n</code></pre>\\n<p>Some example output from this script (foo.js):</p>\\n<pre><code>$ node foo.js -h\\n# opts: { help: true,\\n  _order: [ { name: 'help', value: true, from: 'argv' } ],\\n  _args: [] }\\n# args: []\\nusage: node foo.js [OPTIONS]\\noptions:\\n    --version             Print tool version and exit.\\n    -h, --help            Print this help and exit.\\n    -v, --verbose         Verbose output. Use multiple times for more verbose.\\n    -f FILE, --file=FILE  File to process\\n\\n$ node foo.js -v\\n# opts: { verbose: [ true ],\\n  _order: [ { name: 'verbose', value: true, from: 'argv' } ],\\n  _args: [] }\\n# args: []\\n\\n$ node foo.js --version arg1\\n# opts: { version: true,\\n  _order: [ { name: 'version', value: true, from: 'argv' } ],\\n  _args: [ 'arg1' ] }\\n# args: [ 'arg1' ]\\n\\n$ node foo.js -f bar.txt\\n# opts: { file: 'bar.txt',\\n  _order: [ { name: 'file', value: 'bar.txt', from: 'argv' } ],\\n  _args: [] }\\n# args: []\\n\\n$ node foo.js -vvv --file=blah\\n# opts: { verbose: [ true, true, true ],\\n  file: 'blah',\\n  _order:\\n   [ { name: 'verbose', value: true, from: 'argv' },\\n     { name: 'verbose', value: true, from: 'argv' },\\n     { name: 'verbose', value: true, from: 'argv' },\\n     { name: 'file', value: 'blah', from: 'argv' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>See the <a href=\\\"examples/\\\">\\\"examples\\\"</a> dir for a number of starter examples using\\nsome of dashdash's features.</p>\\n<h1>Environment variable integration</h1>\\n<p>If you want to allow environment variables to specify options to your tool,\\ndashdash makes this easy. We can change the 'verbose' option in the example\\nabove to include an 'env' field:</p>\\n<pre><code class=\\\"language-javascript\\\">    {\\n        names: ['verbose', 'v'],\\n        type: 'arrayOfBool',\\n        env: 'FOO_VERBOSE',         // &#x3C;--- add this line\\n        help: 'Verbose output. Use multiple times for more verbose.'\\n    },\\n</code></pre>\\n<p>then the <strong>\\\"FOO_VERBOSE\\\" environment variable</strong> can be used to set this\\noption:</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_VERBOSE=1 node foo.js\\n# opts: { verbose: [ true ],\\n  _order: [ { name: 'verbose', value: true, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>Boolean options will interpret the empty string as unset, '0' as false\\nand anything else as true.</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_VERBOSE= node examples/foo.js                 # not set\\n# opts: { _order: [], _args: [] }\\n# args: []\\n\\n$ FOO_VERBOSE=0 node examples/foo.js                # '0' is false\\n# opts: { verbose: [ false ],\\n  _order: [ { key: 'verbose', value: false, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n\\n$ FOO_VERBOSE=1 node examples/foo.js                # true\\n# opts: { verbose: [ true ],\\n  _order: [ { key: 'verbose', value: true, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n\\n$ FOO_VERBOSE=boogabooga node examples/foo.js       # true\\n# opts: { verbose: [ true ],\\n  _order: [ { key: 'verbose', value: true, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>Non-booleans can be used as well. Strings:</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_FILE=data.txt node examples/foo.js\\n# opts: { file: 'data.txt',\\n  _order: [ { key: 'file', value: 'data.txt', from: 'env' } ],\\n  _args: [] }\\n# args: []\\n</code></pre>\\n<p>Numbers:</p>\\n<pre><code class=\\\"language-shell\\\">$ FOO_TIMEOUT=5000 node examples/foo.js\\n# opts: { timeout: 5000,\\n  _order: [ { key: 'timeout', value: 5000, from: 'env' } ],\\n  _args: [] }\\n# args: []\\n\\n$ FOO_TIMEOUT=blarg node examples/foo.js\\nfoo: error: arg for \\\"FOO_TIMEOUT\\\" is not a positive integer: \\\"blarg\\\"\\n</code></pre>\\n<p>With the <code>includeEnv: true</code> config to <code>parser.help()</code> the environment\\nvariable can also be included in <strong>help output</strong>:</p>\\n<pre><code>usage: node foo.js [OPTIONS]\\noptions:\\n    --version             Print tool version and exit.\\n    -h, --help            Print this help and exit.\\n    -v, --verbose         Verbose output. Use multiple times for more verbose.\\n                          Environment: FOO_VERBOSE=1\\n    -f FILE, --file=FILE  File to process\\n</code></pre>\\n<h1>Bash completion</h1>\\n<p>Dashdash provides a simple way to create a Bash completion file that you\\ncan place in your \\\"bash<em>completion.d\\\" directory -- sometimes that is\\n\\\"/usr/local/etc/bash</em>completion.d/\\\"). Features:</p>\\n<ul>\\n<li>Support for short and long opts</li>\\n<li>Support for knowing which options take arguments</li>\\n<li>Support for subcommands (e.g. 'git log <TAB>' to show just options for the\\nlog subcommand). See\\n<a href=\\\"https://github.com/trentm/node-cmdln#bash-completion\\\">node-cmdln</a> for\\nhow to integrate that.</li>\\n<li>Does the right thing with \\\"--\\\" to stop options.</li>\\n<li>Custom optarg and arg types for custom completions.</li>\\n</ul>\\n<p>Dashdash will return bash completion file content given a parser instance:</p>\\n<pre><code>var parser = dashdash.createParser({options: options});\\nconsole.log( parser.bashCompletion({name: 'mycli'}) );\\n</code></pre>\\n<p>or directly from a <code>options</code> array of options specs:</p>\\n<pre><code>var code = dashdash.bashCompletionFromOptions({\\n    name: 'mycli',\\n    options: OPTIONS\\n});\\n</code></pre>\\n<p>Write that content to \\\"/usr/local/etc/bash_completion.d/mycli\\\" and you will\\nhave Bash completions for <code>mycli</code>. Alternatively you can write it to\\nany file (e.g. \\\"~/.bashrc\\\") and source it.</p>\\n<p>You could add a <code>--completion</code> hidden option to your tool that emits the\\ncompletion content and document for your users to call that to install\\nBash completions.</p>\\n<p>See <a href=\\\"examples/ddcompletion.js\\\">examples/ddcompletion.js</a> for a complete\\nexample, including how one can define bash functions for completion of custom\\noption types. Also see <a href=\\\"https://github.com/trentm/node-cmdln\\\">node-cmdln</a> for\\nhow it uses this for Bash completion for full multi-subcommand tools.</p>\\n<ul>\\n<li>TODO: document specExtra</li>\\n<li>TODO: document includeHidden</li>\\n<li>TODO: document custom types, <code>function complete\\\\_FOO</code> guide, completionType</li>\\n<li>TODO: document argtypes</li>\\n</ul>\\n<h1>Parser config</h1>\\n<p>Parser construction (i.e. <code>dashdash.createParser(CONFIG)</code>) takes the\\nfollowing fields:</p>\\n<ul>\\n<li>\\n<p><code>options</code> (Array of option specs). Required. See the\\n<a href=\\\"#option-specs\\\">Option specs</a> section below.</p>\\n</li>\\n<li>\\n<p><code>interspersed</code> (Boolean). Optional. Default is true. If true this allows\\ninterspersed arguments and options. I.e.:</p>\\n<pre><code>node ./tool.js -v arg1 arg2 -h   # '-h' is after interspersed args\\n</code></pre>\\n<p>Set it to false to have '-h' <strong>not</strong> get parsed as an option in the above\\nexample.</p>\\n</li>\\n<li>\\n<p><code>allowUnknown</code> (Boolean).  Optional.  Default is false.  If false, this causes\\nunknown arguments to throw an error.  I.e.:</p>\\n<pre><code>node ./tool.js -v arg1 --afe8asefksjefhas\\n</code></pre>\\n<p>Set it to true to treat the unknown option as a positional\\nargument.</p>\\n<p><strong>Caveat</strong>: When a shortopt group, such as <code>-xaz</code> contains a mix of\\nknown and unknown options, the <em>entire</em> group is passed through\\nunmolested as a positional argument.</p>\\n<p>Consider if you have a known short option <code>-a</code>, and parse the\\nfollowing command line:</p>\\n<pre><code>node ./tool.js -xaz\\n</code></pre>\\n<p>where <code>-x</code> and <code>-z</code> are unknown.  There are multiple ways to\\ninterpret this:</p>\\n<ol>\\n<li><code>-x</code> takes a value: <code>{x: 'az'}</code></li>\\n<li><code>-x</code> and <code>-z</code> are both booleans: <code>{x:true,a:true,z:true}</code></li>\\n</ol>\\n<p>Since dashdash does not know what <code>-x</code> and <code>-z</code> are, it can't know\\nif you'd prefer to receive <code>{a:true,_args:['-x','-z']}</code> or\\n<code>{x:'az'}</code>, or <code>{_args:['-xaz']}</code>. Leaving the positional arg unprocessed\\nis the easiest mistake for the user to recover from.</p>\\n</li>\\n</ul>\\n<h1>Option specs</h1>\\n<p>Example using all fields (required fields are noted):</p>\\n<pre><code class=\\\"language-javascript\\\">{\\n    names: ['file', 'f'],       // Required (one of `names` or `name`).\\n    type: 'string',             // Required.\\n    completionType: 'filename',\\n    env: 'MYTOOL_FILE',\\n    help: 'Config file to load before running \\\"mytool\\\"',\\n    helpArg: 'PATH',\\n    helpWrap: false,\\n    default: path.resolve(process.env.HOME, '.mytoolrc')\\n}\\n</code></pre>\\n<p>Each option spec in the <code>options</code> array must/can have the following fields:</p>\\n<ul>\\n<li>\\n<p><code>name</code> (String) or <code>names</code> (Array). Required. These give the option name\\nand aliases. The first name (if more than one given) is the key for the\\nparsed <code>opts</code> object.</p>\\n</li>\\n<li>\\n<p><code>type</code> (String). Required. One of:</p>\\n<ul>\\n<li>bool</li>\\n<li>string</li>\\n<li>number</li>\\n<li>integer</li>\\n<li>positiveInteger</li>\\n<li>date (epoch seconds, e.g. 1396031701, or ISO 8601 format\\n<code>YYYY-MM-DD[THH:MM:SS[.sss][Z]]</code>, e.g. \\\"2014-03-28T18:35:01.489Z\\\")</li>\\n<li>arrayOfBool</li>\\n<li>arrayOfString</li>\\n<li>arrayOfNumber</li>\\n<li>arrayOfInteger</li>\\n<li>arrayOfPositiveInteger</li>\\n<li>arrayOfDate</li>\\n</ul>\\n<p>FWIW, these names attempt to match with asserts on\\n<a href=\\\"https://github.com/mcavage/node-assert-plus\\\">assert-plus</a>.\\nYou can add your own custom option types with <code>dashdash.addOptionType</code>.\\nSee below.</p>\\n</li>\\n<li>\\n<p><code>completionType</code> (String). Optional. This is used for <a href=\\\"#bash-completion\\\">Bash\\ncompletion</a> for an option argument. If not specified,\\nthen the value of <code>type</code> is used. Any string may be specified, but only the\\nfollowing values have meaning:</p>\\n<ul>\\n<li><code>none</code>: Provide no completions.</li>\\n<li><code>file</code>: Bash's default completion (i.e. <code>complete -o default</code>), which\\nincludes filenames.</li>\\n<li><em>Any string FOO for which a <code>function complete_FOO</code> Bash function is\\ndefined.</em> This is for custom completions for a given tool. Typically\\nthese custom functions are provided in the <code>specExtra</code> argument to\\n<code>dashdash.bashCompletionFromOptions()</code>. See\\n<a href=\\\"examples/ddcompletion.js\\\">\\\"examples/ddcompletion.js\\\"</a> for an example.</li>\\n</ul>\\n</li>\\n<li>\\n<p><code>env</code> (String or Array of String). Optional. An environment variable name\\n(or names) that can be used as a fallback for this option. For example,\\ngiven a \\\"foo.js\\\" like this:</p>\\n<pre><code>var options = [{names: ['dry-run', 'n'], env: 'FOO_DRY_RUN'}];\\nvar opts = dashdash.parse({options: options});\\n</code></pre>\\n<p>Both <code>node foo.js --dry-run</code> and <code>FOO_DRY_RUN=1 node foo.js</code> would result\\nin <code>opts.dry_run = true</code>.</p>\\n<p>An environment variable is only used as a fallback, i.e. it is ignored if\\nthe associated option is given in <code>argv</code>.</p>\\n</li>\\n<li>\\n<p><code>help</code> (String). Optional. Used for <code>parser.help()</code> output.</p>\\n</li>\\n<li>\\n<p><code>helpArg</code> (String). Optional. Used in help output as the placeholder for\\nthe option argument, e.g. the \\\"PATH\\\" in:</p>\\n<pre><code>...\\n-f PATH, --file=PATH    File to process\\n...\\n</code></pre>\\n</li>\\n<li>\\n<p><code>helpWrap</code> (Boolean). Optional, default true. Set this to <code>false</code> to have\\nthat option's <code>help</code> <em>not</em> be text wrapped in <code>&#x3C;parser>.help()</code> output.</p>\\n</li>\\n<li>\\n<p><code>default</code>. Optional. A default value used for this option, if the\\noption isn't specified in argv.</p>\\n</li>\\n<li>\\n<p><code>hidden</code> (Boolean). Optional, default false. If true, help output will not\\ninclude this option. See also the <code>includeHidden</code> option to\\n<code>bashCompletionFromOptions()</code> for <a href=\\\"#bash-completion\\\">Bash completion</a>.</p>\\n</li>\\n</ul>\\n<h1>Option group headings</h1>\\n<p>You can add headings between option specs in the <code>options</code> array.  To do so,\\nsimply add an object with only a <code>group</code> property -- the string to print as\\nthe heading for the subsequent options in the array.  For example:</p>\\n<pre><code class=\\\"language-javascript\\\">var options = [\\n    {\\n        group: 'Armament Options'\\n    },\\n    {\\n        names: [ 'weapon', 'w' ],\\n        type: 'string'\\n    },\\n    {\\n        group: 'General Options'\\n    },\\n    {\\n        names: [ 'help', 'h' ],\\n        type: 'bool'\\n    }\\n];\\n...\\n</code></pre>\\n<p>Note: You can use an empty string, <code>{group: ''}</code>, to get a blank line in help\\noutput between groups of options.</p>\\n<h1>Help config</h1>\\n<p>The <code>parser.help(...)</code> function is configurable as follows:</p>\\n<pre><code>    Options:\\n      Armament Options:\\n    ^^  -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |\\n   /                                sword, spear, maul                  |\\n  /   General Options:                                                  |\\n /      -h, --help                  Print this help and exit.           |\\n/   ^^^^                            ^                                   |\\n\\\\       `-- indent                   `-- helpCol              maxCol ---'\\n `-- headingIndent\\n</code></pre>\\n<ul>\\n<li><code>indent</code> (Number or String). Default 4. Set to a number (for that many\\nspaces) or a string for the literal indent.</li>\\n<li><code>headingIndent</code> (Number or String). Default half length of <code>indent</code>. Set to\\na number (for that many spaces) or a string for the literal indent. This\\nindent applies to group heading lines, between normal option lines.</li>\\n<li><code>nameSort</code> (String). Default is 'length'. By default the names are\\nsorted to put the short opts first (i.e. '-h, --help' preferred\\nto '--help, -h'). Set to 'none' to not do this sorting.</li>\\n<li><code>maxCol</code> (Number). Default 80. Note that reflow is just done on whitespace\\nso a long token in the option help can overflow maxCol.</li>\\n<li><code>helpCol</code> (Number). If not set a reasonable value will be determined\\nbetween <code>minHelpCol</code> and <code>maxHelpCol</code>.</li>\\n<li><code>minHelpCol</code> (Number). Default 20.</li>\\n<li><code>maxHelpCol</code> (Number). Default 40.</li>\\n<li><code>helpWrap</code> (Boolean). Default true. Set to <code>false</code> to have option <code>help</code>\\nstrings <em>not</em> be textwrapped to the helpCol..maxCol range.</li>\\n<li><code>includeEnv</code> (Boolean). Default false. If the option has associated\\nenvironment variables (via the <code>env</code> option spec attribute), then\\nappend mentioned of those envvars to the help string.</li>\\n<li><code>includeDefault</code> (Boolean). Default false. If the option has a default value\\n(via the <code>default</code> option spec attribute, or a default on the option's type),\\nthen a \\\"Default: VALUE\\\" string will be appended to the help string.</li>\\n</ul>\\n<h1>Custom option types</h1>\\n<p>Dashdash includes a good starter set of option types that it will parse for\\nyou. However, you can add your own via:</p>\\n<pre><code>var dashdash = require('dashdash');\\ndashdash.addOptionType({\\n    name: '...',\\n    takesArg: true,\\n    helpArg: '...',\\n    parseArg: function (option, optstr, arg) {\\n        ...\\n    },\\n    array: false,  // optional\\n    arrayFlatten: false,  // optional\\n    default: ...,   // optional\\n    completionType: ...  // optional\\n});\\n</code></pre>\\n<p>For example, a simple option type that accepts 'yes', 'y', 'no' or 'n' as\\na boolean argument would look like:</p>\\n<pre><code>var dashdash = require('dashdash');\\n\\nfunction parseYesNo(option, optstr, arg) {\\n    var argLower = arg.toLowerCase()\\n    if (~['yes', 'y'].indexOf(argLower)) {\\n        return true;\\n    } else if (~['no', 'n'].indexOf(argLower)) {\\n        return false;\\n    } else {\\n        throw new Error(format(\\n            'arg for \\\"%s\\\" is not \\\"yes\\\" or \\\"no\\\": \\\"%s\\\"',\\n            optstr, arg));\\n    }\\n}\\n\\ndashdash.addOptionType({\\n    name: 'yesno'\\n    takesArg: true,\\n    helpArg: '&#x3C;yes|no>',\\n    parseArg: parseYesNo\\n});\\n\\nvar options = {\\n    {names: ['answer', 'a'], type: 'yesno'}\\n};\\nvar opts = dashdash.parse({options: options});\\n</code></pre>\\n<p>See \\\"examples/custom-option-*.js\\\" for other examples.\\nSee the <code>addOptionType</code> block comment in \\\"lib/dashdash.js\\\" for more details.\\nPlease let me know <a href=\\\"https://github.com/trentm/node-dashdash/issues/new\\\">with an\\nissue</a> if you write a\\ngenerally useful one.</p>\\n<h1>Why</h1>\\n<p>Why another node.js option parsing lib?</p>\\n<ul>\\n<li>\\n<p><code>nopt</code> really is just for \\\"tools like npm\\\". Implicit opts (e.g. '--no-foo'\\nworks for every '--foo'). Can't disable abbreviated opts. Can't do multiple\\nusages of same opt, e.g. '-vvv' (I think). Can't do grouped short opts.</p>\\n</li>\\n<li>\\n<p><code>optimist</code> has surprise interpretation of options (at least to me).\\nImplicit opts mean ambiguities and poor error handling for fat-fingering.\\n<code>process.exit</code> calls makes it hard to use as a libary.</p>\\n</li>\\n<li>\\n<p><code>optparse</code> Incomplete docs. Is this an attempted clone of Python's <code>optparse</code>.\\nNot clear. Some divergence. <code>parser.on(\\\"name\\\", ...)</code> API is weird.</p>\\n</li>\\n<li>\\n<p><code>argparse</code> Dep on underscore. No thanks just for option processing.\\n<code>find lib | wc -l</code> -> <code>26</code>. Overkill.\\nArgparse is a bit different anyway. Not sure I want that.</p>\\n</li>\\n<li>\\n<p><code>posix-getopt</code> No type validation. Though that isn't a killer. AFAIK can't\\nhave a long opt without a short alias. I.e. no <code>getopt_long</code> semantics.\\nAlso, no whizbang features like generated help output.</p>\\n</li>\\n<li>\\n<p><a href=\\\"https://github.com/visionmedia/commander.js\\\">\\\"commander.js\\\"</a>: I wrote\\n<a href=\\\"http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html\\\">a critique</a>\\na while back. It seems fine, but last I checked had\\n<a href=\\\"https://github.com/visionmedia/commander.js/pull/121\\\">an outstanding bug</a>\\nthat would prevent me from using it.</p>\\n</li>\\n</ul>\\n<h1>License</h1>\\n<p>MIT. See LICENSE.txt.</p>\",\"docPath\":\"argo-ci/node_modules/dashdash/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-dashdash-readme-html.json\n// module id = 2220\n// module chunks = 131140530568233"],"sourceRoot":""}