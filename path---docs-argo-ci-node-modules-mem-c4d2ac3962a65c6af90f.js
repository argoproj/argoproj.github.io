webpackJsonp([23895101922683],{2868:function(e,n){e.exports={pathContext:{docHtml:"<h1>mem <a href=\"https://travis-ci.org/sindresorhus/mem\"><img src=\"https://travis-ci.org/sindresorhus/mem.svg?branch=master\" alt=\"Build Status\"></a></h1>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Memoization\">Memoize</a> functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input</p>\n</blockquote>\n<h2>Install</h2>\n<pre><code>$ npm install --save mem\n</code></pre>\n<h2>Usage</h2>\n<pre><code class=\"language-js\">const mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n</code></pre>\n<h5>Works fine with promise returning functions</h5>\n<pre><code class=\"language-js\">const mem = require('mem');\n\nlet i = 0;\nconst counter = () => Promise.resolve(++i);\nconst memoized = mem(counter);\n\nmemoized().then(a => {\n    console.log(a);\n    //=> 1\n\n    memoized().then(b => {\n        // the return value didn't increase as it's cached\n        console.log(b);\n        //=> 1\n    });\n});\n</code></pre>\n<pre><code class=\"language-js\">const mem = require('mem');\nconst got = require('got');\nconst memGot = mem(got, {maxAge: 1000});\n\nmemGot('sindresorhus.com').then(() => {\n    // this call is cached\n    memGot('sindresorhus.com').then(() => {\n        setTimeout(() => {\n            // this call is not cached as the cache has expired\n            memGot('sindresorhus.com').then(() => {});\n        }, 2000);\n    });\n});\n</code></pre>\n<h2>API</h2>\n<h3>mem(fn, [options])</h3>\n<h4>fn</h4>\n<p>Type: <code>Function</code></p>\n<p>Function to be memoized.</p>\n<h4>options</h4>\n<h5>maxAge</h5>\n<p>Type: <code>number</code><br>\nDefault: <code>Infinity</code></p>\n<p>Milliseconds until the cache expires.</p>\n<h5>cacheKey</h5>\n<p>Type: <code>Function</code></p>\n<p>Determines the cache key for storing the result based on the function arguments. By default, if there's only one argument and it's a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">primitive</a>, it's used directly as a key, otherwise it's all the function arguments JSON stringified as an array.</p>\n<p>You could for example change it to only cache on the first argument <code>x => JSON.stringify(x)</code>.</p>\n<h5>cache</h5>\n<p>Type: <code>Object</code><br>\nDefault: <code>new Map()</code></p>\n<p>Use a different cache storage. Must implement the following methods: <code>.has(key)</code>, <code>.get(key)</code>, <code>.set(key, value)</code>, and optionally <code>.clear()</code>. You could for example use a <code>WeakMap</code> instead.</p>\n<h3>mem.clear(fn)</h3>\n<p>Clear all cached data of a memoized function.</p>\n<h4>fn</h4>\n<p>Type: <code>Function</code></p>\n<p>Memoized function.</p>\n<h2>Tips</h2>\n<h3>Cache statistics</h3>\n<p>If you want to know how many times your cache had a hit or a miss, you can make use of <a href=\"https://github.com/SamVerschueren/stats-map\">stats-map</a> as a replacement for the default cache.</p>\n<h4>Example</h4>\n<pre><code class=\"language-js\">const mem = require('mem');\nconst StatsMap = require('stats-map');\nconst got = require('got');\n\nconst cache = new StatsMap();\nconst memGot = mem(got, {cache});\n\nmemGot('sindresorhus.com')\n    .then(() => memGot('sindresorhus.com'))\n    .then(() => memGot('sindresorhus.com'));\n\nconsole.log(cache.stats);\n//=> {hits: 2, misses: 1}\n</code></pre>\n<h2>License</h2>\n<p>MIT Â© <a href=\"https://sindresorhus.com\">Sindre Sorhus</a></p>",docPath:"argo-ci/node_modules/mem/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-mem-c4d2ac3962a65c6af90f.js.map