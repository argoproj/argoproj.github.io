{"version":3,"sources":["webpack:///path---docs-argo-ci-node-modules-winston-readme-html-f28b52ec311731812ef7.js","webpack:///./.cache/json/docs-argo-ci-node-modules-winston-readme-html.json"],"names":["webpackJsonp","3404","module","exports","pathContext","docHtml","docPath","proj"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,QAAA;AAA09kCC,QAAA,sCAAAC,KAAA","file":"path---docs-argo-ci-node-modules-winston-readme-html-f28b52ec311731812ef7.js","sourcesContent":["webpackJsonp([28209167537949],{\n\n/***/ 3404:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"docHtml\":\"<h1>winston</h1>\\n<p>A logger for just about everything.</p>\\n<p><a href=\\\"https://www.npmjs.com/package/winston\\\"><img src=\\\"https://img.shields.io/npm/v/winston.svg?style=flat-square\\\" alt=\\\"Version npm\\\"></a><a href=\\\"https://npmcharts.com/compare/winston?minimal=true\\\"><img src=\\\"https://img.shields.io/npm/dm/winston.svg?style=flat-square\\\" alt=\\\"npm Downloads\\\"></a><a href=\\\"https://travis-ci.org/winstonjs/winston\\\"><img src=\\\"https://img.shields.io/travis/winstonjs/winston/master.svg?style=flat-square\\\" alt=\\\"Build Status\\\"></a><a href=\\\"https://david-dm.org/winstonjs/winston\\\"><img src=\\\"https://img.shields.io/david/winstonjs/winston.svg?style=flat-square\\\" alt=\\\"Dependencies\\\"></a></p>\\n<p><a href=\\\"https://nodei.co/npm/winston/\\\"><img src=\\\"https://nodei.co/npm/winston.png?downloads=true&#x26;downloadRank=true\\\" alt=\\\"NPM\\\"></a></p>\\n<p><a href=\\\"https://gitter.im/winstonjs/winston?utm_source=badge&#x26;utm_medium=badge&#x26;utm_campaign=pr-badge&#x26;utm_content=badge\\\"><img src=\\\"https://badges.gitter.im/Join%20Chat.svg\\\" alt=\\\"Join the chat at https://gitter.im/winstonjs/winston\\\"></a></p>\\n<h2>winston@3.0.0</h2>\\n<p>See the <a href=\\\"UPGRADE-3.0.html\\\">Upgrade Guide</a> for more information. Bug reports and\\nPRs welcome!</p>\\n<h2>Looking for <code>winston@2.x</code> documentation?</h2>\\n<p>Please note that the documentation below is for <code>winston@3</code>.\\n<a href=\\\"https://github.com/winstonjs/winston/tree/2.x\\\">Read the <code>winston@2.x</code> documentation</a>.</p>\\n<h2>Motivation</h2>\\n<p><code>winston</code> is designed to be a simple and universal logging library with\\nsupport for multiple transports. A transport is essentially a storage device\\nfor your logs. Each <code>winston</code> logger can have multiple transports (see:\\n<a href=\\\"#transports\\\">Transports</a>) configured at different levels (see: <a href=\\\"#logging-levels\\\">Logging levels</a>). For\\nexample, one may want error logs to be stored in a persistent remote location\\n(like a database), but all logs output to the console or a local file.</p>\\n<p><code>winston</code> aims to decouple parts of the logging process to make it more\\nflexible and extensible. Attention is given to supporting flexibility in log\\nformatting (see: <a href=\\\"#formats\\\">Formats</a>) &#x26; levels (see: <a href=\\\"#using-custom-logging-levels\\\">Using custom logging levels</a>), and\\nensuring those APIs decoupled from the implementation of transport logging\\n(i.e. how the logs are stored / indexed, see: <a href=\\\"#adding-custom-transports\\\">Adding Custom Transports</a>) to\\nthe API that they exposed to the programmer.</p>\\n<h2>Usage</h2>\\n<p>The recommended way to use <code>winston</code> is to create your own logger. The\\nsimplest way to do this is using <code>winston.createLogger</code>:</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  level: 'info',\\n  format: winston.format.json(),\\n  transports: [\\n    //\\n    // - Write to all logs with level `info` and below to `combined.log` \\n    // - Write all logs error (and below) to `error.log`.\\n    //\\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\\n    new winston.transports.File({ filename: 'combined.log' })\\n  ]\\n});\\n\\n//\\n// If we're not in production then log to the `console` with the format:\\n// `${info.level}: ${info.message} JSON.stringify({ ...rest }) `\\n// \\nif (process.env.NODE_ENV !== 'production') {\\n  logger.add(new winston.transports.Console({\\n    format: winston.format.simple()\\n  }));\\n}\\n</code></pre>\\n<p>You may also log directly via the default logger exposed by\\n<code>require('winston')</code>, but this merely intended to be a convenient shared\\nlogger to use throughout your application if you so choose.</p>\\n<h2>Table of contents</h2>\\n<ul>\\n<li>\\n<p><a href=\\\"#logging\\\">Logging</a></p>\\n<ul>\\n<li><a href=\\\"#creating-your-own-logger\\\">Creating your logger</a></li>\\n<li><a href=\\\"#streams-objectmode-and-info-objects\\\">Streams, <code>objectMode</code>, and <code>info</code> objects</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#formats\\\">Formats</a></p>\\n<ul>\\n<li><a href=\\\"#combining-formats\\\">Combining formats</a></li>\\n<li><a href=\\\"#string-interpolation\\\">String interpolation</a></li>\\n<li><a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> Objects</a></li>\\n<li><a href=\\\"#creating-custom-formats\\\">Creating custom formats</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#logging-levels\\\">Logging levels</a></p>\\n<ul>\\n<li><a href=\\\"#using-logging-levels\\\">Using logging levels</a></li>\\n<li><a href=\\\"#using-custom-logging-levels\\\">Using custom logging levels</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#transports\\\">Transports</a></p>\\n<ul>\\n<li><a href=\\\"#multiple-transports-of-the-same-type\\\">Multiple transports of the same type</a></li>\\n<li><a href=\\\"#adding-custom-transports\\\">Adding Custom Transports</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#exceptions\\\">Exceptions</a></p>\\n<ul>\\n<li><a href=\\\"#handling-uncaught-exceptions-with-winston\\\">Handling Uncaught Exceptions with winston</a></li>\\n<li><a href=\\\"#to-exit-or-not-to-exit\\\">To Exit or Not to Exit</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#profiling\\\">Profiling</a></li>\\n<li><a href=\\\"#streaming-logs\\\">Streaming Logs</a></li>\\n<li><a href=\\\"#querying-logs\\\">Querying Logs</a></li>\\n<li>\\n<p><a href=\\\"#further-reading\\\">Further Reading</a></p>\\n<ul>\\n<li><a href=\\\"#using-the-default-logger\\\">Using the default logger</a></li>\\n<li><a href=\\\"#awaiting-logs-to-be-written-in-winston\\\">Awaiting logs to be written in <code>winston</code></a></li>\\n<li><a href=\\\"#working-with-multiple-loggers-in-winston\\\">Working with multiple Loggers in <code>winston</code></a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#installation\\\">Installation</a></li>\\n<li><a href=\\\"#run-tests\\\">Run Tests</a></li>\\n</ul>\\n<h2>Logging</h2>\\n<p>Logging levels in <code>winston</code> conform to the severity ordering specified by\\n<a href=\\\"https://tools.ietf.org/html/rfc5424\\\">RFC5424</a>: <em>severity of all levels is assumed to be numerically <strong>ascending</strong>\\nfrom most important to least important.</em></p>\\n<pre><code class=\\\"language-js\\\">const levels = { \\n  error: 0, \\n  warn: 1, \\n  info: 2, \\n  verbose: 3, \\n  debug: 4, \\n  silly: 5 \\n};\\n</code></pre>\\n<h3>Creating your own Logger</h3>\\n<p>You get started by creating a logger using <code>winston.createLogger</code>:</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.Console(),\\n    new winston.transports.File({ filename: 'combined.log' })\\n  ]\\n});\\n</code></pre>\\n<p>A logger acceptsÂ the following parameters:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>level</code></td>\\n<td><code>'info'</code></td>\\n<td>Log only if \\n<a href=\\\"#streams-objectmode-and-info-objects\\\"><code>info.level</code></a>\\n less than or equal to this level</td>\\n</tr>\\n<tr>\\n<td><code>levels</code></td>\\n<td><code>winston.config.npm</code></td>\\n<td>Levels (and colors) representing log priorities</td>\\n</tr>\\n<tr>\\n<td><code>format</code></td>\\n<td><code>winston.format.json</code></td>\\n<td>Formatting for \\n<code>info</code>\\n messages  (see: \\n<a href=\\\"#formats\\\">Formats</a>\\n)</td>\\n</tr>\\n<tr>\\n<td><code>transports</code></td>\\n<td><code>[]</code>\\n \\n<em>(No transports)</em></td>\\n<td>Set of logging targets for \\n<code>info</code>\\n messages</td>\\n</tr>\\n<tr>\\n<td><code>exitOnError</code></td>\\n<td><code>true</code></td>\\n<td>If false, handled exceptions will not cause \\n<code>process.exit</code></td>\\n</tr>\\n<tr>\\n<td><code>silent</code></td>\\n<td><code>false</code></td>\\n<td>If true, all logs are suppressed</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>The levels provided to <code>createLogger</code> will be defined as convenience methods\\non the <code>logger</code> returned. </p>\\n<pre><code class=\\\"language-js\\\">//\\n// Logging\\n//\\nlogger.log({\\n  level: 'info',\\n  message: 'Hello distributed log files!'\\n});\\n\\nlogger.info('Hello again distributed logs');\\n</code></pre>\\n<p>You can add or remove transports from the <code>logger</code> once it has been provided\\nto you from <code>winston.createLogger</code>:</p>\\n<pre><code class=\\\"language-js\\\">const files = new winston.transports.File({ filename: 'combined.log' });\\nconst console = new winston.transports.Console();\\n\\nlogger\\n  .clear()          // Remove all transports\\n  .add(console)     // Add console transport\\n  .add(files)       // Add file transport\\n  .remove(console); // Remove console transport\\n</code></pre>\\n<p>You can also wholesale reconfigure a <code>winston.Logger</code> instance using the\\n<code>configure</code> method:</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  level: 'info',\\n  transports: [\\n    new winston.transports.Console(),\\n    new winston.transports.File({ filename: 'combined.log' })\\n  ]\\n});\\n\\n//\\n// Replaces the previous transports with those in the\\n// new configuration wholesale.\\n//\\nconst DailyRotateFile = require('winston-daily-rotate-file');\\nlogger.configure({\\n  level: 'verbose',\\n  transports: [\\n    new DailyRotateFile(opts)\\n  ]\\n});\\n</code></pre>\\n<h3>Streams, <code>objectMode</code>, and <code>info</code> objects</h3>\\n<p>In <code>winston</code>, both <code>Logger</code> and <code>Transport</code> instances are treated as\\n<a href=\\\"https://nodejs.org/api/stream.html#stream_object_mode\\\"><code>objectMode</code></a>\\nstreams that accept an <code>info</code> object. The <code>info</code> object represents a\\nsingle log message. The object itself is mutable. Every <code>info</code> must\\nhave at least the <code>level</code> and <code>message</code> properties:</p>\\n<pre><code class=\\\"language-js\\\">{\\n  level: 'info',                 // Level of the logging message  \\n  message: 'Hey! Log something?' // Descriptive message being logged.\\n}\\n</code></pre>\\n<p><code>winston.format</code> itself exposes several additional properties:</p>\\n<ul>\\n<li><code>splat</code>: string interpolation splat for <code>%d %s</code>-style messages.</li>\\n<li><code>timestamp</code>: timestamp the message was received.</li>\\n<li><code>label</code>: custom label associated with each message.</li>\\n</ul>\\n<p>As a consumer you may add whatever properties you wish âÂ <em>internal state is\\nmaintained by <code>Symbol</code> properties:</em></p>\\n<ul>\\n<li><code>Symbol.for('level')</code> <em><strong>(READ-ONLY)</strong>:</em> equal to <code>level</code> property. Is\\ntreated as immutable by all code.  </li>\\n<li><code>Symbol.for('message'):</code> complete string message set by \\\"finalizing\\nformats\\\": <code>json</code>, <code>logstash</code>, <code>printf</code>, <code>prettyPrint</code>, and <code>simple</code>. </li>\\n</ul>\\n<h2>Formats</h2>\\n<p>Formats in <code>winston</code> can be accessed from <code>winston.format</code>. They are\\nimplemented in <a href=\\\"https://github.com/winstonjs/logform\\\"><code>logform</code></a>, a separate\\nmodule from <code>winston</code>. This allows flexibility when writing your own transports\\nin case you wish to include a default format with your transport.</p>\\n<p>In modern versions of <code>node</code> template strings are very performant and are the\\nrecommended way for doing most end-user formatting. If you want to bespoke\\nformat your logs, <code>winston.format.printf</code> is for you:</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\nconst { combine, timestamp, label, printf } = format;\\n\\nconst myFormat = printf(info => {\\n  return `${info.timestamp} [${info.label}] ${info.level}: ${info.message}`;\\n});\\n\\nconst logger = createLogger({\\n  format: combine(\\n    label({ label: 'right meow!' }),\\n    timestamp(),\\n    myFormat\\n  ),\\n  transports: [new transports.Console()]\\n});\\n</code></pre>\\n<p>To see what built-in formats are available and learn more about creating your\\nown custom logging formats, see\\n<a href=\\\"https://github.com/winstonjs/logform\\\"><code>logform</code></a>.</p>\\n<h3>Combining formats</h3>\\n<p>Any number of formats may be combined into a single format using\\n<code>format.combine</code>. Since <code>format.combine</code> takes no <code>opts</code>, as a convenience it\\nreturns pre-created instance of the combined format.</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\nconst { combine, timestamp, label, prettyPrint } = format;\\n\\nconst logger = createLogger({\\n  format: combine(\\n    label({ label: 'right meow!' }),\\n    timestamp(),\\n    prettyPrint()\\n  ),\\n  transports: [new transports.Console()]\\n})\\n\\nlogger.log({\\n  level: 'info',\\n  message: 'What time is the testing at?'\\n});\\n// Outputs:\\n// { level: 'info',\\n//   message: 'What time is the testing at?',\\n//   label: 'right meow!',\\n//   timestamp: '2017-09-30T03:57:26.875Z' }\\n</code></pre>\\n<h3>String interpolation</h3>\\n<p>The <code>log</code> method provides the string interpolation using <a href=\\\"https://nodejs.org/dist/latest/docs/api/util.html#util_util_format_format_args\\\">util.format</a>. <strong>It\\nmust be enabled using <code>format.splat</code>.</strong></p>\\n<p>Below is an example that defines a format with string interpolation of\\nmessages using <code>format.splat</code> and then serializes the entire <code>info</code> message\\nusing <code>format.simple</code>.</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\nconst logger = createLogger({\\n  format: format.combine(\\n    format.splat(),\\n    format.simple()\\n  ),\\n  transports: [new transports.Console()]\\n});\\n\\n//Â info: test message my string {}\\nlogger.log('info', 'test message %s', 'my string');\\n\\n//Â info: test message 123 {}\\nlogger.log('info', 'test message %d', 123);\\n\\n// info: test message first second {number: 123}\\nlogger.log('info', 'test message %s, %s', 'first', 'second', { number: 123 });\\n</code></pre>\\n<h3>Filtering <code>info</code> Objects</h3>\\n<p>If you wish to filter out a given <code>info</code> Object completely when logging then\\nsimply return a falsey value.</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\n\\n// Ignore log messages if they have { private: true }\\nconst ignorePrivate = format((info, opts) => {\\n  if (info.private) { return false; }\\n  return info;\\n});\\n\\nconst logger = createLogger({\\n  format: format.combine(\\n    ignorePrivate(),\\n    format.json()\\n  ),\\n  transports: [new transports.Console()]\\n});\\n\\n// Outputs: {\\\"level\\\":\\\"error\\\",\\\"message\\\":\\\"Public error to share\\\"}\\nlogger.log({\\n  level: 'error',\\n  message: 'Public error to share'\\n});\\n\\n// Messages with { private: true } will not be written when logged.\\nlogger.log({\\n  private: true,\\n  level: 'error',\\n  message: 'This is super secret - hide it.'\\n});\\n</code></pre>\\n<p>Use of <code>format.combine</code> will respect any falsey values return and stop\\nevaluation of later formats in the series. For example:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('winston');\\nconst { combine, timestamp, label } = format;\\n\\nconst willNeverThrow = format.combine(\\n  format(info => { return false })(), // Ignores everything\\n  format(info => { throw new Error('Never reached') })()\\n);\\n</code></pre>\\n<h3>Creating custom formats</h3>\\n<p>Formats are prototypal objects (i.e. class instances) that define a single\\nmethod: <code>transform(info, opts)</code> and return the mutated <code>info</code>:</p>\\n<ul>\\n<li><code>info</code>: an object representing the log message.</li>\\n<li><code>opts</code>: setting specific to the current instance of the format.</li>\\n</ul>\\n<p>They are expected to return one of two things:</p>\\n<ul>\\n<li><strong>An <code>info</code> Object</strong> representing the modified <code>info</code> argument. Object\\nreferences need not be preservedÂ if immutability is preferred. All current\\nbuilt-in formats consider <code>info</code> mutable, but [immutablejs] is being\\nconsidered for future releases.</li>\\n<li><strong>A falsey value</strong> indicating that the <code>info</code> argument should be ignored by the\\ncaller. (See: <a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> Objects</a>) below.</li>\\n</ul>\\n<p><code>winston.format</code> is designed to be as simple as possible. To define a new\\nformat simple pass it a <code>transform(info, opts)</code> function to get a new\\n<code>Format</code>.</p>\\n<p>The named <code>Format</code> returned can be used to create as many copies of the given\\n<code>Format</code> as desired:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('winston');\\n\\nconst volume = format((info, opts) => {\\n  if (opts.yell) {\\n    info.message = info.message.toUpperCase();\\n  } else if (opts.whisper) {\\n    info.message = info.message.toLowerCase();\\n  }\\n\\n  return info;\\n});\\n\\n// `volume` is now a function that returns instances of the format.\\nconst scream = volume({ yell: true });\\nconsole.dir(scream.transform({\\n  level: 'info',\\n  message: `sorry for making you YELL in your head!`\\n}, scream.options));\\n// {\\n//   level: 'info'\\n//   message: 'SORRY FOR MAKING YOU YELL IN YOUR HEAD!'\\n// }\\n\\n// `volume` can be used multiple times to create different formats.\\nconst whisper = volume({ whisper: true });\\nconsole.dir(whisper.transform({\\n  level: 'info',\\n  message: `WHY ARE THEY MAKING US YELL SO MUCH!`\\n}, whisper.options));\\n// {\\n//   level: 'info'\\n//   message: 'why are they making us yell so much!'\\n// }\\n</code></pre>\\n<h2>Logging Levels</h2>\\n<p>Logging levels in <code>winston</code> conform to the severity ordering specified by\\n<a href=\\\"https://tools.ietf.org/html/rfc5424\\\">RFC5424</a>: <em>severity of all levels is assumed to be numerically <strong>ascending</strong>\\nfrom most important to least important.</em></p>\\n<p>Each <code>level</code> is given a specific integer priority. The higher the priority the\\nmore important the message is considered to be, and the lower the\\ncorresponding integer priority.  For example, as specified exactly in RFC5424\\nthe <code>syslog</code> levels are prioritized from 0 to 7 (highest to lowest).</p>\\n<pre><code class=\\\"language-js\\\">{ \\n  emerg: 0, \\n  alert: 1, \\n  crit: 2, \\n  error: 3, \\n  warning: 4, \\n  notice: 5, \\n  info: 6, \\n  debug: 7\\n}\\n</code></pre>\\n<p>Similarly, <code>npm</code> logging levels are prioritized from 0 to 5 (highest to\\nlowest):</p>\\n<pre><code class=\\\"language-js\\\">{ \\n  error: 0, \\n  warn: 1, \\n  info: 2, \\n  verbose: 3, \\n  debug: 4, \\n  silly: 5 \\n}\\n</code></pre>\\n<p>If you do not explicitly define the levels that <code>winston</code> should use the\\n<code>npm</code> levels above will be used.</p>\\n<h3>Using Logging Levels</h3>\\n<p>Setting the level for your logging message can be accomplished in one of two\\nways. You can pass a string representing the logging level to the log() method\\nor use the level specified methods defined on every winston Logger.</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Any logger instance\\n//\\nlogger.log('silly', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('debug', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('verbose', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('info', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('warn', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('error', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.info(\\\"127.0.0.1 - there's no place like home\\\");\\nlogger.warn(\\\"127.0.0.1 - there's no place like home\\\");\\nlogger.error(\\\"127.0.0.1 - there's no place like home\\\");\\n\\n//\\n// Default logger\\n//\\nwinston.log('info', \\\"127.0.0.1 - there's no place like home\\\");\\nwinston.info(\\\"127.0.0.1 - there's no place like home\\\");\\n</code></pre>\\n<p><code>winston</code> allows you to define a <code>level</code> property on each transport which\\nspecifies the <strong>maximum</strong> level of messages that a transport should log. For\\nexample, using the <code>syslog</code> levels you could log only <code>error</code> messages to the\\nconsole and everything <code>info</code> and below to a file (which includes <code>error</code>\\nmessages):</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  levels: winston.config.syslog.levels,\\n  transports: [\\n    new winston.transports.Console({ level: 'error' }),\\n    new winston.transports.File({\\n      filename: 'combined.log',\\n      level: 'info'\\n    })\\n  ]\\n});\\n</code></pre>\\n<p>You may also dynamically change the log level of a transport:</p>\\n<pre><code class=\\\"language-js\\\">const transports = {\\n  console: new winston.transports.Console({ level: 'warn' }),\\n  file: new winston.transports.File({ filename: 'combined.log', level: 'error' })\\n};\\n\\nconst logger = winston.createLogger({\\n  transports: [\\n    transports.console,\\n    transports.file\\n  ]\\n});\\n\\nlogger.info('Will not be logged in either transport!');\\ntransports.console.level = 'info';\\ntransports.file.level = 'info';\\nlogger.info('Will be logged in both transports!');\\n</code></pre>\\n<p><code>winston</code> supports customizable logging levels, defaulting to npm style\\nlogging levels. Levels must be specified at the time of creating your logger.</p>\\n<h3>Using Custom Logging Levels</h3>\\n<p>In addition to the predefined <code>npm</code>, <code>syslog</code>, and <code>cli</code> levels available in\\n<code>winston</code>, you can also choose to define your own:</p>\\n<pre><code class=\\\"language-js\\\">const myCustomLevels = {\\n  levels: {\\n    foo: 0,\\n    bar: 1,\\n    baz: 2,\\n    foobar: 3\\n  },\\n  colors: {\\n    foo: 'blue',\\n    bar: 'green',\\n    baz: 'yellow',\\n    foobar: 'red'\\n  }\\n};\\n\\nconst customLevelLogger = winston.createLogger({ \\n  levels: myCustomLevels.levels \\n});\\n\\ncustomLevelLogger.foobar('some foobar level-ed message');\\n</code></pre>\\n<p>Although there is slight repetition in this data structure, it enables simple\\nencapsulation if you do not want to have colors. If you do wish to have\\ncolors, in addition to passing the levels to the Logger itself, you must make\\nwinston aware of them:</p>\\n<pre><code class=\\\"language-js\\\">winston.addColors(myCustomLevels.colors);\\n</code></pre>\\n<p>This enables loggers using the <code>colorize</code> formatter to appropriately color and style\\nthe output of custom levels.</p>\\n<p>Additionally, you can also change background color and font style.\\nFor example,</p>\\n<pre><code class=\\\"language-js\\\">baz: 'italic yellow',\\nfoobar: 'bold red cyanBG'\\n</code></pre>\\n<p>Possible options are below.</p>\\n<ul>\\n<li>\\n<p>Font styles: <code>bold</code>, <code>dim</code>, <code>italic</code>, <code>underline</code>, <code>inverse</code>, <code>hidden</code>,\\n<code>strikethrough</code>.</p>\\n</li>\\n<li>\\n<p>Font foreground colors: <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>,\\n<code>cyan</code>, <code>white</code>, <code>gray</code>, <code>grey</code>.</p>\\n</li>\\n<li>\\n<p>Background colors: <code>blackBG</code>, <code>redBG</code>, <code>greenBG</code>, <code>yellowBG</code>, <code>blueBG</code>\\n<code>magentaBG</code>, <code>cyanBG</code>, <code>whiteBG</code></p>\\n</li>\\n</ul>\\n<h3>Colorizing Standard logging levels</h3>\\n<p>To colorize the standard logging level add</p>\\n<pre><code class=\\\"language-js\\\">winston.format.combine(\\n  winston.format.colorize(),\\n  winston.format.json()\\n);\\n</code></pre>\\n<p>where <code>winston.format.json()</code> is whatever other formatter you want to use.  The <code>colorize</code> formatter must come before any formatters adding text you wish to color.</p>\\n<h2>Transports</h2>\\n<p>There are several <a href=\\\"docs/transports.md#winston-core\\\">core transports</a> included in  <code>winston</code>, which leverage the\\nbuilt-in networking and file I/O offered by Node.js core. In addition, there\\nare <a href=\\\"docs/transports.md#additional-transports\\\">additional transports</a> written by members of the community.</p>\\n<h2>Multiple transports of the same type</h2>\\n<p>It is possible to use multiple transports of the same type e.g.\\n<code>winston.transports.File</code> when you construct the transport.</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.File({\\n      filename: 'combined.log',\\n      level: 'info'\\n    }),\\n    new winston.transports.File({\\n      filename: 'errors.log',\\n      level: 'error'\\n    })\\n  ]\\n});\\n</code></pre>\\n<p>If you later want to remove one of these transports you can do so by using the\\ntransport itself. e.g.:</p>\\n<pre><code class=\\\"language-js\\\">const combinedLogs = logger.transports.find(transport => {\\n  return transport.filename === 'combined.log'\\n});\\n\\nlogger.remove(combinedLogs);\\n</code></pre>\\n<h2>Adding Custom Transports</h2>\\n<p>Adding a custom transport is easy. All you need to do is accept any options\\nyou need, implement a log() method, and consume it with <code>winston</code>.</p>\\n<pre><code class=\\\"language-js\\\">const Transport = require('winston-transport');\\nconst util = require('util');\\n\\n//\\n// Inherit from `winston-transport` so you can take advantage\\n// of the base functionality and `.exceptions.handle()`.\\n//\\nmodule.exports = class YourCustomTransport extends Transport {\\n  constructor(opts) {\\n    super(opts);\\n    //\\n    // Consume any custom options here. e.g.:\\n    // - Connection information for databases\\n    // - Authentication information for APIs (e.g. loggly, papertrail, \\n    //   logentries, etc.).\\n    //\\n  }\\n\\n  log(info, callback) {\\n    setImmediate(() => {\\n      this.emit('logged', info);\\n    });\\n\\n    // Perform the writing to the remote service\\n    callback();\\n  }\\n};\\n</code></pre>\\n<h2>Exceptions</h2>\\n<h3>Handling Uncaught Exceptions with winston</h3>\\n<p>With <code>winston</code>, it is possible to catch and log <code>uncaughtException</code> events\\nfrom your process. With your own logger instance you can enable this behavior\\nwhen it's created or later on in your applications lifecycle:</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, transports } = require('winston');\\n\\n// Enable exception handling when you create your logger.\\nconst logger = createLogger({\\n  transports: [\\n    new transports.File({ filename: 'combined.log' }) \\n  ],\\n  exceptionHandlers: [\\n    new transports.File({ filename: 'exceptions.log' })\\n  ]\\n});\\n\\n// Or enable it later on by adding a transport or using `.exceptions.handle`\\nconst logger = createLogger({\\n  transports: [\\n    new transports.File({ filename: 'combined.log' }) \\n  ]\\n});\\n\\n// Call exceptions.handle with a transport to handle exceptions\\nlogger.exceptions.handle(\\n  new transports.File({ filename: 'exceptions.log' })\\n);\\n</code></pre>\\n<p>If you want to use this feature with the default logger, simply call\\n<code>.exceptions.handle()</code> with a transport instance.</p>\\n<pre><code class=\\\"language-js\\\">//\\n// You can add a separate exception logger by passing it to `.exceptions.handle`\\n//\\nwinston.exceptions.handle(\\n  new winston.transports.File({ filename: 'path/to/exceptions.log' })\\n);\\n\\n//\\n// Alternatively you can set `handleExceptions` to true when adding transports\\n// to winston.\\n//\\nwinston.add(new winston.transports.File({\\n  filename: 'path/to/combined.log',\\n  handleExceptions: true\\n}));\\n</code></pre>\\n<h3>To Exit or Not to Exit</h3>\\n<p>By default, winston will exit after logging an uncaughtException. If this is\\nnot the behavior you want, set <code>exitOnError = false</code></p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({ exitOnError: false });\\n\\n//\\n// or, like this:\\n//\\nlogger.exitOnError = false;\\n</code></pre>\\n<p>When working with custom logger instances, you can pass in separate transports\\nto the <code>exceptionHandlers</code> property or set <code>handleExceptions</code> on any\\ntransport.</p>\\n<h5>Example 1</h5>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.File({ filename: 'path/to/combined.log' })\\n  ],\\n  exceptionHandlers: [\\n    new winston.transports.File({ filename: 'path/to/exceptions.log' })\\n  ]\\n});\\n</code></pre>\\n<h5>Example 2</h5>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.Console({\\n      handleExceptions: true\\n    })\\n  ],\\n  exitOnError: false\\n});\\n</code></pre>\\n<p>The <code>exitOnError</code> option can also be a function to prevent exit on only\\ncertain types of errors:</p>\\n<pre><code class=\\\"language-js\\\">function ignoreEpipe(err) {\\n  return err.code !== 'EPIPE';\\n}\\n\\nconst logger = winston.createLogger({ exitOnError: ignoreEpipe });\\n\\n//\\n// or, like this:\\n//\\nlogger.exitOnError = ignoreEpipe;\\n</code></pre>\\n<h2>Profiling</h2>\\n<p>In addition to logging messages and metadata, <code>winston</code> also has a simple\\nprofiling mechanism implemented for any logger:</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Start profile of 'test'\\n//\\nlogger.profile('test');\\n\\nsetTimeout(function () {\\n  //\\n  // Stop profile of 'test'. Logging will now take place:\\n  //   '17 Jan 21:00:00 - info: test duration=1000ms'\\n  //\\n  logger.profile('test');\\n}, 1000);\\n</code></pre>\\n<p>Also you can start a timer and keep a reference that you can call `.done()<code></code>\\non:</p>\\n<pre><code class=\\\"language-js\\\"> // Returns an object corresponding to a specific timing. When done\\n // is called the timer will finish and log the duration. e.g.:\\n //\\n const profiler = logger.startTimer();\\n setTimeout(function () {\\n   profiler.done({ message: 'Logging message' });\\n }, 1000);\\n</code></pre>\\n<p>All profile messages are set to 'info' level by default, and both message and\\nmetadata are optional.  For individual profile messages, you can override the default log level by supplying a metadata object with a <code>level</code> property:</p>\\n<pre><code class=\\\"language-js\\\">logger.profile('test', { level: 'debug' });\\n</code></pre>\\n<h2>Querying Logs</h2>\\n<p><code>winston</code> supports querying of logs with Loggly-like options. <a href=\\\"https://www.loggly.com/docs/api-retrieving-data/\\\">See Loggly\\nSearch API</a>. Specifically:\\n<code>File</code>, <code>Couchdb</code>, <code>Redis</code>, <code>Loggly</code>, <code>Nssocket</code>, and <code>Http</code>.</p>\\n<pre><code class=\\\"language-js\\\">const options = {\\n  from: new Date() - (24 * 60 * 60 * 1000),\\n  until: new Date(),\\n  limit: 10,\\n  start: 0,\\n  order: 'desc',\\n  fields: ['message']\\n};\\n\\n//\\n// Find items logged between today and yesterday.\\n//\\nlogger.query(options, function (err, results) {\\n  if (err) {\\n    /* TODO: handle me */\\n    throw err;\\n  }\\n\\n  console.log(results);\\n});\\n</code></pre>\\n<h2>Streaming Logs</h2>\\n<p>Streaming allows you to stream your logs back from your chosen transport.</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Start at the end.\\n//\\nwinston.stream({ start: -1 }).on('log', function(log) {\\n  console.log(log);\\n});\\n</code></pre>\\n<h2>Further Reading</h2>\\n<h3>Using the Default Logger</h3>\\n<p>The default logger is accessible through the <code>winston</code> module directly. Any\\nmethod that you could call on an instance of a logger is available on the\\ndefault logger:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\n\\nwinston.log('info', 'Hello distributed log files!');\\nwinston.info('Hello again distributed logs');\\n\\nwinston.level = 'debug';\\nwinston.log('debug', 'Now my debug messages are written to console!');\\n</code></pre>\\n<p>By default, no transports are set on the default logger. You must\\nadd or remove transports via the <code>add()</code> and <code>remove()</code> methods:</p>\\n<pre><code class=\\\"language-js\\\">const files = new winston.transports.File({ filename: 'combined.log' });\\nconst console = new winston.transports.Console();\\n\\nwinston.add(console);\\nwinston.add(files);\\nwinston.remove(console);\\n</code></pre>\\n<p>Or do it with one call to configure():</p>\\n<pre><code class=\\\"language-js\\\">winston.configure({\\n  transports: [\\n    new winston.transports.File({ filename: 'somefile.log' })\\n  ]\\n});\\n</code></pre>\\n<p>For more documentation about working with each individual transport supported\\nby <code>winston</code> see the <a href=\\\"docs/transports.html\\\"><code>winston</code> Transports</a> document.</p>\\n<h3>Awaiting logs to be written in <code>winston</code></h3>\\n<p>Often it is useful to wait for your logs to be written before exiting the\\nprocess. Each instance of <code>winston.Logger</code> is also a [Node.js stream]. A\\n<code>finish</code> event will be raised when all logs have flushed to all transports\\nafter the stream has been ended.</p>\\n<pre><code class=\\\"language-js\\\">const transport = new winston.transports.Console();\\nconst logger = winston.createLogger({\\n  transports: [transport]\\n});\\n\\ntransport.on('finished', function (info) {\\n  // All `info` log messages has now been logged\\n});\\n\\nlogger.info('CHILL WINSTON!', { seriously: true });\\nlogger.end();\\n</code></pre>\\n<p>It is also worth mentioning that the logger also emits an 'error' event which\\nyou should handle or suppress if you don't want unhandled exceptions:</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Handle errors\\n//\\nlogger.on('error', function (err) { /* Do Something */ });\\n\\n//\\n// Or just suppress them.\\n//\\nlogger.emitErrs = false;\\n</code></pre>\\n<h3>Working with multiple Loggers in winston</h3>\\n<p>Often in larger, more complex, applications it is necessary to have multiple\\nlogger instances with different settings. Each logger is responsible for a\\ndifferent feature area (or category). This is exposed in <code>winston</code> in two\\nways: through <code>winston.loggers</code> and instances of <code>winston.Container</code>. In fact,\\n<code>winston.loggers</code> is just a predefined instance of <code>winston.Container</code>:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\n\\n//\\n// Configure the logger for `category1`\\n//\\nwinston.loggers.add('category1', {\\n  console: {\\n    level: 'silly',\\n    label: 'category one'\\n  },\\n  file: {\\n    filename: '/path/to/some/file'\\n  }\\n});\\n\\n//\\n// Configure the logger for `category2`\\n//\\nwinston.loggers.add('category2', {\\n  couchdb: {\\n    host: '127.0.0.1',\\n    port: 5984\\n  }\\n});\\n</code></pre>\\n<p>Now that your loggers are setup, you can require winston <em>in any file in your\\napplication</em> and access these pre-configured loggers:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\n\\n//\\n// Grab your preconfigured logger\\n//\\nconst category1 = winston.loggers.get('category1');\\n\\ncategory1.info('logging from your IoC container-based logger');\\n</code></pre>\\n<p>If you prefer to manage the <code>Container</code> yourself, you can simply instantiate one:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\nconst container = new winston.Container();\\n\\ncontainer.add('category1', {\\n  console: {\\n    level: 'silly'\\n  },\\n  file: {\\n    filename: '/path/to/some/file'\\n  }\\n});\\n</code></pre>\\n<h2>Installation</h2>\\n<pre><code class=\\\"language-bash\\\">npm install winston\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">yarn add winston\\n</code></pre>\\n<h2>Run Tests</h2>\\n<p>All of the winston tests are written with <a href=\\\"https://mochajs.org\\\"><code>mocha</code></a>, <a href=\\\"https://github.com/istanbuljs/nyc\\\"><code>nyc</code></a>, and\\n<a href=\\\"https://github.com/bigpipe/assume\\\"><code>assume</code></a>.  They can be run with <code>npm</code>.</p>\\n<pre><code class=\\\"language-bash\\\">npm test\\n</code></pre>\\n<h4>Author: <a href=\\\"http://github.com/indexzero\\\">Charlie Robbins</a></h4>\\n<h4>Contributors: <a href=\\\"https://github.com/jcrugzz\\\">Jarrett Cruger</a>, <a href=\\\"https://github.com/dabh\\\">David Hyde</a>, <a href=\\\"https://github.com/chrisalderson\\\">Chris Alderson</a></h4>\",\"docPath\":\"argo-ci/node_modules/winston/readme\",\"proj\":\"argo-ci\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docs-argo-ci-node-modules-winston-readme-html-f28b52ec311731812ef7.js","module.exports = {\"pathContext\":{\"docHtml\":\"<h1>winston</h1>\\n<p>A logger for just about everything.</p>\\n<p><a href=\\\"https://www.npmjs.com/package/winston\\\"><img src=\\\"https://img.shields.io/npm/v/winston.svg?style=flat-square\\\" alt=\\\"Version npm\\\"></a><a href=\\\"https://npmcharts.com/compare/winston?minimal=true\\\"><img src=\\\"https://img.shields.io/npm/dm/winston.svg?style=flat-square\\\" alt=\\\"npm Downloads\\\"></a><a href=\\\"https://travis-ci.org/winstonjs/winston\\\"><img src=\\\"https://img.shields.io/travis/winstonjs/winston/master.svg?style=flat-square\\\" alt=\\\"Build Status\\\"></a><a href=\\\"https://david-dm.org/winstonjs/winston\\\"><img src=\\\"https://img.shields.io/david/winstonjs/winston.svg?style=flat-square\\\" alt=\\\"Dependencies\\\"></a></p>\\n<p><a href=\\\"https://nodei.co/npm/winston/\\\"><img src=\\\"https://nodei.co/npm/winston.png?downloads=true&#x26;downloadRank=true\\\" alt=\\\"NPM\\\"></a></p>\\n<p><a href=\\\"https://gitter.im/winstonjs/winston?utm_source=badge&#x26;utm_medium=badge&#x26;utm_campaign=pr-badge&#x26;utm_content=badge\\\"><img src=\\\"https://badges.gitter.im/Join%20Chat.svg\\\" alt=\\\"Join the chat at https://gitter.im/winstonjs/winston\\\"></a></p>\\n<h2>winston@3.0.0</h2>\\n<p>See the <a href=\\\"UPGRADE-3.0.html\\\">Upgrade Guide</a> for more information. Bug reports and\\nPRs welcome!</p>\\n<h2>Looking for <code>winston@2.x</code> documentation?</h2>\\n<p>Please note that the documentation below is for <code>winston@3</code>.\\n<a href=\\\"https://github.com/winstonjs/winston/tree/2.x\\\">Read the <code>winston@2.x</code> documentation</a>.</p>\\n<h2>Motivation</h2>\\n<p><code>winston</code> is designed to be a simple and universal logging library with\\nsupport for multiple transports. A transport is essentially a storage device\\nfor your logs. Each <code>winston</code> logger can have multiple transports (see:\\n<a href=\\\"#transports\\\">Transports</a>) configured at different levels (see: <a href=\\\"#logging-levels\\\">Logging levels</a>). For\\nexample, one may want error logs to be stored in a persistent remote location\\n(like a database), but all logs output to the console or a local file.</p>\\n<p><code>winston</code> aims to decouple parts of the logging process to make it more\\nflexible and extensible. Attention is given to supporting flexibility in log\\nformatting (see: <a href=\\\"#formats\\\">Formats</a>) &#x26; levels (see: <a href=\\\"#using-custom-logging-levels\\\">Using custom logging levels</a>), and\\nensuring those APIs decoupled from the implementation of transport logging\\n(i.e. how the logs are stored / indexed, see: <a href=\\\"#adding-custom-transports\\\">Adding Custom Transports</a>) to\\nthe API that they exposed to the programmer.</p>\\n<h2>Usage</h2>\\n<p>The recommended way to use <code>winston</code> is to create your own logger. The\\nsimplest way to do this is using <code>winston.createLogger</code>:</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  level: 'info',\\n  format: winston.format.json(),\\n  transports: [\\n    //\\n    // - Write to all logs with level `info` and below to `combined.log` \\n    // - Write all logs error (and below) to `error.log`.\\n    //\\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\\n    new winston.transports.File({ filename: 'combined.log' })\\n  ]\\n});\\n\\n//\\n// If we're not in production then log to the `console` with the format:\\n// `${info.level}: ${info.message} JSON.stringify({ ...rest }) `\\n// \\nif (process.env.NODE_ENV !== 'production') {\\n  logger.add(new winston.transports.Console({\\n    format: winston.format.simple()\\n  }));\\n}\\n</code></pre>\\n<p>You may also log directly via the default logger exposed by\\n<code>require('winston')</code>, but this merely intended to be a convenient shared\\nlogger to use throughout your application if you so choose.</p>\\n<h2>Table of contents</h2>\\n<ul>\\n<li>\\n<p><a href=\\\"#logging\\\">Logging</a></p>\\n<ul>\\n<li><a href=\\\"#creating-your-own-logger\\\">Creating your logger</a></li>\\n<li><a href=\\\"#streams-objectmode-and-info-objects\\\">Streams, <code>objectMode</code>, and <code>info</code> objects</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#formats\\\">Formats</a></p>\\n<ul>\\n<li><a href=\\\"#combining-formats\\\">Combining formats</a></li>\\n<li><a href=\\\"#string-interpolation\\\">String interpolation</a></li>\\n<li><a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> Objects</a></li>\\n<li><a href=\\\"#creating-custom-formats\\\">Creating custom formats</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#logging-levels\\\">Logging levels</a></p>\\n<ul>\\n<li><a href=\\\"#using-logging-levels\\\">Using logging levels</a></li>\\n<li><a href=\\\"#using-custom-logging-levels\\\">Using custom logging levels</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#transports\\\">Transports</a></p>\\n<ul>\\n<li><a href=\\\"#multiple-transports-of-the-same-type\\\">Multiple transports of the same type</a></li>\\n<li><a href=\\\"#adding-custom-transports\\\">Adding Custom Transports</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#exceptions\\\">Exceptions</a></p>\\n<ul>\\n<li><a href=\\\"#handling-uncaught-exceptions-with-winston\\\">Handling Uncaught Exceptions with winston</a></li>\\n<li><a href=\\\"#to-exit-or-not-to-exit\\\">To Exit or Not to Exit</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#profiling\\\">Profiling</a></li>\\n<li><a href=\\\"#streaming-logs\\\">Streaming Logs</a></li>\\n<li><a href=\\\"#querying-logs\\\">Querying Logs</a></li>\\n<li>\\n<p><a href=\\\"#further-reading\\\">Further Reading</a></p>\\n<ul>\\n<li><a href=\\\"#using-the-default-logger\\\">Using the default logger</a></li>\\n<li><a href=\\\"#awaiting-logs-to-be-written-in-winston\\\">Awaiting logs to be written in <code>winston</code></a></li>\\n<li><a href=\\\"#working-with-multiple-loggers-in-winston\\\">Working with multiple Loggers in <code>winston</code></a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#installation\\\">Installation</a></li>\\n<li><a href=\\\"#run-tests\\\">Run Tests</a></li>\\n</ul>\\n<h2>Logging</h2>\\n<p>Logging levels in <code>winston</code> conform to the severity ordering specified by\\n<a href=\\\"https://tools.ietf.org/html/rfc5424\\\">RFC5424</a>: <em>severity of all levels is assumed to be numerically <strong>ascending</strong>\\nfrom most important to least important.</em></p>\\n<pre><code class=\\\"language-js\\\">const levels = { \\n  error: 0, \\n  warn: 1, \\n  info: 2, \\n  verbose: 3, \\n  debug: 4, \\n  silly: 5 \\n};\\n</code></pre>\\n<h3>Creating your own Logger</h3>\\n<p>You get started by creating a logger using <code>winston.createLogger</code>:</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.Console(),\\n    new winston.transports.File({ filename: 'combined.log' })\\n  ]\\n});\\n</code></pre>\\n<p>A logger acceptsÂ the following parameters:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>level</code></td>\\n<td><code>'info'</code></td>\\n<td>Log only if \\n<a href=\\\"#streams-objectmode-and-info-objects\\\"><code>info.level</code></a>\\n less than or equal to this level</td>\\n</tr>\\n<tr>\\n<td><code>levels</code></td>\\n<td><code>winston.config.npm</code></td>\\n<td>Levels (and colors) representing log priorities</td>\\n</tr>\\n<tr>\\n<td><code>format</code></td>\\n<td><code>winston.format.json</code></td>\\n<td>Formatting for \\n<code>info</code>\\n messages  (see: \\n<a href=\\\"#formats\\\">Formats</a>\\n)</td>\\n</tr>\\n<tr>\\n<td><code>transports</code></td>\\n<td><code>[]</code>\\n \\n<em>(No transports)</em></td>\\n<td>Set of logging targets for \\n<code>info</code>\\n messages</td>\\n</tr>\\n<tr>\\n<td><code>exitOnError</code></td>\\n<td><code>true</code></td>\\n<td>If false, handled exceptions will not cause \\n<code>process.exit</code></td>\\n</tr>\\n<tr>\\n<td><code>silent</code></td>\\n<td><code>false</code></td>\\n<td>If true, all logs are suppressed</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>The levels provided to <code>createLogger</code> will be defined as convenience methods\\non the <code>logger</code> returned. </p>\\n<pre><code class=\\\"language-js\\\">//\\n// Logging\\n//\\nlogger.log({\\n  level: 'info',\\n  message: 'Hello distributed log files!'\\n});\\n\\nlogger.info('Hello again distributed logs');\\n</code></pre>\\n<p>You can add or remove transports from the <code>logger</code> once it has been provided\\nto you from <code>winston.createLogger</code>:</p>\\n<pre><code class=\\\"language-js\\\">const files = new winston.transports.File({ filename: 'combined.log' });\\nconst console = new winston.transports.Console();\\n\\nlogger\\n  .clear()          // Remove all transports\\n  .add(console)     // Add console transport\\n  .add(files)       // Add file transport\\n  .remove(console); // Remove console transport\\n</code></pre>\\n<p>You can also wholesale reconfigure a <code>winston.Logger</code> instance using the\\n<code>configure</code> method:</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  level: 'info',\\n  transports: [\\n    new winston.transports.Console(),\\n    new winston.transports.File({ filename: 'combined.log' })\\n  ]\\n});\\n\\n//\\n// Replaces the previous transports with those in the\\n// new configuration wholesale.\\n//\\nconst DailyRotateFile = require('winston-daily-rotate-file');\\nlogger.configure({\\n  level: 'verbose',\\n  transports: [\\n    new DailyRotateFile(opts)\\n  ]\\n});\\n</code></pre>\\n<h3>Streams, <code>objectMode</code>, and <code>info</code> objects</h3>\\n<p>In <code>winston</code>, both <code>Logger</code> and <code>Transport</code> instances are treated as\\n<a href=\\\"https://nodejs.org/api/stream.html#stream_object_mode\\\"><code>objectMode</code></a>\\nstreams that accept an <code>info</code> object. The <code>info</code> object represents a\\nsingle log message. The object itself is mutable. Every <code>info</code> must\\nhave at least the <code>level</code> and <code>message</code> properties:</p>\\n<pre><code class=\\\"language-js\\\">{\\n  level: 'info',                 // Level of the logging message  \\n  message: 'Hey! Log something?' // Descriptive message being logged.\\n}\\n</code></pre>\\n<p><code>winston.format</code> itself exposes several additional properties:</p>\\n<ul>\\n<li><code>splat</code>: string interpolation splat for <code>%d %s</code>-style messages.</li>\\n<li><code>timestamp</code>: timestamp the message was received.</li>\\n<li><code>label</code>: custom label associated with each message.</li>\\n</ul>\\n<p>As a consumer you may add whatever properties you wish âÂ <em>internal state is\\nmaintained by <code>Symbol</code> properties:</em></p>\\n<ul>\\n<li><code>Symbol.for('level')</code> <em><strong>(READ-ONLY)</strong>:</em> equal to <code>level</code> property. Is\\ntreated as immutable by all code.  </li>\\n<li><code>Symbol.for('message'):</code> complete string message set by \\\"finalizing\\nformats\\\": <code>json</code>, <code>logstash</code>, <code>printf</code>, <code>prettyPrint</code>, and <code>simple</code>. </li>\\n</ul>\\n<h2>Formats</h2>\\n<p>Formats in <code>winston</code> can be accessed from <code>winston.format</code>. They are\\nimplemented in <a href=\\\"https://github.com/winstonjs/logform\\\"><code>logform</code></a>, a separate\\nmodule from <code>winston</code>. This allows flexibility when writing your own transports\\nin case you wish to include a default format with your transport.</p>\\n<p>In modern versions of <code>node</code> template strings are very performant and are the\\nrecommended way for doing most end-user formatting. If you want to bespoke\\nformat your logs, <code>winston.format.printf</code> is for you:</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\nconst { combine, timestamp, label, printf } = format;\\n\\nconst myFormat = printf(info => {\\n  return `${info.timestamp} [${info.label}] ${info.level}: ${info.message}`;\\n});\\n\\nconst logger = createLogger({\\n  format: combine(\\n    label({ label: 'right meow!' }),\\n    timestamp(),\\n    myFormat\\n  ),\\n  transports: [new transports.Console()]\\n});\\n</code></pre>\\n<p>To see what built-in formats are available and learn more about creating your\\nown custom logging formats, see\\n<a href=\\\"https://github.com/winstonjs/logform\\\"><code>logform</code></a>.</p>\\n<h3>Combining formats</h3>\\n<p>Any number of formats may be combined into a single format using\\n<code>format.combine</code>. Since <code>format.combine</code> takes no <code>opts</code>, as a convenience it\\nreturns pre-created instance of the combined format.</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\nconst { combine, timestamp, label, prettyPrint } = format;\\n\\nconst logger = createLogger({\\n  format: combine(\\n    label({ label: 'right meow!' }),\\n    timestamp(),\\n    prettyPrint()\\n  ),\\n  transports: [new transports.Console()]\\n})\\n\\nlogger.log({\\n  level: 'info',\\n  message: 'What time is the testing at?'\\n});\\n// Outputs:\\n// { level: 'info',\\n//   message: 'What time is the testing at?',\\n//   label: 'right meow!',\\n//   timestamp: '2017-09-30T03:57:26.875Z' }\\n</code></pre>\\n<h3>String interpolation</h3>\\n<p>The <code>log</code> method provides the string interpolation using <a href=\\\"https://nodejs.org/dist/latest/docs/api/util.html#util_util_format_format_args\\\">util.format</a>. <strong>It\\nmust be enabled using <code>format.splat</code>.</strong></p>\\n<p>Below is an example that defines a format with string interpolation of\\nmessages using <code>format.splat</code> and then serializes the entire <code>info</code> message\\nusing <code>format.simple</code>.</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\nconst logger = createLogger({\\n  format: format.combine(\\n    format.splat(),\\n    format.simple()\\n  ),\\n  transports: [new transports.Console()]\\n});\\n\\n//Â info: test message my string {}\\nlogger.log('info', 'test message %s', 'my string');\\n\\n//Â info: test message 123 {}\\nlogger.log('info', 'test message %d', 123);\\n\\n// info: test message first second {number: 123}\\nlogger.log('info', 'test message %s, %s', 'first', 'second', { number: 123 });\\n</code></pre>\\n<h3>Filtering <code>info</code> Objects</h3>\\n<p>If you wish to filter out a given <code>info</code> Object completely when logging then\\nsimply return a falsey value.</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, format, transports } = require('winston');\\n\\n// Ignore log messages if they have { private: true }\\nconst ignorePrivate = format((info, opts) => {\\n  if (info.private) { return false; }\\n  return info;\\n});\\n\\nconst logger = createLogger({\\n  format: format.combine(\\n    ignorePrivate(),\\n    format.json()\\n  ),\\n  transports: [new transports.Console()]\\n});\\n\\n// Outputs: {\\\"level\\\":\\\"error\\\",\\\"message\\\":\\\"Public error to share\\\"}\\nlogger.log({\\n  level: 'error',\\n  message: 'Public error to share'\\n});\\n\\n// Messages with { private: true } will not be written when logged.\\nlogger.log({\\n  private: true,\\n  level: 'error',\\n  message: 'This is super secret - hide it.'\\n});\\n</code></pre>\\n<p>Use of <code>format.combine</code> will respect any falsey values return and stop\\nevaluation of later formats in the series. For example:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('winston');\\nconst { combine, timestamp, label } = format;\\n\\nconst willNeverThrow = format.combine(\\n  format(info => { return false })(), // Ignores everything\\n  format(info => { throw new Error('Never reached') })()\\n);\\n</code></pre>\\n<h3>Creating custom formats</h3>\\n<p>Formats are prototypal objects (i.e. class instances) that define a single\\nmethod: <code>transform(info, opts)</code> and return the mutated <code>info</code>:</p>\\n<ul>\\n<li><code>info</code>: an object representing the log message.</li>\\n<li><code>opts</code>: setting specific to the current instance of the format.</li>\\n</ul>\\n<p>They are expected to return one of two things:</p>\\n<ul>\\n<li><strong>An <code>info</code> Object</strong> representing the modified <code>info</code> argument. Object\\nreferences need not be preservedÂ if immutability is preferred. All current\\nbuilt-in formats consider <code>info</code> mutable, but [immutablejs] is being\\nconsidered for future releases.</li>\\n<li><strong>A falsey value</strong> indicating that the <code>info</code> argument should be ignored by the\\ncaller. (See: <a href=\\\"#filtering-info-objects\\\">Filtering <code>info</code> Objects</a>) below.</li>\\n</ul>\\n<p><code>winston.format</code> is designed to be as simple as possible. To define a new\\nformat simple pass it a <code>transform(info, opts)</code> function to get a new\\n<code>Format</code>.</p>\\n<p>The named <code>Format</code> returned can be used to create as many copies of the given\\n<code>Format</code> as desired:</p>\\n<pre><code class=\\\"language-js\\\">const { format } = require('winston');\\n\\nconst volume = format((info, opts) => {\\n  if (opts.yell) {\\n    info.message = info.message.toUpperCase();\\n  } else if (opts.whisper) {\\n    info.message = info.message.toLowerCase();\\n  }\\n\\n  return info;\\n});\\n\\n// `volume` is now a function that returns instances of the format.\\nconst scream = volume({ yell: true });\\nconsole.dir(scream.transform({\\n  level: 'info',\\n  message: `sorry for making you YELL in your head!`\\n}, scream.options));\\n// {\\n//   level: 'info'\\n//   message: 'SORRY FOR MAKING YOU YELL IN YOUR HEAD!'\\n// }\\n\\n// `volume` can be used multiple times to create different formats.\\nconst whisper = volume({ whisper: true });\\nconsole.dir(whisper.transform({\\n  level: 'info',\\n  message: `WHY ARE THEY MAKING US YELL SO MUCH!`\\n}, whisper.options));\\n// {\\n//   level: 'info'\\n//   message: 'why are they making us yell so much!'\\n// }\\n</code></pre>\\n<h2>Logging Levels</h2>\\n<p>Logging levels in <code>winston</code> conform to the severity ordering specified by\\n<a href=\\\"https://tools.ietf.org/html/rfc5424\\\">RFC5424</a>: <em>severity of all levels is assumed to be numerically <strong>ascending</strong>\\nfrom most important to least important.</em></p>\\n<p>Each <code>level</code> is given a specific integer priority. The higher the priority the\\nmore important the message is considered to be, and the lower the\\ncorresponding integer priority.  For example, as specified exactly in RFC5424\\nthe <code>syslog</code> levels are prioritized from 0 to 7 (highest to lowest).</p>\\n<pre><code class=\\\"language-js\\\">{ \\n  emerg: 0, \\n  alert: 1, \\n  crit: 2, \\n  error: 3, \\n  warning: 4, \\n  notice: 5, \\n  info: 6, \\n  debug: 7\\n}\\n</code></pre>\\n<p>Similarly, <code>npm</code> logging levels are prioritized from 0 to 5 (highest to\\nlowest):</p>\\n<pre><code class=\\\"language-js\\\">{ \\n  error: 0, \\n  warn: 1, \\n  info: 2, \\n  verbose: 3, \\n  debug: 4, \\n  silly: 5 \\n}\\n</code></pre>\\n<p>If you do not explicitly define the levels that <code>winston</code> should use the\\n<code>npm</code> levels above will be used.</p>\\n<h3>Using Logging Levels</h3>\\n<p>Setting the level for your logging message can be accomplished in one of two\\nways. You can pass a string representing the logging level to the log() method\\nor use the level specified methods defined on every winston Logger.</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Any logger instance\\n//\\nlogger.log('silly', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('debug', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('verbose', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('info', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('warn', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.log('error', \\\"127.0.0.1 - there's no place like home\\\");\\nlogger.info(\\\"127.0.0.1 - there's no place like home\\\");\\nlogger.warn(\\\"127.0.0.1 - there's no place like home\\\");\\nlogger.error(\\\"127.0.0.1 - there's no place like home\\\");\\n\\n//\\n// Default logger\\n//\\nwinston.log('info', \\\"127.0.0.1 - there's no place like home\\\");\\nwinston.info(\\\"127.0.0.1 - there's no place like home\\\");\\n</code></pre>\\n<p><code>winston</code> allows you to define a <code>level</code> property on each transport which\\nspecifies the <strong>maximum</strong> level of messages that a transport should log. For\\nexample, using the <code>syslog</code> levels you could log only <code>error</code> messages to the\\nconsole and everything <code>info</code> and below to a file (which includes <code>error</code>\\nmessages):</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  levels: winston.config.syslog.levels,\\n  transports: [\\n    new winston.transports.Console({ level: 'error' }),\\n    new winston.transports.File({\\n      filename: 'combined.log',\\n      level: 'info'\\n    })\\n  ]\\n});\\n</code></pre>\\n<p>You may also dynamically change the log level of a transport:</p>\\n<pre><code class=\\\"language-js\\\">const transports = {\\n  console: new winston.transports.Console({ level: 'warn' }),\\n  file: new winston.transports.File({ filename: 'combined.log', level: 'error' })\\n};\\n\\nconst logger = winston.createLogger({\\n  transports: [\\n    transports.console,\\n    transports.file\\n  ]\\n});\\n\\nlogger.info('Will not be logged in either transport!');\\ntransports.console.level = 'info';\\ntransports.file.level = 'info';\\nlogger.info('Will be logged in both transports!');\\n</code></pre>\\n<p><code>winston</code> supports customizable logging levels, defaulting to npm style\\nlogging levels. Levels must be specified at the time of creating your logger.</p>\\n<h3>Using Custom Logging Levels</h3>\\n<p>In addition to the predefined <code>npm</code>, <code>syslog</code>, and <code>cli</code> levels available in\\n<code>winston</code>, you can also choose to define your own:</p>\\n<pre><code class=\\\"language-js\\\">const myCustomLevels = {\\n  levels: {\\n    foo: 0,\\n    bar: 1,\\n    baz: 2,\\n    foobar: 3\\n  },\\n  colors: {\\n    foo: 'blue',\\n    bar: 'green',\\n    baz: 'yellow',\\n    foobar: 'red'\\n  }\\n};\\n\\nconst customLevelLogger = winston.createLogger({ \\n  levels: myCustomLevels.levels \\n});\\n\\ncustomLevelLogger.foobar('some foobar level-ed message');\\n</code></pre>\\n<p>Although there is slight repetition in this data structure, it enables simple\\nencapsulation if you do not want to have colors. If you do wish to have\\ncolors, in addition to passing the levels to the Logger itself, you must make\\nwinston aware of them:</p>\\n<pre><code class=\\\"language-js\\\">winston.addColors(myCustomLevels.colors);\\n</code></pre>\\n<p>This enables loggers using the <code>colorize</code> formatter to appropriately color and style\\nthe output of custom levels.</p>\\n<p>Additionally, you can also change background color and font style.\\nFor example,</p>\\n<pre><code class=\\\"language-js\\\">baz: 'italic yellow',\\nfoobar: 'bold red cyanBG'\\n</code></pre>\\n<p>Possible options are below.</p>\\n<ul>\\n<li>\\n<p>Font styles: <code>bold</code>, <code>dim</code>, <code>italic</code>, <code>underline</code>, <code>inverse</code>, <code>hidden</code>,\\n<code>strikethrough</code>.</p>\\n</li>\\n<li>\\n<p>Font foreground colors: <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>,\\n<code>cyan</code>, <code>white</code>, <code>gray</code>, <code>grey</code>.</p>\\n</li>\\n<li>\\n<p>Background colors: <code>blackBG</code>, <code>redBG</code>, <code>greenBG</code>, <code>yellowBG</code>, <code>blueBG</code>\\n<code>magentaBG</code>, <code>cyanBG</code>, <code>whiteBG</code></p>\\n</li>\\n</ul>\\n<h3>Colorizing Standard logging levels</h3>\\n<p>To colorize the standard logging level add</p>\\n<pre><code class=\\\"language-js\\\">winston.format.combine(\\n  winston.format.colorize(),\\n  winston.format.json()\\n);\\n</code></pre>\\n<p>where <code>winston.format.json()</code> is whatever other formatter you want to use.  The <code>colorize</code> formatter must come before any formatters adding text you wish to color.</p>\\n<h2>Transports</h2>\\n<p>There are several <a href=\\\"docs/transports.md#winston-core\\\">core transports</a> included in  <code>winston</code>, which leverage the\\nbuilt-in networking and file I/O offered by Node.js core. In addition, there\\nare <a href=\\\"docs/transports.md#additional-transports\\\">additional transports</a> written by members of the community.</p>\\n<h2>Multiple transports of the same type</h2>\\n<p>It is possible to use multiple transports of the same type e.g.\\n<code>winston.transports.File</code> when you construct the transport.</p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.File({\\n      filename: 'combined.log',\\n      level: 'info'\\n    }),\\n    new winston.transports.File({\\n      filename: 'errors.log',\\n      level: 'error'\\n    })\\n  ]\\n});\\n</code></pre>\\n<p>If you later want to remove one of these transports you can do so by using the\\ntransport itself. e.g.:</p>\\n<pre><code class=\\\"language-js\\\">const combinedLogs = logger.transports.find(transport => {\\n  return transport.filename === 'combined.log'\\n});\\n\\nlogger.remove(combinedLogs);\\n</code></pre>\\n<h2>Adding Custom Transports</h2>\\n<p>Adding a custom transport is easy. All you need to do is accept any options\\nyou need, implement a log() method, and consume it with <code>winston</code>.</p>\\n<pre><code class=\\\"language-js\\\">const Transport = require('winston-transport');\\nconst util = require('util');\\n\\n//\\n// Inherit from `winston-transport` so you can take advantage\\n// of the base functionality and `.exceptions.handle()`.\\n//\\nmodule.exports = class YourCustomTransport extends Transport {\\n  constructor(opts) {\\n    super(opts);\\n    //\\n    // Consume any custom options here. e.g.:\\n    // - Connection information for databases\\n    // - Authentication information for APIs (e.g. loggly, papertrail, \\n    //   logentries, etc.).\\n    //\\n  }\\n\\n  log(info, callback) {\\n    setImmediate(() => {\\n      this.emit('logged', info);\\n    });\\n\\n    // Perform the writing to the remote service\\n    callback();\\n  }\\n};\\n</code></pre>\\n<h2>Exceptions</h2>\\n<h3>Handling Uncaught Exceptions with winston</h3>\\n<p>With <code>winston</code>, it is possible to catch and log <code>uncaughtException</code> events\\nfrom your process. With your own logger instance you can enable this behavior\\nwhen it's created or later on in your applications lifecycle:</p>\\n<pre><code class=\\\"language-js\\\">const { createLogger, transports } = require('winston');\\n\\n// Enable exception handling when you create your logger.\\nconst logger = createLogger({\\n  transports: [\\n    new transports.File({ filename: 'combined.log' }) \\n  ],\\n  exceptionHandlers: [\\n    new transports.File({ filename: 'exceptions.log' })\\n  ]\\n});\\n\\n// Or enable it later on by adding a transport or using `.exceptions.handle`\\nconst logger = createLogger({\\n  transports: [\\n    new transports.File({ filename: 'combined.log' }) \\n  ]\\n});\\n\\n// Call exceptions.handle with a transport to handle exceptions\\nlogger.exceptions.handle(\\n  new transports.File({ filename: 'exceptions.log' })\\n);\\n</code></pre>\\n<p>If you want to use this feature with the default logger, simply call\\n<code>.exceptions.handle()</code> with a transport instance.</p>\\n<pre><code class=\\\"language-js\\\">//\\n// You can add a separate exception logger by passing it to `.exceptions.handle`\\n//\\nwinston.exceptions.handle(\\n  new winston.transports.File({ filename: 'path/to/exceptions.log' })\\n);\\n\\n//\\n// Alternatively you can set `handleExceptions` to true when adding transports\\n// to winston.\\n//\\nwinston.add(new winston.transports.File({\\n  filename: 'path/to/combined.log',\\n  handleExceptions: true\\n}));\\n</code></pre>\\n<h3>To Exit or Not to Exit</h3>\\n<p>By default, winston will exit after logging an uncaughtException. If this is\\nnot the behavior you want, set <code>exitOnError = false</code></p>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({ exitOnError: false });\\n\\n//\\n// or, like this:\\n//\\nlogger.exitOnError = false;\\n</code></pre>\\n<p>When working with custom logger instances, you can pass in separate transports\\nto the <code>exceptionHandlers</code> property or set <code>handleExceptions</code> on any\\ntransport.</p>\\n<h5>Example 1</h5>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.File({ filename: 'path/to/combined.log' })\\n  ],\\n  exceptionHandlers: [\\n    new winston.transports.File({ filename: 'path/to/exceptions.log' })\\n  ]\\n});\\n</code></pre>\\n<h5>Example 2</h5>\\n<pre><code class=\\\"language-js\\\">const logger = winston.createLogger({\\n  transports: [\\n    new winston.transports.Console({\\n      handleExceptions: true\\n    })\\n  ],\\n  exitOnError: false\\n});\\n</code></pre>\\n<p>The <code>exitOnError</code> option can also be a function to prevent exit on only\\ncertain types of errors:</p>\\n<pre><code class=\\\"language-js\\\">function ignoreEpipe(err) {\\n  return err.code !== 'EPIPE';\\n}\\n\\nconst logger = winston.createLogger({ exitOnError: ignoreEpipe });\\n\\n//\\n// or, like this:\\n//\\nlogger.exitOnError = ignoreEpipe;\\n</code></pre>\\n<h2>Profiling</h2>\\n<p>In addition to logging messages and metadata, <code>winston</code> also has a simple\\nprofiling mechanism implemented for any logger:</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Start profile of 'test'\\n//\\nlogger.profile('test');\\n\\nsetTimeout(function () {\\n  //\\n  // Stop profile of 'test'. Logging will now take place:\\n  //   '17 Jan 21:00:00 - info: test duration=1000ms'\\n  //\\n  logger.profile('test');\\n}, 1000);\\n</code></pre>\\n<p>Also you can start a timer and keep a reference that you can call `.done()<code></code>\\non:</p>\\n<pre><code class=\\\"language-js\\\"> // Returns an object corresponding to a specific timing. When done\\n // is called the timer will finish and log the duration. e.g.:\\n //\\n const profiler = logger.startTimer();\\n setTimeout(function () {\\n   profiler.done({ message: 'Logging message' });\\n }, 1000);\\n</code></pre>\\n<p>All profile messages are set to 'info' level by default, and both message and\\nmetadata are optional.  For individual profile messages, you can override the default log level by supplying a metadata object with a <code>level</code> property:</p>\\n<pre><code class=\\\"language-js\\\">logger.profile('test', { level: 'debug' });\\n</code></pre>\\n<h2>Querying Logs</h2>\\n<p><code>winston</code> supports querying of logs with Loggly-like options. <a href=\\\"https://www.loggly.com/docs/api-retrieving-data/\\\">See Loggly\\nSearch API</a>. Specifically:\\n<code>File</code>, <code>Couchdb</code>, <code>Redis</code>, <code>Loggly</code>, <code>Nssocket</code>, and <code>Http</code>.</p>\\n<pre><code class=\\\"language-js\\\">const options = {\\n  from: new Date() - (24 * 60 * 60 * 1000),\\n  until: new Date(),\\n  limit: 10,\\n  start: 0,\\n  order: 'desc',\\n  fields: ['message']\\n};\\n\\n//\\n// Find items logged between today and yesterday.\\n//\\nlogger.query(options, function (err, results) {\\n  if (err) {\\n    /* TODO: handle me */\\n    throw err;\\n  }\\n\\n  console.log(results);\\n});\\n</code></pre>\\n<h2>Streaming Logs</h2>\\n<p>Streaming allows you to stream your logs back from your chosen transport.</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Start at the end.\\n//\\nwinston.stream({ start: -1 }).on('log', function(log) {\\n  console.log(log);\\n});\\n</code></pre>\\n<h2>Further Reading</h2>\\n<h3>Using the Default Logger</h3>\\n<p>The default logger is accessible through the <code>winston</code> module directly. Any\\nmethod that you could call on an instance of a logger is available on the\\ndefault logger:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\n\\nwinston.log('info', 'Hello distributed log files!');\\nwinston.info('Hello again distributed logs');\\n\\nwinston.level = 'debug';\\nwinston.log('debug', 'Now my debug messages are written to console!');\\n</code></pre>\\n<p>By default, no transports are set on the default logger. You must\\nadd or remove transports via the <code>add()</code> and <code>remove()</code> methods:</p>\\n<pre><code class=\\\"language-js\\\">const files = new winston.transports.File({ filename: 'combined.log' });\\nconst console = new winston.transports.Console();\\n\\nwinston.add(console);\\nwinston.add(files);\\nwinston.remove(console);\\n</code></pre>\\n<p>Or do it with one call to configure():</p>\\n<pre><code class=\\\"language-js\\\">winston.configure({\\n  transports: [\\n    new winston.transports.File({ filename: 'somefile.log' })\\n  ]\\n});\\n</code></pre>\\n<p>For more documentation about working with each individual transport supported\\nby <code>winston</code> see the <a href=\\\"docs/transports.html\\\"><code>winston</code> Transports</a> document.</p>\\n<h3>Awaiting logs to be written in <code>winston</code></h3>\\n<p>Often it is useful to wait for your logs to be written before exiting the\\nprocess. Each instance of <code>winston.Logger</code> is also a [Node.js stream]. A\\n<code>finish</code> event will be raised when all logs have flushed to all transports\\nafter the stream has been ended.</p>\\n<pre><code class=\\\"language-js\\\">const transport = new winston.transports.Console();\\nconst logger = winston.createLogger({\\n  transports: [transport]\\n});\\n\\ntransport.on('finished', function (info) {\\n  // All `info` log messages has now been logged\\n});\\n\\nlogger.info('CHILL WINSTON!', { seriously: true });\\nlogger.end();\\n</code></pre>\\n<p>It is also worth mentioning that the logger also emits an 'error' event which\\nyou should handle or suppress if you don't want unhandled exceptions:</p>\\n<pre><code class=\\\"language-js\\\">//\\n// Handle errors\\n//\\nlogger.on('error', function (err) { /* Do Something */ });\\n\\n//\\n// Or just suppress them.\\n//\\nlogger.emitErrs = false;\\n</code></pre>\\n<h3>Working with multiple Loggers in winston</h3>\\n<p>Often in larger, more complex, applications it is necessary to have multiple\\nlogger instances with different settings. Each logger is responsible for a\\ndifferent feature area (or category). This is exposed in <code>winston</code> in two\\nways: through <code>winston.loggers</code> and instances of <code>winston.Container</code>. In fact,\\n<code>winston.loggers</code> is just a predefined instance of <code>winston.Container</code>:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\n\\n//\\n// Configure the logger for `category1`\\n//\\nwinston.loggers.add('category1', {\\n  console: {\\n    level: 'silly',\\n    label: 'category one'\\n  },\\n  file: {\\n    filename: '/path/to/some/file'\\n  }\\n});\\n\\n//\\n// Configure the logger for `category2`\\n//\\nwinston.loggers.add('category2', {\\n  couchdb: {\\n    host: '127.0.0.1',\\n    port: 5984\\n  }\\n});\\n</code></pre>\\n<p>Now that your loggers are setup, you can require winston <em>in any file in your\\napplication</em> and access these pre-configured loggers:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\n\\n//\\n// Grab your preconfigured logger\\n//\\nconst category1 = winston.loggers.get('category1');\\n\\ncategory1.info('logging from your IoC container-based logger');\\n</code></pre>\\n<p>If you prefer to manage the <code>Container</code> yourself, you can simply instantiate one:</p>\\n<pre><code class=\\\"language-js\\\">const winston = require('winston');\\nconst container = new winston.Container();\\n\\ncontainer.add('category1', {\\n  console: {\\n    level: 'silly'\\n  },\\n  file: {\\n    filename: '/path/to/some/file'\\n  }\\n});\\n</code></pre>\\n<h2>Installation</h2>\\n<pre><code class=\\\"language-bash\\\">npm install winston\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">yarn add winston\\n</code></pre>\\n<h2>Run Tests</h2>\\n<p>All of the winston tests are written with <a href=\\\"https://mochajs.org\\\"><code>mocha</code></a>, <a href=\\\"https://github.com/istanbuljs/nyc\\\"><code>nyc</code></a>, and\\n<a href=\\\"https://github.com/bigpipe/assume\\\"><code>assume</code></a>.  They can be run with <code>npm</code>.</p>\\n<pre><code class=\\\"language-bash\\\">npm test\\n</code></pre>\\n<h4>Author: <a href=\\\"http://github.com/indexzero\\\">Charlie Robbins</a></h4>\\n<h4>Contributors: <a href=\\\"https://github.com/jcrugzz\\\">Jarrett Cruger</a>, <a href=\\\"https://github.com/dabh\\\">David Hyde</a>, <a href=\\\"https://github.com/chrisalderson\\\">Chris Alderson</a></h4>\",\"docPath\":\"argo-ci/node_modules/winston/readme\",\"proj\":\"argo-ci\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docs-argo-ci-node-modules-winston-readme-html.json\n// module id = 3404\n// module chunks = 28209167537949"],"sourceRoot":""}