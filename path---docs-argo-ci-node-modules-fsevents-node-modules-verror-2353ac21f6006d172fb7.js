webpackJsonp([0x85fd2e0bc572],{2619:function(e,r){e.exports={pathContext:{docHtml:"<h1>verror: richer JavaScript errors</h1>\n<p>This module provides two classes: VError, for accretive errors, and WError, for\nwrapping errors.  Both support printf-style error messages using extsprintf.</p>\n<h2>Printf-style errors</h2>\n<p>At the most basic level, VError is just like JavaScript's Error class, but with\nprintf-style arguments:</p>\n<pre><code>var verror = require('verror');\n\nvar opname = 'read';\nvar err = new verror.VError('\"%s\" operation failed', opname);\nconsole.log(err.message);\nconsole.log(err.stack);\n</code></pre>\n<p>This prints:</p>\n<pre><code>\"read\" operation failed\n\"read\" operation failed\n    at Object.&#x3C;anonymous> (/Users/dap/node-verror/examples/varargs.js:4:11)\n    at Module._compile (module.js:449:26)\n    at Object.Module._extensions..js (module.js:467:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Module.runMain (module.js:492:10)\n    at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n</code></pre>\n<h2>VError for accretive error messages</h2>\n<p>More interestingly, you can use VError to build up an error describing what\nhappened at various levels in the stack.  For example, suppose you have a\nrequest handler that stats a file and fails if it doesn't exist:</p>\n<pre><code>var fs = require('fs');\nvar verror = require('verror');\n\nfunction checkFile(filename, callback) {\n    fs.stat(filename, function (err) {\n        if (err)\n    /* Annotate the \"stat\" error with what we were doing. */\n        return (callback(new verror.VError(err,\n        'failed to check \"%s\"', filename)));\n\n    /* ... */\n    });\n}\n\nfunction handleRequest(filename, callback) {\n    checkFile('/nonexistent', function (err) {\n        if (err) {\n            /* Annotate the \"checkFile\" error with what we were doing. */\n            return (callback(new verror.VError(err, 'request failed')));\n        }\n\n        /* ... */\n    });\n}\n\nhandleRequest('/nonexistent', function (err) {\nif (err)\n    console.log(err.message);\n/* ... */\n});\n</code></pre>\n<p>Since the file \"/nonexistent\" doesn't exist, this prints out:</p>\n<pre><code>request failed: failed to check \"/nonexistent\": ENOENT, stat '/nonexistent'\n</code></pre>\n<p>The idea here is that the lowest level (Node's \"fs.stat\" function) generates an\narbitrary error, and each higher level (request handler and stat callback)\ncreates a new VError that annotates the previous error with what it was doing,\nso that the result is a clear message explaining what failed at each level.</p>\n<p>This plays nicely with extsprintf's \"%r\" specifier, which prints out a\nJava-style stacktrace with the whole chain of exceptions:</p>\n<pre><code>EXCEPTION: VError: request failed: failed to check \"/nonexistent\": ENOENT, stat '/nonexistent'\n    at /Users/dap/work/node-verror/examples/levels.js:21:21\n    at /Users/dap/work/node-verror/examples/levels.js:9:12\n    at Object.oncomplete (fs.js:297:15)\nCaused by: EXCEPTION: VError: failed to check \"/nonexistent\": ENOENT, stat '/nonexistent'\n    at /Users/dap/work/node-verror/examples/levels.js:9:21\n    at Object.oncomplete (fs.js:297:15)\nCaused by: EXCEPTION: Error: Error: ENOENT, stat '/nonexistent'\n</code></pre>\n<h2>WError for wrapped errors</h2>\n<p>Sometimes you don't want an Error's \"message\" field to include the details of\nall of the low-level errors, but you still want to be able to get at them\nprogrammatically.  For example, in an HTTP server, you probably don't want to\nspew all of the low-level errors back to the client, but you do want to include\nthem in the audit log entry for the request.  In that case, you can use a\nWError, which is created exactly like VError (and also supports both\nprintf-style arguments and an optional cause), but the resulting \"message\" only\ncontains the top-level error.  It's also more verbose, including the class\nassociated with each error in the cause chain.  Using the same example above,\nbut replacing the VError in handleRequest with WError, we get this output:</p>\n<pre><code>request failed\n</code></pre>\n<p>That's what we wanted -- just a high-level summary for the client.  But we can\nget the object's toString() for the full details:</p>\n<pre><code>WError: request failed; caused by WError: failed to check \"/nonexistent\";\ncaused by Error: ENOENT, stat '/nonexistent'\n</code></pre>\n<h1>Contributing</h1>\n<p>Contributions welcome.  Code should be \"make check\" clean.  To run \"make check\",\nyou'll need these tools:</p>\n<ul>\n<li><a href=\"https://github.com/davepacheco/jsstyle\">https://github.com/davepacheco/jsstyle</a></li>\n<li><a href=\"https://github.com/davepacheco/javascriptlint\">https://github.com/davepacheco/javascriptlint</a></li>\n</ul>\n<p>If you're changing something non-trivial or user-facing, you may want to submit\nan issue first.</p>",docPath:"argo-ci/node_modules/fsevents/node_modules/verror/readme",proj:"argo-ci"}}}});
//# sourceMappingURL=path---docs-argo-ci-node-modules-fsevents-node-modules-verror-2353ac21f6006d172fb7.js.map